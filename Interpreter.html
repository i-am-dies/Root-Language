<html>
<body>
<style>
body {
	display: grid;
	grid-template-columns: 5fr 4fr;
	grid-template-rows: 2fr 1fr;
	grid-template-areas:
		'code trees'
		'console console';

	margin: 0;
}

#input,
#output_lint,
#output_trees,
#output_console {
	overflow: auto;

	font: 12px monospace;
	tab-size: 4;
	white-space: pre;
}

#input,
#output_lint {
	grid-area: code;

	box-sizing: border-box;

	padding: 2px;

	border: none;
	background: rgb(63 63 63 / 1);

	color: rgba(255 255 255 / 0.25);
	caret-color: white;
}

#output_lint {
	background: none;

	color: rgb(191 191 191 / 1);

	pointer-events: none;
}

#output_trees,
#output_console {
	grid-area: trees;

	overflow-x: auto;

	background: rgb(223 223 223 / 1);

	font-size: 10px;
}

#output_console {
	grid-area: console;

	background: none;
}
</style>
<textarea id="input"></textarea>
<div id="output_lint"></div>
<div id="output_trees">
	<button id="change_tree">Change tree</button>
	<div id="output_tokens" style="display: none;"></div>
	<div id="output_ast"></div>
</div>
<div id="output_console"></div>
<script>
	class Lexer {
		static code;
		static position;
		static location;
		static tokens;
		static states;
		static reports;

		static rules = [
			[['/*', '*/'], (v) => {
				if(this.atComments || this.atString) {
					this.ruleHelpers.continueString();
					this.token.value += v;
				} else
				if(v === '/*') {
					this.addToken('commentBlock', v);
				}
				if(this.token.type === 'commentBlock') {
					if(v === '/*') {
						this.addState('comment');
					} else {
						this.removeState('comment');
					}
				}
			}],
			['//', (v) => {
				if(this.atComments || this.atString) {
					this.ruleHelpers.continueString();
					this.token.value += v;
				} else {
					this.addToken('commentLine', v);
					this.addState('comment');
				}
			}],
			[['\\\\', '\\\'', '\\(', '\\b', '\\f', '\\n', '\\r', '\\t', '\\v', '\\'], (v) => {
				if(this.atComments) {
					this.token.value += v;

					return;
				}
				if(!this.atString) {
					this.addToken('unsupported', v);

					return;
				}
				if(v === '\\(') {
					return true;
				}

				this.ruleHelpers.continueString();
				this.token.value += ({
					'\\\\': '\\',
					'\\\'': '\'',
					'\\b': '\b',
					'\\f': '\f',
					'\\n': '\n',
					'\\r': '\r',
					'\\t': '\t',
					'\\v': '\v',
					'\\': ''
				})[v]
			}],
			[['\\(', ')'], (v) => {
				if(this.atComments) {
					this.token.value += v;

					return;
				}

				if(v === '\\(' && this.atString) {
					this.addToken('stringExpressionOpen', v);
					this.addState('stringExpression');
				}
				if(v === ')' && this.atStringExpression) {
					this.addToken('stringExpressionClosed');
					this.removeState('stringExpression');
				} else {
					return v === ')';
				}
			}],
			[['!', '%', '&', '*', '+', ',', '-', '.', '/', ':', '<', '=', '>', '?', '^', '|', '~'], (v) => {
				if(this.atComments || this.atString) {
					this.ruleHelpers.continueString();
					this.token.value += v;

					return;
				}

				let initializers = [',', '.', ':'],								// Create new token if value exists in the list and current (operator) token doesn't initialized with it
					singletons = ['!', '?'],									// Create new token if current (postfix operator) token matches any value in the list
					generics = ['!', '&', ',', '.', ':', '<', '>', '?', '|']	// Only values in the list are allowed for generic types

				let initializer = initializers.includes(v) && !this.token.value.startsWith(v),
					singleton = this.token.type === 'operatorPostfix' && singletons.includes(this.token.value),
					generic = generics.includes(v);

				if(!generic) {
					this.ruleHelpers.mergeOperators();
				}

				let closingAngle = this.atAngle && v === '>';

				if(this.token.type.startsWith('operator') && !initializer && !singleton && !closingAngle) {
					this.token.value += v;

					return;
				}

				let type = 'operator';

				if(singleton) {
					type = this.token.type;
				} else {
					if(
						['string', 'identifier'].includes(this.token.type) ||
						this.token.type.endsWith('Closed') ||
						this.token.type.startsWith('number') ||
						this.token.type.startsWith('keyword')
					) {
						type += 'Postfix';
					}

					this.ruleHelpers.specifyOperatorType();
				}

				this.addToken(type);
				if(initializer || singleton) {
					this.token.nonmergeable = true;
				}

				if(v === '<') this.addState('angle');
				if(v === '>') this.removeState('angle');
			}],
			[['(', ')', '[', ']', '{', '}'], (v) => {
				if(this.atComments || this.atString) {
					this.ruleHelpers.continueString();
					this.token.value += v;

					return;
				}

				let type = ({
					'(': 'parenthesisOpen',
					')': 'parenthesisClosed',
					'[': 'bracketOpen',
					']': 'bracketClosed',
					'{': 'braceOpen',
					'}': 'braceClosed'
				})[v]

				if(type.endsWith('Open')) {
					this.ruleHelpers.specifyOperatorType();
				}
				this.addToken(type);
				this.removeState('angle', 2);  // Balanced tokens except </> are allowed right after generic types but not inside them

				if(v === '{' && this.atStatement && this.atToken((t, v) => t === 'whitespace' && v.includes('\n'), this.ignorable, -1)) {
					this.addState('statementBody');

					return;
				}
				if(v === '}' && this.atStatementBody && !this.atFutureToken((t) => ['keywordElse', 'keywordWhere'].includes(t), this.ignorable)) {
					this.addToken('delimiter', ';');
					this.token.generated = true;
					this.removeState('statement');

					return;
				}

				if(this.atStringExpressions) {
					if(v === '(') this.addState('parenthesis');
					if(v === ')') this.removeState('parenthesis');
				}
				if(this.atStatements) {
					if(v === '{') this.addState('brace');
					if(v === '}') this.removeState('brace');
				}
			}],
			['\'', (v) => {
				if(this.atComments) {
					this.token.value += v;

					return;
				}

				if(!this.atString) {
					this.ruleHelpers.finalizeOperator();
					this.addToken('stringOpen');
					this.addState('string');
				} else {
					this.addToken('stringClosed');
					this.removeState('string');
				}
			}],
			[';', (v) => {
				if(this.atComments || this.atString) {
					this.ruleHelpers.continueString();
					this.token.value += v;

					return;
				}

				if(this.token.type === 'delimiter' && this.token.generated) {
					delete this.token.generated;
				} else {
					this.addToken('delimiter');
				}
			}],
			[/\n/g, (v) => {
				if(this.atComments && this.token.type !== 'commentLine' || this.atString) {
					this.ruleHelpers.continueString();
					this.token.value += v;

					return;
				}

				if(this.token.type !== 'whitespace') {
					this.addToken('whitespace', v);

					if(this.getToken(-1).type === 'commentLine') {
						this.removeState('comment');
					}
				} else {
					this.token.value += v;
				}

				if(this.atStatement && this.token.value.match(/\n/g).length === 1) {
					let braceOpen = (t) => t === 'braceOpen';

					if(this.atToken(braceOpen, this.ignorable)) {
						this.addState('statementBody');
					} else
					if(!this.atState('brace', []) && !this.atFutureToken(braceOpen, this.ignorable)) {
						this.removeState('statement');
					}
				}
			}],
			[/[^\S\n]+/g, (v) => {
				if(this.atComments || this.atString || this.token.type === 'whitespace') {
					this.ruleHelpers.continueString();
					this.token.value += v;

					return;
				}

				this.addToken('whitespace', v);
			}],
			[/[0-9]+/g, (v) => {
				if(this.atComments || this.atString) {
					this.ruleHelpers.continueString();
					this.token.value += v;

					return;
				}
				if(this.token.type === 'operatorPostfix' && this.token.value === '.' && this.getToken(-1).type === 'numberInteger') {
					this.removeToken();
					this.token.type = 'numberFloat';
					this.token.value += '.'+v;

					return;
				}

				this.ruleHelpers.finalizeOperator();
				this.addToken('numberInteger', v);
			}],
			[/[a-z_][a-z0-9_]*/gi, (v) => {
				if(this.atComments || this.atString) {
					this.ruleHelpers.continueString();
					this.token.value += v;

					return;
				}

				let keywords = [
					// Flow-related words (async, class, for, return...)
					// Literals (false, nil, true...)
					// Types (Any, bool, _, ...)

					// Words as Self, arguments, metaSelf or self are not allowed because they all
					// have dynamic values and it's logical to distinguish them at the interpretation stage

					'Any',
					'Class',
					'Enumeration',
					'Function',
					'Namespace',
					'Object',
					'Protocol',
					'Structure',
					'any', 'async', 'await', 'awaits',
					'bool', 'break',
					'case', 'catch', 'class', 'continue',
					'default', 'do',
					'else', 'enum', 'extension',
					'fallthrough', 'false', 'final', 'float', 'for', 'func',
					'if', 'import', 'in', 'infix', 'inout', 'int', 'is',
					'lazy',
					'namespace', 'nil',
					'operator',
					'postfix', 'prefix', 'private', 'protected', 'protocol', 'public',
					'return',
					'static', 'string', 'struct', 'switch',
					'throw', 'throws', 'true', 'try',
					'var',
					'where', 'while',
					'_'
				]

				this.ruleHelpers.specifyOperatorType();

				let type = 'identifier',
					chain = this.atToken((t, v) => t.startsWith('operator') && !t.endsWith('Postfix') && v === '.', this.ignorable);

				if(keywords.includes(v) && !chain) {  // Disable keywords in a chains
					type = 'keyword';

					if(v === '_') {
						type += 'Underscore';
					} else {
						let value = v[0].toUpperCase()+v.slice(1);

						type += v[0] === value[0] ? 'Capital'+value : value;
					}
				}

				if(this.atAngle && type.startsWith('keyword')) {  // No keywords are allowed in generic types
					this.ruleHelpers.mergeOperators();
				}
				this.addToken(type, v);

				if(['For', 'If', 'Switch', 'While'].some(v => type.endsWith(v))) {
					this.addState('statement');
				}
			}],
			[/./g, (v) => {
				if(this.token.type === 'commentBlock' || this.token.type === 'commentLine' && v !== '\n' || this.atString || this.token.type === 'unsupported') {
					this.ruleHelpers.continueString();
					this.token.value += v;

					return;
				}

				this.addToken('unsupported', v);
			}]
		]

		static ruleHelpers = {
			continueString: () => {
				if(['stringOpen', 'stringExpressionClosed'].includes(this.token.type)) {
					this.addToken('stringSegment', '');
				}
			},
			mergeOperators: () => {
				this.removeState('angle', 2);

				for(let i = this.tokens.length; i >= 0; i--) {
					if(
						!this.token.type.startsWith('operator') || this.token.nonmergeable ||
						!this.getToken(-1).type.startsWith('operator') || this.getToken(-1).nonmergeable
					) {
						break;
					}

					this.getToken(-1).value += this.token.value;
					this.removeToken();
				}
			},
			specifyOperatorType: () => {
				switch(this.token.type) {
					case 'operator':		this.token.type = 'operatorPrefix';	break;
					case 'operatorPostfix':	this.token.type = 'operatorInfix';	break;
				}
			},
			finalizeOperator: () => {
				this.ruleHelpers.mergeOperators();
				this.ruleHelpers.specifyOperatorType();
			}
		}

		static get codeEnd() {
			return this.position >= this.code.length;
		}

		static get token() {
			return this.getToken();
		}

		static get atComments() {
			return this.atState('comment');
		}

		static get atString() {
			return this.atState('string', []);
		}

		static get atStringExpression() {
			return this.atState('stringExpression', []);
		}

		static get atStringExpressions() {
			return this.atState('stringExpression');
		}

		static get atStatement() {
			return this.atState('statement', ['brace']);
		}

		static get atStatements() {
			return this.atState('statement');
		}

		static get atStatementBody() {
			return this.atState('statementBody', []);
		}

		static get atAngle() {
			return this.atState('angle', []);
		}

		static ignorable = (t) => t === 'whitespace' || t.startsWith('comment');

		static getToken(offset = 0) {
			return this.tokens[this.tokens.length-1+offset] ?? {
				position: undefined,
				location: undefined,
				type: '',
				value: ''
			}
		}

		static addToken(type, value) {
			this.tokens.push({
				position: this.position,
				location: {...this.location},
				type: type,
				value: value ?? this.code[this.position]
			});
		}

		static removeToken(offset = 0) {
			this.tokens = this.tokens.filter((v, k) => k !== this.tokens.length-1+offset);
		}

		/*
		 * Check for token(s) starting from rightmost (inclusively if no offset set), using combinations of type and value within predicate.
		 *
		 * Strict by default, additionally whitelist predicate can be set.
		 *
		 * Useful for complex token sequences check.
		 */
		static atToken(conforms, whitelisted, offset = 0) {
			for(let i = this.tokens.length-1+offset; i >= 0; i--) {
				let token = this.tokens[i],
					type = token.type,
					value = token.value;

				if(conforms(type, value)) {
					return true;
				}
				if(whitelisted != null && !whitelisted(type, value)) {
					return;
				}
			}
		}

		/*
		 * Future-time version of atToken(). Rightmost (at the moment) token is not included in a search.
		 */
		static atFutureToken(conforms, whitelisted) {
			let save = this.getSave(),
				result;

			this.position = this.token.position+this.token.value.length;  // Override allows nested calls

			while(!this.codeEnd) {
				this.nextToken();

				let token = this.tokens.at(-1),
					type = token?.type,
				    value = token?.value;

				if(conforms(type, value)) {
					result = true;

					break;
				}
				if(whitelisted != null && !whitelisted(type, value)) {
					break;
				}
			}

			this.restoreSave(save);

			return result;
		}

		static addState(type) {
			this.states.push(type);
		}

		/*
		 * 0 - Remove states starting from rightmost found (inclusively)
		 * 1 - 0 with subtypes, ignoring nested
		 * 2 - Remove found states globally
		 */
		static removeState(type, mode = 0) {
			if(mode === 0) {
				let i = this.states.lastIndexOf(type);

				if(i > -1) {
					this.states.length = i;
				}
			}
			if(mode === 1) {
				for(let i = this.states.length-1; i >= 0; i--) {
					let type_ = this.states[i]

					if(!type_.startsWith(type)) {
						continue;
					} else {
						this.states.splice(i, 1);
					}
					if(type_ === type) {
						break;
					}
				}
			}
			if(mode === 2) {
				this.states = this.states.filter(v => v !== type);
			}
		}

		/*
		 * Check for state starting from rightmost (inclusively).
		 *
		 * Unstrict by default, additionaly whitelist can be set.
		 */
		static atState(type, whitelist) {
			for(let i = this.states.length-1; i >= 0; i--) {
				if(this.states[i] === type) {
					return true;
				}
				if(whitelist != null && !whitelist.includes(this.states[i])) {
					return;
				}
			}
		}

		static report(level, string) {
			this.reports.push({
				level: level,
				position: this.position,
				location: {...this.location},
				string: string
			});
		}

		static getSave() {
			return {
				position: this.position,
				location: {...this.location},
				tokens: JSON.stringify(this.tokens),
				states: JSON.stringify(this.states),
				reports: this.reports.length
			}
		}

		static restoreSave(save) {
			this.position = save.position;
			this.location = {...save.location}
			this.tokens = JSON.parse(save.tokens);
			this.states = JSON.parse(save.states);
			this.reports.length = save.reports;
		}

		static reset() {
			this.code = '';
			this.position = 0;
			this.location = {
				line: 0,
				column: 0
			}
			this.tokens = []
			this.states = []
				// angle - used to distinguish between common operator and generic type's closing >
				// brace - used in statements
				// parenthesis - used in string expressions
			this.reports = []
		}

		static atSubstring(substring) {
			return this.code.indexOf(substring, this.position) === this.position;
		}

		static atRegex(regex) {
			let substring;

			if(!regex.global) {
				regex = new RegExp(regex.source, 'g');
			}

			regex.lastIndex = this.position;
			substring = regex.exec(this.code);
			substring = substring?.index === this.position ? substring[0] : undefined;

			return substring;
		}

		static nextToken() {
			for(let rule of this.rules) {
				let triggers = rule[0],
					actions = rule[1],
					plain = typeof triggers === 'string',
					array = Array.isArray(triggers),
					regex = triggers instanceof RegExp,
					trigger;

				if(plain && this.atSubstring(triggers)) {
					trigger = triggers;
				}
				if(array) {
					trigger = triggers.find(v => this.atSubstring(v));
				}
				if(regex) {
					trigger = this.atRegex(triggers);
				}

				if(trigger != null && !actions(trigger)) {  // Multiple rules can be executed on same position if some of them return true
					this.position += trigger.length;  // Rules shouldn't explicitly set position

					for(let character of trigger) {
						if(character === '\n') {
							this.location.line++;
							this.location.column = 0;
						} else {
							this.location.column++;
						}
					}
				//	this.report(0, '  END: ['+trigger.replaceAll('\n', '\\n')+'], STATES: '+this.states);

					break;
				}
			}
		}

		static tokenize(code) {
			this.reset();

			this.code = code;

			while(!this.codeEnd) {
				this.nextToken();  // Zero-length position commits will lead to forever loop, rules developer attention is advised
			}

			let result = {
				rawTokens: this.tokens,
				tokens: this.tokens.filter(v => !this.ignorable(v.type)),
				reports: this.reports
			}

			this.reset();

			return result;
		}
	}

	class Parser {
		static tokens;
		static #position;
		static reports;

		static rules = {
			anyType: () => {
				let node = {
					type: 'anyType',
					range: {},
					value: undefined
				}

				if(this.token.type !== 'keywordUnderscore') {
					return;
				}

				node.value = this.token.value;
				node.range.start =
				node.range.end = this.position++;

				return node;
			},
			argument: () => {
				let node = {
					type: 'argument',
					range: {
						start: this.position
					},
					label: this.rules.identifier(),
					value: undefined
				}

				if(node.label != null && this.token.type.startsWith('operator') && this.token.value === ':') {
					this.position++;
				} else {
					this.position = node.range.start;
					node.label = undefined;
				}

				node.value = this.rules.expressionsSequence();
				if(node.label == null && node.value == null) {
					return;
				}

				node.range.end = this.position-1;

				return node;
			},
			arrayLiteral: () => {
				let node = {
					type: 'arrayLiteral',
					range: {},
					values: []
				}

				if(this.token.type !== 'bracketOpen') {
					return;
				}

				node.range.start = this.position++;
				node.values = this.ruleHelpers.sequentialNodes(
					['expressionsSequence'],
					() => this.token.type.startsWith('operator') && this.token.value === ','
				);

				if(this.token.type !== 'bracketClosed') {
					this.position = node.range.start;

					return;
				}

				node.range.end = this.position++;

				return node;
			},
			arrayType: () => {
				let node = {
					type: 'arrayType',
					range: {},
					value: undefined
				}

				if(this.token.type !== 'bracketOpen') {
					return;
				}

				node.range.start = this.position++;
				node.value = this.rules.type();

				if(this.token.type !== 'bracketClosed') {
					this.position--;

					return;
				}

				node.range.end = this.position++;

				return node;
			},
			asyncExpression: () => {
				let node = {
					type: 'asyncExpression',
					range: {},
					value: undefined
				}

				if(this.token.type !== 'keywordAsync') {
					return;
				}

				node.range.start = this.position++;
				node.value = this.rules.expression();

				if(node.value == null) {
					this.position--;

					return;
				}

				node.range.end = this.position-1;

				return node;
			},
			awaitExpression: () => {
				let node = {
					type: 'awaitExpression',
					range: {},
					value: undefined
				}

				if(this.token.type !== 'keywordAwait') {
					return;
				}

				node.range.start = this.position++;
				node.value = this.rules.expression();

				if(node.value == null) {
					this.position--;

					return;
				}

				node.range.end = this.position-1;

				return node;
			},
			body: (type) => {
				let node = {
					type: type+'Body',
					range: {},
					statements: []
				}

				if(this.token.type !== 'braceOpen') {
					return;
				}

				node.range.start = this.position++;
				node.statements = this.rules[type+'Statements']?.();

				if(node.statements.length === 0) {
					this.report(0, node.range.start, node.type, 'No statements.');
				}

				if(!this.tokensEnd) {
					node.range.end = this.position++;
				} else {
					node.range.end = this.position-1;

					this.report(1, node.range.start, node.type, 'Node doesn\'t have the closing brace and was decided to be autoclosed at the end of stream.');
				}

				return node;
			},
			booleanLiteral: () => {
				let node = {
					type: 'booleanLiteral',
					range: {},
					value: undefined
				}

				if(!['keywordFalse', 'keywordTrue'].includes(this.token.type)) {
					return;
				}

				node.value = this.token.value;
				node.range.start =
				node.range.end = this.position++;

				return node;
			},
			breakStatement: () => {
				let node = {
					type: 'breakStatement',
					range: {},
					label: undefined
				}

				if(this.token.type !== 'keywordBreak') {
					return;
				}

				node.range.start = this.position++;
				node.label = this.rules.identifier();
				node.range.end = this.position-1;

				return node;
			},
			callExpression: (node_) => {
				let node = {
					type: 'callExpression',
					range: {
						start: node_.range.start
					},
					callee: node_,
					genericArguments: [],
					arguments: [],
					closure: undefined
				}

				if(this.token.type.startsWith('operator') && this.token.value === '<') {
					this.position++;
					node.genericArguments = this.ruleHelpers.sequentialNodes(
						['type'],
						() => this.token.type.startsWith('operator') && this.token.value === ','
					);

					if(this.token.type.startsWith('operator') && this.token.value === '>') {
						this.position++;
					} else {
						this.position = node_.range.end+1;
					}
				}

				node.range.end = this.position-1;

				if(this.token.type === 'parenthesisOpen') {
					this.position++;
					node.arguments = this.ruleHelpers.skippableNodes(
						['argument'],
						() => this.token.type === 'parenthesisOpen',
						() => this.token.type === 'parenthesisClosed',
						() => this.token.type.startsWith('operator') && this.token.value === ','
					);

					if(this.token.type === 'parenthesisClosed') {
						this.position++;
					} else {
						node.range.end = this.position-1;

						this.report(1, node.range.start, node.type, 'Node doesn\'t have the closing parenthesis and was decided to be autoclosed at the end of stream.');

						return node;
					}
				}

				node.closure = this.rules.closureExpression();

				if(node.closure == null && node.range.end === this.position-1) {
					this.position = node_.range.end+1;

					return;
				}

				node.range.end = this.position-1;

				return node;
			},
			caseDeclaration: () => {
				let node = {
					type: 'caseDeclaration',
					range: {},
					identifiers: []
				}

				if(this.token.type !== 'keywordCase') {
					return;
				}

				node.range.start = this.position++;
				node.identifiers = this.ruleHelpers.sequentialNodes(
					['identifier'],
					() => this.token.type.startsWith('operator') && this.token.value === ','
				);

				if(node.identifiers.length === 0) {
					this.report(0, node.range.start, node.type, 'No identifiers(s).');
				}

				node.range.end = this.position-1;

				return node;
			},
			chainBody: (strict) => {
				let node = this.rules.body('chain');

				if(node != null && strict && !node?.statements.some(v => v.type !== 'unsupported')) {
					this.position = node.range.start;

					return;
				}

				return node;
			},
			chainDeclaration: () => {
				let node = {
					type: 'chainDeclaration',
					range: {
						start: this.position
					},
					modifiers: this.rules.modifiers(),
					body: undefined
				}

				if(this.token.type !== 'identifier' || this.token.value !== 'chain') {
					this.position = node.range.start;

					return;
				}

				node.range.start = this.position++;
				node.body = this.rules.chainBody();

				if(node.modifiers?.values.some(v => v !== 'static')) {
					this.report(1, node.range.start, node.type, 'Can only have specific modifier (static).');
				}
				if(node.body == null) {
					this.report(0, node.range.start, node.type, 'No body.');
				}

				node.range.end = this.position-1;

				return node;
			},
			chainExpression: (node_) => {
				let node = {
					type: 'chainExpression',
					range: {
						start: node_.range.start
					},
					composite: node_,
					member: undefined
				}

				if(!['operator', 'operatorInfix'].includes(this.token.type) || this.token.value !== '.') {
					return;
				}

				this.position++;
				node.member =
					this.rules.identifier() ??
					this.rules.stringLiteral();

				if(node.member == null) {
					this.position = node_.range.end+1;

					return;
				}

				node.range.end = node.member.range.end;

				return node;
			},
			chainIdentifier: (node_) => {
				let node = {
					type: 'chainIdentifier',
					range: {
						start: node_.range.start
					},
					supervalue: node_,
					value: undefined
				}

				if(!['operatorPrefix', 'operatorInfix'].includes(this.token.type) || this.token.value !== '.') {
					return;
				}

				this.position++;
				node.value = this.rules.identifier();

				if(node.value == null) {
					this.position = node_.range.end+1;

					return;
				}

				node.range.end = node.value.range.end;

				return node;
			},
			chainStatements: () => {
				return this.rules.statements(['observerDeclaration']);
			},
			classBody: () => {
				return this.rules.body('class');
			},
			classDeclaration: (anonymous) => {
				let node = {
					type: 'class'+(!anonymous ? 'Declaration' : 'Expression'),
					range: {
						start: this.position
					},
					modifiers: this.rules.modifiers(),
					identifier: undefined,
					genericParameters: undefined,
					inheritance: undefined,
					body: undefined
				}

				if(this.token.type !== 'keywordClass') {
					this.position = node.range.start;

					return;
				}

				this.position++;
				node.identifier = this.rules.identifier();

				if(anonymous) {
					if(node.modifiers != null || node.identifier != null) {
						this.position = node.range.start;

						return;
					}

					delete node.modifiers;
					delete node.identifier;
				} else
				if(node.identifier == null) {
					this.report(2, node.range.start, node.type, 'No identifier.');
				}

				node.genericParameters = this.rules.genericParametersClause();
				node.inheritance = this.rules.inheritanceClause();
				node.body = this.rules.classBody();

				if(node.modifiers?.values.some(v => !['private', 'protected', 'public', 'static', 'final'].includes(v))) {
					this.report(1, node.range.start, node.type, 'Wrong modifier(s).');
				}
				if(node.body == null) {
					this.report(0, node.range.start, node.type, 'No body.');
				}

				node.range.end = this.position-1;

				return node;
			},
			classExpression: () => {
				return this.rules.classDeclaration(true);
			},
			classStatements: () => {
				return this.rules.statements([
					'chainDeclaration',
					'classDeclaration',
					'deinitializerDeclaration',
					'enumerationDeclaration',
					'functionDeclaration',
					'initializerDeclaration',
					'namespaceDeclaration',
					'protocolDeclaration',
					'structureDeclaration',
					'subscriptDeclaration',
					'variableDeclaration'
				]);
			},
			closureExpression: () => {
				let node = {
					type: 'closureExpression',
					range: {},
					signature: undefined,
					statements: []
				}

				if(this.token.type !== 'braceOpen') {
					return;
				}

				node.range.start = this.position++;
				node.signature = this.rules.functionSignature();

				if(node.signature != null) {
					if(this.token.type !== 'keywordIn') {
						this.position = node.range.start;

						return;
					}

					this.position++;
				} else {
					this.report(0, node.range.start, node.type, 'No signature.');
				}

				node.statements = this.rules.functionStatements();

				if(node.statements.length === 0) {
					this.report(0, node.range.start, node.type, 'No statements.');
				}

				if(!this.tokensEnd) {
					node.range.end = this.position++;
				} else {
					node.range.end = this.position-1;

					this.report(1, node.range.start, node.type, 'Node doesn\'t have the closing brace and was decided to be autoclosed at the end of stream.');
				}

				return node;
			},
			compositeType: () => {
				let node = {
					type: 'compositeType',
					range: {},
					value: undefined
				}

				if(![
					'keywordCapitalAny',
					'keywordCapitalClass',
					'keywordCapitalEnumeration',
					'keywordCapitalFunction',
					'keywordCapitalNamespace',
					'keywordCapitalObject',
					'keywordCapitalProtocol',
					'keywordCapitalStructure'
				].includes(this.token.type)) {
					return;
				}

				node.value = this.token.value;
				node.range.start =
				node.range.end = this.position++;

				return node;
			},
			conditionalOperator: () => {
				let node = {
					type: 'conditionalOperator',
					range: {},
					expression: undefined
				}

				if(!this.token.type.startsWith('operator') || this.token.value !== '?') {
					return;
				}

				node.range.start = this.position++;
				node.expression = this.rules.expressionsSequence();

				if(!this.token.type.startsWith('operator') || this.token.value !== ':') {
					this.position = node.range.start;

					return;
				}

				node.range.end = this.position++;

				return node;
			},
			continueStatement: () => {
				let node = {
					type: 'continueStatement',
					range: {},
					label: undefined
				}

				if(this.token.type !== 'keywordContinue') {
					return;
				}

				node.range.start = this.position++;
				node.label = this.rules.identifier();
				node.range.end = this.position-1;

				return node;
			},
			controlTransferStatement: () => {
				let node =
					this.rules.breakStatement() ??
					this.rules.continueStatement() ??
					this.rules.fallthroughStatement() ??
					this.rules.returnStatement() ??
					this.rules.throwStatement();

				return node;
			},
			declaration: () => {
				let node =
					this.rules.chainDeclaration() ??
					this.rules.classDeclaration() ??
					this.rules.deinitializerDeclaration() ??
					this.rules.enumerationDeclaration() ??
					this.rules.functionDeclaration() ??
					this.rules.importDeclaration() ??
					this.rules.initializerDeclaration() ??
					this.rules.namespaceDeclaration() ??
					this.rules.operatorDeclaration() ??
					this.rules.protocolDeclaration() ??
					this.rules.structureDeclaration() ??
					this.rules.subscriptDeclaration() ??
					this.rules.variableDeclaration();

				return node;
			},
			declarator: () => {
				let node = {
					type: 'declarator',
					range: {
						start: this.position
					},
					identifier: this.rules.identifier(),
					type_: undefined,
					value: undefined,
					body: undefined
				}

				if(node.identifier == null) {
					return;
				}

				node.type_ = this.rules.typeClause();
				node.value = this.rules.initializerClause();
				node.body = this.rules.chainBody(true) ?? this.rules.functionBody();
				node.range.end = this.position-1;

				return node;
			},
			defaultExpression: (node_) => {
				let node = {
					type: 'defaultExpression',
					range: {
						start: node_.range.start
					},
					value: node_
				}

				if(this.token.type !== 'operatorPostfix' || this.token.value !== '!') {
					return;
				}

				node.range.end = this.position++;

				return node;
			},
			defaultType: (node_) => {
				let node = {
					type: 'defaultType',
					range: {
						start: node_.range.start
					},
					value: node_
				}

				if(this.token.type !== 'operatorPostfix' || this.token.value !== '!') {
					return;
				}

				node.range.end = this.position++;

				return node;
			},
			deinitializerDeclaration: () => {
				let node = {
					type: 'deinitializerDeclaration',
					range: {},
					body: undefined
				}

				if(this.token.type !== 'identifier' || this.token.value !== 'deinit') {
					return;
				}

				this.position++;
				node.body = this.rules.functionBody();

				if(node.body == null) {
					this.report(0, node.range.start, node.type, 'No body.');
				}

				node.range.end = this.position-1;

				return node;
			},
			deleteExpression: () => {
				let node = {
					type: 'deleteExpression',
					range: {},
					value: undefined
				}

				if(this.token.type !== 'identifier' || this.token.value !== 'delete') {
					return;
				}

				node.range.start = this.position++;
				node.value = this.rules.expression();

				if(node.value == null) {
					this.position--;

					return;
				}

				node.range.end = this.position-1;

				return node;
			},
			dictionaryLiteral: () => {
				let node = {
					type: 'dictionaryLiteral',
					range: {},
					entries: []
				}

				if(this.token.type !== 'bracketOpen') {
					return;
				}

				node.range.start = this.position++;
				node.entries = this.ruleHelpers.sequentialNodes(
					['entry'],
					() => this.token.type.startsWith('operator') && this.token.value === ','
				);

				if(node.entries.length === 0 && this.token.type.startsWith('operator') && this.token.value === ':') {
					this.position++;
				}

				if(this.token.type === 'bracketClosed') {
					node.range.end = this.position++;
				} else {
					this.position = node.range.start;

					return;
				}

				return node;
			},
			dictionaryType: () => {
				let node = {
					type: 'dictionaryType',
					range: {},
					key: undefined,
					value: undefined
				}

				if(this.token.type !== 'bracketOpen') {
					return;
				}

				node.range.start = this.position++;
				node.key = this.rules.type();

				if(!this.token.type.startsWith('operator') || this.token.value !== ':') {
					this.position--;

					return;
				}

				this.position++;
				node.value = this.rules.type();

				if(this.token.type !== 'bracketClosed') {
					this.position = node.range.start;

					return;
				}

				node.range.end = this.position++;

				return node;
			},
			elseClause: () => {
				let node,
					start = this.position;

				if(this.token.type !== 'keywordElse') {
					return;
				}

				this.position++;
				node =
					this.rules.functionBody() ??
					this.rules.expressionsSequence() ??
					this.rules.ifStatement();

				if(node == null) {
					this.report(0, start, 'elseClause', 'No value.');
				}

				return node;
			},
			entry: () => {
				let node = {
					type: 'entry',
					range: {
						start: this.position
					},
					key: this.rules.expressionsSequence(),
					value: undefined
				}
				if(node.key == null || !this.token.type.startsWith('operator') || this.token.value !== ':') {
					this.position = node.range.start;

					return;
				}

				this.position++;
				node.value = this.rules.expressionsSequence();

				if(node.value == null) {
					this.position = node.range.start;

					return;
				}

				node.range.end = this.position-1;

				return node;
			},
			enumerationBody: () => {
				return this.rules.body('enumeration');
			},
			enumerationDeclaration: (anonymous) => {
				let node = {
					type: 'enumeration'+(!anonymous ? 'Declaration' : 'Expression'),
					range: {
						start: this.position
					},
					modifiers: this.rules.modifiers(),
					identifier: undefined,
					inheritance: undefined,
					body: undefined
				}

				if(this.token.type !== 'keywordEnum') {
					this.position = node.range.start;

					return;
				}

				this.position++;
				node.identifier = this.rules.identifier();

				if(anonymous) {
					if(node.identifier != null) {
						this.position = node.range.start;

						return;
					} else {
						delete node.identifier;
					}
				} else
				if(node.identifier == null) {
					this.report(2, node.range.start, node.type, 'No identifier.');
				}

				node.inheritance = this.rules.inheritanceClause();
				node.body = this.rules.enumerationBody();

				if(node.modifiers?.values.some(v => !['private', 'protected', 'public', 'static', 'final'].includes(v))) {
					this.report(1, node.range.start, node.type, 'Wrong modifier(s).');
				}
				if(node.body == null) {
					this.report(0, node.range.start, node.type, 'No body.');
				}

				node.range.end = this.position-1;

				return node;
			},
			enumerationExpression: () => {
				return this.rules.enumerationDeclaration(true);
			},
			enumerationStatements: () => {
				return this.rules.statements([
					'caseDeclaration',
					'enumerationDeclaration'
				]);
			},
			expression: () => {
				let node =
					this.rules.asyncExpression() ??
					this.rules.awaitExpression() ??
					this.rules.deleteExpression() ??
					this.rules.tryExpression() ??
					this.rules.prefixExpression();

				return node;
			},
			expressionsSequence: () => {
				let node = {
					type: 'expressionsSequence',
					range: {
						start: this.position
					},
					values: []
				}

				let subsequentialTypes = ['inOperator', 'isOperator']

				node.values = this.ruleHelpers.sequentialNodes(['expression', 'infixExpression'], undefined, subsequentialTypes);

				if(node.values.length === 0) {
					return;
				}
				if(node.values.filter(v => !subsequentialTypes.includes(v.type)).length%2 === 0) {
					this.position = node.values.at(-1).range.start;

					node.values.pop();
				}
				if(node.values.length === 1) {
					return node.values[0]
				}

				node.range.end = this.position-1;

				return node;
			},
			fallthroughStatement: () => {
				let node = {
					type: 'fallthroughStatement',
					range: {},
					label: undefined
				}

				if(this.token.type !== 'keywordFallthrough') {
					return;
				}

				node.range.start = this.position++;
				node.label = this.rules.identifier();
				node.range.end = this.position-1;

				return node;
			},
			floatLiteral: () => {
				let node = {
					type: 'floatLiteral',
					range: {},
					value: undefined
				}

				if(this.token.type !== 'numberFloat') {
					return;
				}

				node.value = this.token.value;
				node.range.start =
				node.range.end = this.position++;

				return node;
			},
			forStatement: () => {
				let node = {
					type: 'forStatement',
					range: {},
					identifier: undefined,
					in: undefined,
					where: undefined,
					value: undefined
				}

				if(this.token.type !== 'keywordFor') {
					return;
				}

				node.range.start = this.position++;
				node.identifier = this.rules.identifier();

				if(this.token.type === 'keywordIn') {
					this.position++;
					node.in = this.rules.expressionsSequence();
				}
				if(this.token.type === 'keywordWhere') {
					this.position++;
					node.where = this.rules.expressionsSequence();
				}

				this.ruleHelpers.preconditionalStatementValue(node, node.where != null ? 'where' : 'in', 'value');

				if(node.identifier == null) {
					this.report(1, node.range.start, node.type, 'No identifier.');
				}
				if(node.in == null) {
					this.report(2, node.range.start, node.type, 'No in.');
				}
				if(node.value == null) {
					this.report(0, node.range.start, node.type, 'No value.');
				}

				node.range.end = this.position-1;

				return node;
			},
			functionBody: () => {
				return this.rules.body('function');
			},
			functionDeclaration: (anonymous) => {
				let node = {
					type: 'function'+(!anonymous ? 'Declaration' : 'Expression'),
					range: {
						start: this.position
					},
					modifiers: this.rules.modifiers(),
					identifier: undefined,
					signature: undefined,
					body: undefined
				}

				if(this.token.type !== 'keywordFunc') {
					this.position = node.range.start;

					return;
				}

				this.position++;
				node.identifier =
					this.rules.identifier() ??
					this.rules.operator();

				if(anonymous) {
					if(node.modifiers != null || node.identifier != null) {
						this.position = node.range.start;

						return;
					}

					delete node.modifiers;
					delete node.identifier;
				} else
				if(node.identifier == null) {
					this.report(2, node.range.start, node.type, 'No identifier.');
				}

				node.signature = this.rules.functionSignature();
				node.body = this.rules.functionBody();

				if(node.signature == null) {
					this.report(2, node.range.start, node.type, 'No signature.');
				}
				if(node.body == null) {
					this.report(0, node.range.start, node.type, 'No body.');
				}

				node.range.end = this.position-1;

				return node;
			},
			functionExpression: () => {
				return this.rules.functionDeclaration(true);
			},
			functionSignature: () => {
				let node = {
					type: 'functionSignature',
					range: {
						start: this.position
					},
					genericParameters: this.rules.genericParametersClause(),
					parameters: [],
					awaits: false,
					throws: false,
					return: undefined
				}

				if(this.token.type === 'parenthesisOpen') {
					this.position++;
					node.parameters = this.ruleHelpers.skippableNodes(
						['parameter'],
						() => this.token.type === 'parenthesisOpen',
						() => this.token.type === 'parenthesisClosed',
						() => this.token.type.startsWith('operator') && this.token.value === ','
					);

					if(this.token.type === 'parenthesisClosed') {
						this.position++;
					} else {
						node.range.end = this.position-1;

						this.report(1, node.range.start, node.type, 'Parameters don\'t have the closing parenthesis and were decided to be autoclosed at the end of stream.');

						return node;
					}
				}

				while(['keywordAwaits', 'keywordThrows'].includes(this.token.type)) {
					if(this.token.type === 'keywordAwaits') {
						this.position++;
						node.awaits = true;
					}
					if(this.token.type === 'keywordThrows') {
						this.position++;
						node.throws = true;
					}
				}

				if(this.token.type.startsWith('operator') && this.token.value === '->') {
					this.position++;
					node.return = this.rules.type();
				}

				node.range.end = this.position-1;

				if(node.range.end < node.range.start) {
					return;
				}

				return node;
			},
			functionStatements: () => {
				return this.rules.statements([
					'expressionsSequence',  // Expressions must be parsed first as they may include (anonymous) declarations
					'declaration',
					'controlTransferStatement',
					'forStatement',
					'ifStatement',
					'whileStatement'
				]);
			},
			functionType: () => {
				let node = {
					type: 'functionType',
					range: {
						start: this.position,
						end: this.position
					},
					genericParameters: [],
					parameters: [],
					awaits: false,
					throws: false,
					return: undefined
				}

				if(this.token.type.startsWith('operator') && this.token.value === '<') {
					this.position++;
					node.genericParameters = this.ruleHelpers.sequentialNodes(
						['type'],
						() => this.token.type.startsWith('operator') && this.token.value === ','
					);

					if(this.token.type.startsWith('operator') && this.token.value === '>') {
						node.range.end = this.position++;
					} else {
						this.position = node.range.start;

						return;
					}
				}

				if(this.token.type !== 'parenthesisOpen') {
					this.position = node.range.start;

					return;
				}

				this.position++;
				node.parameters = this.ruleHelpers.sequentialNodes(
					['type'],
					() => this.token.type.startsWith('operator') && this.token.value === ','
				);

				if(this.token.type !== 'parenthesisClosed') {
					this.position = node.range.start;

					return;
				}

				this.position++;

				while(['keywordAsync', 'keywordThrows'].includes(this.token.type)) {
					if(this.token.type === 'keywordAsync') {
						this.position++;
						node.awaits = true;

						if(this.token.type === 'operatorPostfix' && this.token.value === '?') {
							this.position++;
							node.awaits = undefined;
						}
					}
					if(this.token.type === 'keywordThrows') {
						this.position++;
						node.throws = true;

						if(this.token.type === 'operatorPostfix' && this.token.value === '?') {
							this.position++;
							node.throws = undefined;
						}
					}
				}

				if(this.token.type.startsWith('operator') && this.token.value === '->') {
					this.position++;
					node.return = this.rules.type();
				}

				node.range.end = this.position-1;

				return node;
			},
			genericParameter: () => {
				let node =
					this.rules.variadicGenericParameter() ??
					this.rules.primaryGenericParameter();

				return node;
			},
			genericParametersClause: () => {
				let nodes = [],
					start = this.position;

				if(!this.token.type.startsWith('operator') || this.token.value !== '<') {
					return nodes;
				}

				this.position++;
				nodes = this.ruleHelpers.skippableNodes(
					['genericParameter'],
					() => this.token.type.startsWith('operator') && this.token.value === '<',
					() => this.token.type.startsWith('operator') && this.token.value === '>',
					() => this.token.type.startsWith('operator') && this.token.value === ','
				);

				if(!this.token.type.startsWith('operator') || this.token.value !== '>') {
					this.report(1, start, 'genericParametersClause', 'Node doesn\'t have the closing angle and was decided to be autoclosed at the end of stream.');

					return nodes;
				}

				this.position++;

				return nodes;
			},
			identifier: () => {
				let node = {
					type: 'identifier',
					range: {},
					value: undefined
				}

				if(this.token.type !== 'identifier') {
					return;
				}

				node.value = this.token.value;
				node.range.start =
				node.range.end = this.position++;

				return node;
			},
			ifStatement: () => {
				let node = {
					type: 'ifStatement',
					range: {},
					condition: undefined,
					then: undefined,
					else: undefined
				}

				if(this.token.type !== 'keywordIf') {
					return;
				}

				node.range.start = this.position++;
				node.condition = this.rules.expressionsSequence();

				this.ruleHelpers.preconditionalStatementValue(node, 'condition', 'then');

				node.else = this.rules.elseClause();

				if(node.condition == null) {
					this.report(2, node.range.start, node.type, 'No condition.');
				}
				if(node.then == null) {
					this.report(0, node.range.start, node.type, 'No value.');
				}

				node.range.end = this.position-1;

				return node;
			},
			implicitChainExpression: () => {
				let node = {
					type: 'implicitChainExpression',
					range: {},
					member: undefined
				}

				if(!this.token.type.startsWith('operator') || this.token.type.endsWith('Postfix') || this.token.value !== '.') {
					return;
				}

				node.range.start = this.position++;
				node.member =
					this.rules.identifier() ??
					this.rules.stringLiteral();

				if(node.member == null) {
					this.position--;

					return;
				}

				node.range.end = node.member.range.end;

				return node;
			},
			implicitChainIdentifier: () => {
				let node = {
					type: 'implicitChainIdentifier',
					range: {},
					value: undefined
				}

				if(!this.token.type.startsWith('operator') || this.token.type.endsWith('Postfix') || this.token.value !== '.') {
					return;
				}

				node.range.start = this.position++;
				node.value = this.rules.identifier();

				if(node.value == null) {
					this.position--;

					return;
				}

				node.range.end = node.value.range.end;

				return node;
			},
			importDeclaration: () => {
				let node = {
					type: 'importDeclaration',
					range: {},
					value: undefined
				}

				if(this.token.type !== 'keywordImport') {
					return;
				}

				node.range.start =
				node.range.end = this.position++;
				node.value = this.rules.identifier();

				if(node.value != null) {
					while(!this.tokensEnd) {
						let node_ = this.rules.chainIdentifier(node.value);

						if(node_ == null) {
							break;
						}

						node.value = node_;
					}
				} else {
					this.report(1, node.range.start, node.type, 'No value.');
				}

				node.range.end =
					node.value?.range.end ??
					node.range.end;

				return node;
			},
			infixExpression: () => {
				let node =
					this.rules.conditionalOperator() ??
					this.rules.inOperator() ??
					this.rules.isOperator() ??
					this.rules.infixOperator();

				return node;
			},
			infixOperator: () => {
				let node = {
					type: 'infixOperator',
					range: {},
					value: undefined
				}

				let exceptions = [',', ':']  // Enclosing nodes can use operators from the list as delimiters

				if(!['operator', 'operatorInfix'].includes(this.token.type) || exceptions.includes(this.token.value)) {
					return;
				}

				node.value = this.token.value;
				node.range.start =
				node.range.end = this.position++;

				return node;
			},
			inheritanceClause: () => {
				let nodes = [],
					start = this.position;

				if(!this.token.type.startsWith('operator') || this.token.value !== ':') {
					return;
				}

				this.position++;
				nodes = this.ruleHelpers.sequentialNodes(
					['typeReference'],
					() => this.token.type.startsWith('operator') && this.token.value === ','
				);

				if(nodes.length === 0) {
					this.report(0, start, 'inheritanceClause', 'No types.');
				}

				return nodes;
			},
			initializerClause: () => {
				let node,
					start = this.position;

				if(!this.token.type.startsWith('operator') || this.token.value !== '=') {
					return;
				}

				this.position++;
				node = this.rules.expressionsSequence();

				if(node == null) {
					this.report(0, start, 'initializerClause', 'No value.');
				}

				return node;
			},
			initializerDeclaration: () => {
				let node = {
					type: 'initializerDeclaration',
					range: {
						start: this.position
					},
					modifiers: this.rules.modifiers(),
					signature: undefined,
					body: undefined
				}

				if(this.token.type !== 'identifier' || this.token.value !== 'init') {
					this.position = node.range.start;

					return;
				}

				this.position++;
				node.signature = this.rules.functionSignature();
				node.body = this.rules.functionBody();

				if(node.modifiers?.values.some(v => !['private', 'protected', 'public'].includes(v))) {
					this.report(1, node.range.start, node.type, 'Wrong modifier(s).');
				}
				if(node.signature == null) {
					this.report(0, node.range.start, node.type, 'No signature.');
				}
				if(node.body == null) {
					this.report(0, node.range.start, node.type, 'No body.');
				}

				node.range.end = this.position-1;

				return node;
			},
			inOperator: () => {
				let node = {
					type: 'inOperator',
					range: {
						start: this.position
					},
					negatiated: false,
					composite: undefined
				}

				if(this.token.type === 'operatorPrefix' && this.token.value === '!') {
					this.position++;
					node.negatiated = true;
				}

				if(this.token.type !== 'keywordIn') {
					this.position = node.range.start;

					return;
				}

				this.position++;
				node.composite = this.rules.expressionsSequence();

				if(node.composite == null) {
					this.position = node.range.start;

					return;
				}

				node.range.end = this.position-1;

				return node;
			},
			inoutExpression: () => {
				let node = {
					type: 'inoutExpression',
					range: {},
					identifier: undefined
				}

				if(this.token.type !== 'operatorPrefix' || this.token.value !== '&') {
					return;
				}

				node.range.start = this.position++;
				node.identifier = this.rules.identifier();

				if(node.identifier == null) {
					this.position--;

					return;
				}

				node.range.end = node.identifier.range.end;

				return node;
			},
			inoutType: () => {
				let node = {
					type: 'inoutType',
					range: {},
					value: undefined
				}

				if(this.token.type !== 'keywordInout') {
					return;
				}

				node.range.start = this.position++;
				node.value = this.rules.unionType();
				node.range.end = this.position-1;

				return node;
			},
			integerLiteral: () => {
				let node = {
					type: 'integerLiteral',
					range: {},
					value: undefined
				}

				if(this.token.type !== 'numberInteger') {
					return;
				}

				node.value = this.token.value;
				node.range.start =
				node.range.end = this.position++;

				return node;
			},
			intersectionType: () => {
				let node = {
					type: 'intersectionType',
					range: {
						start: this.position
					},
					subtypes: this.ruleHelpers.sequentialNodes(
						['postfixType'],
						() => this.token.type.startsWith('operator') && this.token.value === '&'
					)
				}

				if(node.subtypes.length === 0) {
					return;
				}
				if(node.subtypes.length === 1) {
					return node.subtypes[0]
				}

				node.range.end = this.position-1;

				return node;
			},
			isOperator: () => {
				let node = {
					type: 'isOperator',
					range: {
						start: this.position
					},
					type_: undefined,
					negatiated: false
				}

				if(this.token.type === 'operatorPrefix' && this.token.value === '!') {
					this.position++;
					node.negatiated = true;
				}

				if(this.token.type !== 'keywordIs') {
					this.position = node.range.start;

					return;
				}

				this.position++;
				node.type_ = this.rules.type();

				if(node.type_ == null) {
					this.position = node.range.start;

					return;
				}

				node.range.end = this.position-1;

				return node;
			},
			literalExpression: () => {
				let node =
					this.rules.arrayLiteral() ??
					this.rules.booleanLiteral() ??
					this.rules.dictionaryLiteral() ??
					this.rules.floatLiteral() ??
					this.rules.integerLiteral() ??
					this.rules.nilLiteral() ??
					this.rules.stringLiteral();

				return node;
			},
			modifiers: () => {
				let node = {
					type: 'modifiers',
					range: {
						start: this.position
					},
					values: []
				}

				while([
					'keywordInfix',
					'keywordPostfix',
					'keywordPrefix',
					'keywordPrivate',
					'keywordProtected',
					'keywordPublic',
					'keywordStatic',
					'keywordLazy',
					'keywordFinal'
				].includes(this.token.type)) {
					node.values.push(this.token.value);
					node.range.end = this.position++;
				}

				if(node.values.length === 0) {
					return;
				}

				return node;
			},
			module: () => {
				let node = {
					type: 'module',
					range: {
						start: this.position
					},
					statements: this.rules.functionStatements()
				}

				node.range.end = node.statements.length > 0 ? this.position-1 : 0;

				return node;
			},
			namespaceBody: () => {
				return this.rules.body('namespace');
			},
			namespaceDeclaration: (anonymous) => {
				let node = {
					type: 'namespace'+(!anonymous ? 'Declaration' : 'Expression'),
					range: {
						start: this.position
					},
					modifiers: this.rules.modifiers(),
					identifier: undefined,
					body: undefined
				}

				if(this.token.type !== 'keywordNamespace') {
					this.position = node.range.start;

					return;
				}

				this.position++;
				node.identifier = this.rules.identifier();

				if(anonymous) {
					if(node.modifiers != null || node.identifier != null) {
						this.position = node.range.start;

						return;
					}

					delete node.modifiers;
					delete node.identifier;
				} else
				if(node.identifier == null) {
					this.report(2, node.range.start, node.type, 'No identifier.');
				}

				node.body = this.rules.namespaceBody();

				if(node.modifiers?.values.some(v => !['private', 'protected', 'public', 'static', 'final'].includes(v))) {
					this.report(1, node.range.start, node.type, 'Wrong modifier(s).');
				}
				if(node.body == null) {
					this.report(0, node.range.start, node.type, 'No body.');
				}

				node.range.end = this.position-1;

				return node;
			},
			namespaceExpression: () => {
				return this.rules.namespaceDeclaration(true);
			},
			namespaceStatements: () => {
				return this.rules.statements(['declaration']);
			},
			nillableExpression: (node_) => {
				let node = {
					type: 'nillableExpression',
					range: {
						start: node_.range.start
					},
					value: node_
				}

				if(!['operatorInfix', 'operatorPostfix'].includes(this.token.type) || this.token.value !== '?') {
					return;
				}

				node.range.end = this.position++;

				return node;
			},
			nillableType: (node_) => {
				let node = {
					type: 'nillableType',
					range: {
						start: node_.range.start
					},
					value: node_
				}

				if(this.token.type !== 'operatorPostfix' || this.token.value !== '?') {
					return;
				}

				node.range.end = this.position++;

				return node;
			},
			nilLiteral: () => {
				let node = {
					type: 'nilLiteral',
					range: {}
				}

				if(this.token.type !== 'keywordNil') {
					return;
				}

				node.range.start =
				node.range.end = this.position++;

				return node;
			},
			observerDeclaration: () => {
				let node = {
					type: 'observerDeclaration',
					range: {
						start: this.position
					},
					identifier: this.rules.identifier(),
					body: undefined
				}

				if(![
					'willGet',
					'get',
					'didGet',
					'willSet',
					'set',
					'didSet',
					'willDelete',
					'delete',
					'didDelete'
				].includes(node.identifier?.value)) {
					this.position = node.range.start;

					return;
				}

				node.body = this.rules.functionBody();

				if(node.body == null) {
					this.report(0, node.range.start, node.type, 'No body.');
				}

				node.range.end = this.position-1;

				return node;
			},
			operator: () => {
				let node = {
					type: 'operator',
					range: {},
					value: undefined
				}

				if(!this.token.type.startsWith('operator')) {
					return;
				}

				node.value = this.token.value;
				node.range.start =
				node.range.end = this.position++;

				return node;
			},
			operatorBody: () => {
				return this.rules.body('operator');
			},
			operatorDeclaration: () => {
				let node = {
					type: 'operatorDeclaration',
					range: {
						start: this.position
					},
					modifiers: this.rules.modifiers(),
					operator: undefined,
					body: undefined
				}

				if(this.token.type !== 'keywordOperator') {
					this.position = node.range.start;

					return;
				}

				this.position++;
				node.operator = this.rules.operator();
				node.body = this.rules.operatorBody();

				if(!node.modifiers?.values.some(v => ['infix', 'postfix', 'prefix'].includes(v))) {
					this.report(2, node.range.start, node.type, 'Should have specific modifier (infix, postfix, prefix).');
				}
				if(node.operator == null) {
					this.report(2, node.range.start, node.type, 'No operator.');
				}
				if(node.body == null) {
					this.report(0, node.range.start, node.type, 'No body.');
				} else {
					for(let entry of node.body.statements.filter(v => v.type === 'entry')) {
						if(entry.key.type !== 'identifier' || !['associativity', 'precedence'].includes(entry.key.value)) {
							this.report(1, entry.range.start, node.type, 'Should have only identifiers as keys (associativity, precedence).');
						} else {
							if(entry.key.value === 'associativity') {
								if(entry.value.type !== 'identifier') {
									this.report(2, entry.range.start, node.type, 'Associativity value should be identifier.');
								}
								if(!['left', 'right', 'none'].includes(entry.value.value)) {
									this.report(2, entry.range.start, node.type, 'Associativity accepts only one of following values: left, right, none.');
								}
							}
							if(entry.key.value === 'precedence' && entry.value.type !== 'integerLiteral') {
								this.report(2, entry.range.start, node.type, 'Precedence value should be integer.');
							}
						}
					}
				}

				node.range.end = this.position-1;

				return node;
			},
			operatorStatements: () => {
				return this.rules.statements(['entry']);
			},
			parameter: () => {
				let node = {
					type: 'parameter',
					range: {
						start: this.position
					},
					label: this.rules.identifier(),
					identifier: undefined,
					type_: undefined,
					value: undefined
				}

				if(node.label == null) {
					return;
				}

				node.identifier = this.rules.identifier();

				if(node.identifier == null) {
					node.identifier = node.label;
					node.label = undefined;
				}

				node.type_ = this.rules.typeClause();
				node.value = this.rules.initializerClause();
				node.range.end = this.position-1;

				return node;
			},
			parenthesizedExpression: () => {
				let node = {
					type: 'parenthesizedExpression',
					range: {},
					value: undefined
				}

				if(this.token.type !== 'parenthesisOpen') {
					return;
				}

				node.range.start = this.position++;
				node.value = this.ruleHelpers.skippableNode(
					'expressionsSequence',
					() => this.token.type === 'parenthesisOpen',
					() => this.token.type === 'parenthesisClosed'
				);

				if(this.token.type === 'parenthesisClosed') {
					node.range.end = this.position++;
				} else
				if(this.tokensEnd) {
					node.range.end = this.position-1;

					this.report(1, node.range.start, node.type, 'Node doesn\'t have the closing parenthesis and was decided to be autoclosed at the end of stream.');
				} else {
					this.position = node.range.start;

					return;
				}

				return node;
			},
			parenthesizedType: () => {
				let node = {
					type: 'parenthesizedType',
					range: {},
					value: undefined
				}

				if(this.token.type !== 'parenthesisOpen') {
					return;
				}

				node.range.start = this.position++;
				node.value = this.rules.type();

				if(this.token.type !== 'parenthesisClosed') {
					this.position = node.range.start;

					return;
				}

				node.range.end = this.position++;

				return node;
			},
			postfixExpression: () => {
				let node = {
					type: 'postfixExpression',
					range: {
						start: this.position
					},
					value: this.rules.primaryExpression(),
					operator: undefined
				}

				if(node.value == null) {
					return;
				}

				while(!this.tokensEnd) {
					let node_ =
						this.rules.callExpression(node.value) ??
						this.rules.chainExpression(node.value) ??
						this.rules.defaultExpression(node.value) ??
						this.rules.nillableExpression(node.value) ??
						this.rules.subscriptExpression(node.value);

					if(node_ == null) {
						break;
					}

					node.value = node_;
				}

				node.operator = this.rules.postfixOperator();

				if(node.operator == null) {
					return node.value;
				}

				node.range.end = node.operator.range.end;

				return node;
			},
			postfixOperator: () => {
				let node = {
					type: 'postfixOperator',
					range: {},
					value: undefined
				}

				let exceptions = [',', ':']  // Enclosing nodes can use trailing operators from the list

				if(this.token.type !== 'operatorPostfix' || exceptions.includes(this.token.value)) {
					return;
				}

				node.value = this.token.value;
				node.range.start =
				node.range.end = this.position++;

				return node;
			},
			postfixType: () => {
				let node = this.rules.primaryType();

				if(node == null) {
					return;
				}

				while(!this.tokensEnd) {
					let node_ =
						this.rules.defaultType(node) ??
						this.rules.nillableType(node);

					if(node_ == null) {
						break;
					}

					node = node_;
				}

				return node;
			},
			prefixExpression: () => {
				let node = {
					type: 'prefixExpression',
					range: {
						start: this.position
					},
					operator: this.rules.prefixOperator(),
					value: undefined
				}

				node.value = this.rules.postfixExpression();

				if(node.value == null) {
					this.position = node.range.start;

					return;
				}
				if(node.operator == null) {
					return node.value;
				}

				node.range.end = node.value.range.end;

				return node;
			},
			prefixOperator: () => {
				let node = {
					type: 'prefixOperator',
					range: {},
					value: undefined
				}

				let exceptions = ['&', '.']  // primaryExpressions can start with operators from the list

				if(this.token.type !== 'operatorPrefix' || exceptions.includes(this.token.value)) {
					return;
				}

				node.value = this.token.value;
				node.range.start =
				node.range.end = this.position++;

				return node;
			},
			primaryExpression: () => {
				let node =
					this.rules.classExpression() ??
					this.rules.closureExpression() ??
					this.rules.enumerationExpression() ??
					this.rules.functionExpression() ??
					this.rules.identifier() ??
					this.rules.implicitChainExpression() ??
					this.rules.inoutExpression() ??
					this.rules.literalExpression() ??
					this.rules.namespaceExpression() ??
					this.rules.parenthesizedExpression() ??
					this.rules.protocolExpression() ??
					this.rules.structureExpression();

				return node;
			},
			primaryGenericParameter: () => {
				let node = {
					type: 'genericParameter',
					range: {
						start: this.position
					},
					identifier: this.rules.identifier(),
					type_: undefined
				}

				if(node.identifier == null) {
					return;
				}

				node.type_ = this.rules.typeClause();
				node.range.end = this.position-1;

				return node;
			},
			primaryType: () => {
				let node =
					this.rules.anyType() ??
					this.rules.arrayType() ??
					this.rules.compositeType() ??
					this.rules.dictionaryType() ??
					this.rules.functionType() ??
					this.rules.parenthesizedType() ??
					this.rules.primitiveType() ??
					this.rules.protocolType() ??
					this.rules.typeReference();

				return node;
			},
			primitiveType: () => {
				let node = {
					type: 'primitiveType',
					range: {},
					value: undefined
				}

				if(![
					'keywordAny',
					'keywordBool',
					'keywordFloat',
					'keywordInt',
					'keywordString'
				].includes(this.token.type)) {
					return;
				}

				node.value = this.token.value;
				node.range.start =
				node.range.end = this.position++;

				return node;
			},
			protocolBody: () => {
				return this.rules.body('protocol');
			},
			protocolDeclaration: (anonymous) => {
				let node = {
					type: 'protocol'+(!anonymous ? 'Declaration' : 'Expression'),
					range: {
						start: this.position
					},
					modifiers: this.rules.modifiers(),
					identifier: undefined,
					inheritance: undefined,
					body: undefined
				}

				if(this.token.type !== 'keywordProtocol') {
					this.position = node.range.start;

					return;
				}

				this.position++;
				node.identifier = this.rules.identifier();

				if(anonymous) {
					if(node.modifiers != null || node.identifier != null) {
						this.position = node.range.start;

						return;
					}

					delete node.modifiers;
					delete node.identifier;
				} else
				if(node.identifier == null) {
					this.report(2, node.range.start, node.type, 'No identifier.');
				}

				node.inheritance = this.rules.inheritanceClause();
				node.body = this.rules.protocolBody();

				if(node.modifiers?.values.some(v => !['private', 'protected', 'public', 'static', 'final'].includes(v))) {
					this.report(1, node.range.start, node.type, 'Wrong modifier(s).');
				}
				if(node.body == null) {
					this.report(0, node.range.start, node.type, 'No body.');
				}

				node.range.end = this.position-1;

				return node;
			},
			protocolExpression: () => {
				return this.rules.protocolDeclaration(true);
			},
			protocolStatements: () => {
				return this.rules.statements([
					'classDeclaration',
					'enumerationDeclaration',
					'functionDeclaration',
					'namespaceDeclaration',
					'protocolDeclaration',
					'structureDeclaration',
					'variableDeclaration'
				]);
			},
			protocolType: () => {
				return this.rules.protocolBody();
			},
			returnStatement: () => {
				let node = {
					type: 'returnStatement',
					range: {},
					value: undefined
				}

				if(this.token.type !== 'keywordReturn') {
					return;
				}

				node.range.start = this.position++;
				node.value = this.rules.expressionsSequence();
				node.range.end = this.position-1;

				return node;
			},
			statements: (types) => {
				return this.ruleHelpers.skippableNodes(
					types,
					() => this.token.type === 'braceOpen',
					() => this.token.type === 'braceClosed',
					() => this.token.type === 'delimiter',
					true
				);
			},
			stringExpression: () => {
				let node = {
					type: 'stringExpression',
					range: {},
					value: undefined
				}

				if(this.token.type !== 'stringExpressionOpen') {
					return;
				}

				node.range.start = this.position++;
				node.value = this.ruleHelpers.skippableNode(
					'expressionsSequence',
					() => this.token.type === 'stringExpressionOpen',
					() => this.token.type === 'stringExpressionClosed'
				);

				if(this.token.type === 'stringExpressionClosed') {
					node.range.end = this.position++;
				} else
				if(this.tokensEnd) {
					node.range.end = this.position-1;

					this.report(1, node.range.start, node.type, 'Node doesn\'t have the closing parenthesis and was decided to be autoclosed at the end of stream.');
				} else {
					this.position = node.range.start;

					return;
				}

				return node;
			},
			stringLiteral: () => {
				let node = {
					type: 'stringLiteral',
					range: {},
					segments: []
				}

				if(this.token.type !== 'stringOpen') {
					return;
				}

				node.range.start = this.position++;
				node.segments = this.ruleHelpers.skippableNodes(
					['stringSegment', 'stringExpression'],
					() => this.token.type === 'stringOpen',
					() => this.token.type === 'stringClosed'
				);

				if(this.token.type === 'stringClosed') {
					node.range.end = this.position++;
				} else {
					node.range.end = this.position-1;

					this.report(1, node.range.start, node.type, 'Node doesn\'t have the closing apostrophe and decided to be autoclosed at the end of stream.');
				}

				return node;
			},
			stringSegment: () => {
				let node = {
					type: 'stringSegment',
					range: {},
					value: undefined
				}

				if(this.token.type !== 'stringSegment') {
					return;
				}

				node.value = this.token.value;
				node.range.start =
				node.range.end = this.position++;

				return node;
			},
			structureBody: () => {
				return this.rules.body('structure');
			},
			structureDeclaration: (anonymous) => {
				let node = {
					type: 'structure'+(!anonymous ? 'Declaration' : 'Expression'),
					range: {
						start: this.position
					},
					modifiers: this.rules.modifiers(),
					identifier: undefined,
					genericParameters: undefined,
					inheritance: undefined,
					body: undefined
				}

				if(this.token.type !== 'keywordStruct') {
					this.position = node.range.start;

					return;
				}

				this.position++;
				node.identifier = this.rules.identifier();

				if(anonymous) {
					if(node.modifiers != null || node.identifier != null) {
						this.position = node.range.start;

						return;
					}

					delete node.modifiers;
					delete node.identifier;
				} else
				if(node.identifier == null) {
					this.report(2, node.range.start, node.type, 'No identifier.');
				}

				node.genericParameters = this.rules.genericParametersClause();
				node.inheritance = this.rules.inheritanceClause();
				node.body = this.rules.structureBody();

				if(node.modifiers?.values.some(v => !['private', 'protected', 'public', 'static', 'final'].includes(v))) {
					this.report(1, node.range.start, node.type, 'Wrong modifier(s).');
				}
				if(node.body == null) {
					this.report(0, node.range.start, node.type, 'No body.');
				}

				node.range.end = this.position-1;

				return node;
			},
			structureExpression: () => {
				return this.rules.structureDeclaration(true);
			},
			structureStatements: () => {
				return this.rules.statements([
					'chainDeclaration',
					'classDeclaration',
					'deinitializerDeclaration',
					'enumerationDeclaration',
					'functionDeclaration',
					'initializerDeclaration',
					'namespaceDeclaration',
					'protocolDeclaration',
					'structureDeclaration',
					'subscriptDeclaration',
					'variableDeclaration'
				]);
			},
			subscriptBody: (strict) => {
				let node = this.rules.body('subscript');

				if(node != null && strict && !node?.statements.some(v => v.type !== 'unsupported')) {
					this.position = node.range.start;

					return;
				}

				return node;
			},
			subscriptDeclaration: () => {
				let node = {
					type: 'subscriptDeclaration',
					range: {
						start: this.position
					},
					modifiers: this.rules.modifiers(),
					signature: undefined,
					body: undefined
				}

				if(this.token.type !== 'identifier' || this.token.value !== 'subscript') {
					this.position = node.range.start;

					return;
				}

				node.range.start = this.position++;
				node.signature = this.rules.functionSignature();
				node.body = this.rules.subscriptBody(true) ?? this.rules.functionBody();

				if(node.modifiers?.values.some(v => !['private', 'protected', 'public', 'static'].includes(v))) {
					this.report(1, node.range.start, node.type, 'Wrong modifier(s).');
				}
				if(node.signature == null) {
					this.report(2, node.range.start, node.type, 'No signature.');
				}
				if(node.body == null) {
					this.report(0, node.range.start, node.type, 'No body.');
				}

				node.range.end = this.position-1;

				return node;
			},
			subscriptExpression: (node_) => {
				let node = {
					type: 'subscriptExpression',
					range: {
						start: node_.range.start
					},
					composite: node_,
					arguments: undefined,
					closure: undefined
				}

				if(this.token.type.startsWith('operator') && this.token.value === '<') {
					this.position++;
					node.genericArguments = this.ruleHelpers.sequentialNodes(
						['type'],
						() => this.token.type.startsWith('operator') && this.token.value === ','
					);

					if(this.token.type.startsWith('operator') && this.token.value === '>') {
						this.position++;
					} else {
						this.position = node_.range.end+1;
					}
				}

				node.range.end = this.position-1;

				if(this.token.type === 'bracketOpen') {
					this.position++;
					node.arguments = this.ruleHelpers.skippableNodes(
						['argument'],
						() => this.token.type === 'bracketOpen',
						() => this.token.type === 'bracketClosed',
						() => this.token.type.startsWith('operator') && this.token.value === ','
					);

					if(this.token.type === 'bracketClosed') {
						this.position++;
					} else {
						node.range.end = this.position-1;

						this.report(1, node.range.start, node.type, 'Node doesn\'t have the closing bracket and was decided to be autoclosed at the end of stream.');

						return node;
					}
				}

				node.closure = this.rules.closureExpression();

				if(node.closure == null && node.range.end === this.position-1) {
					this.position = node_.range.end+1;

					return;
				}

				node.range.end = this.position-1;

				return node;
			},
			subscriptStatements: () => {
				return this.rules.statements(['observerDeclaration']);
			},
			throwStatement: () => {
				let node = {
					type: 'throwStatement',
					range: {},
					value: undefined
				}

				if(this.token.type !== 'keywordThrow') {
					return;
				}

				node.range.start = this.position++;
				node.value = this.rules.expressionsSequence();
				node.range.end = this.position-1;

				return node;
			},
			tryExpression: () => {
				let node = {
					type: 'tryExpression',
					range: {},
					nillable: false,
					value: undefined
				}

				if(this.token.type !== 'keywordTry') {
					return;
				}

				node.range.start = this.position++;

				if(this.token.type === 'operatorPostfix' && this.token.value === '?') {
					this.position++;
					node.nillable = true;
				}

				node.value = this.rules.expression();

				if(node.value == null) {
					this.position = node.range.start;

					return;
				}

				node.range.end = this.position-1;

				return node;
			},
			type: () => {
				let node =
					this.rules.variadicType() ??
					this.rules.inoutType() ??
					this.rules.unionType();

				return node;
			},
			typeClause: () => {
				let node,
					start = this.position;

				if(!this.token.type.startsWith('operator') || this.token.value !== ':') {
					return;
				}

				this.position++;
				node = this.rules.type();

				if(node == null) {
					this.report(0, start, 'typeClause', 'No value.');
				}

				return node;
			},
			typeReference: () => {
				let node = {
					type: 'typeReference',
					range: {
						start: this.position
					},
					identifier:
						this.rules.identifier() ??
						this.rules.implicitChainIdentifier(),
					genericArguments: []
				}

				if(node.identifier == null) {
					return;
				}

				while(!this.tokensEnd) {
					let node_ = this.rules.chainIdentifier(node.identifier);

					if(node_ == null) {
						break;
					}

					node.identifier = node_;
				}

				node.range.end = this.position-1;

				if(!this.token.type.startsWith('operator') || this.token.value !== '<') {
					return node;
				}

				this.position++;
				node.genericArguments = this.ruleHelpers.sequentialNodes(
					['type'],
					() => this.token.type.startsWith('operator') && this.token.value === ','
				);

				if(!this.token.type.startsWith('operator') || this.token.value !== '>') {
					this.position = node.range.end+1;
					node.genericArguments = []
				} else {
					node.range.end = this.position++;
				}

				return node;
			},
			unionType: () => {
				let node = {
					type: 'unionType',
					range: {
						start: this.position
					},
					subtypes: this.ruleHelpers.sequentialNodes(
						['intersectionType'],
						() => this.token.type.startsWith('operator') && this.token.value === '|'
					)
				}

				if(node.subtypes.length === 0) {
					return;
				}
				if(node.subtypes.length === 1) {
					return node.subtypes[0]
				}

				node.range.end = this.position-1;

				return node;
			},
			variableDeclaration: () => {
				let node = {
					type: 'variableDeclaration',
					range: {
						start: this.position
					},
					modifiers: this.rules.modifiers(),
					declarators: []
				}

				if(this.token.type !== 'keywordVar') {
					this.position = node.range.start;

					return;
				}

				this.position++;
				node.declarators = this.ruleHelpers.sequentialNodes(
					['declarator'],
					() => this.token.type.startsWith('operator') && this.token.value === ','
				);

				if(node.modifiers?.values.some(v => !['private', 'protected', 'public', 'static', 'lazy', 'final'].includes(v))) {
					this.report(1, node.range.start, node.type, 'Wrong modifier(s).');
				}
				if(node.declarators.length === 0) {
					this.report(0, node.range.start, node.type, 'No declarator(s).');
				}

				node.range.end = this.position-1;

				return node;
			},
			variadicGenericParameter: () => {
				let node = {
					type: 'variadicGenericParameter',
					range: {}
				}

				if(!this.token.type.startsWith('operator') || this.token.value !== '...') {
					return;
				}

				node.range.start =
				node.range.end = this.position++;

				return node;
			},
			variadicType: () => {
				let node = {
					type: 'variadicType',
					range: {
						start: this.position
					},
					value: this.rules.inoutType() ?? this.rules.unionType()
				}

				if(!this.token.type.startsWith('operator') || this.token.value !== '...') {
					return node.value;
				}

				this.position++;
				node.range.end = this.position-1;

				return node;
			},
			whileStatement: () => {
				let node = {
					type: 'whileStatement',
					range: {},
					condition: undefined,
					value: undefined
				}

				if(this.token.type !== 'keywordWhile') {
					return;
				}

				node.range.start = this.position++;
				node.condition = this.rules.expressionsSequence();

				this.ruleHelpers.preconditionalStatementValue(node, 'condition', 'value');

				if(node.condition == null) {
					this.report(2, node.range.start, node.type, 'No condition.');
				}
				if(node.value == null) {
					this.report(0, node.range.start, node.type, 'No value.');
				}

				node.range.end = this.position-1;

				return node;
			}
		}

		static ruleHelpers = {
			/*
			 * Returns a list of nodes of the types in sequential order like [1, 2, 3, 1...].
			 *
			 * Additionally a separator between the nodes can be set.
			 * Also types can be marked subsequential and therefore have no impact on offset in iterations.
			 *
			 * Stops when an unsupported type occurs.
			 *
			 * Useful for precise sequences lookup.
			 */
			sequentialNodes: (types, separating, subsequentialTypes) => {
				let nodes = [],
					offset = 0;

				while(!this.tokensEnd) {
					let type = types[offset%types.length],
						node = this.rules[type]?.();

					if(node == null) {
						break;
					}

					nodes.push(node);

					if(!subsequentialTypes?.includes(node.type)) {
						offset++;
					}

					if(separating != null && offset > 0) {
						if(separating()) {
							this.position++;
						} else {
							break;
						}
					}
				}

				return nodes;
			},
			/*
			 * Returns a node of the type or the "unsupported" node if not closed immediately.
			 *
			 * Stops if node found, at 0 (relatively to 1 at start) scope level or at the .tokensEnd.
			 *
			 * Warns about "unsupported" nodes.
			 *
			 * Useful for imprecise single enclosed(ing) nodes lookup.
			 */
			skippableNode: (type, opening, closing) => {
				let node,
					start = this.position,
					scopeLevel = 1;

				node = this.rules[type]?.();

				if(node != null || closing() || this.tokensEnd) {
					return node;
				}

				node = {
					type: 'unsupported',
					range: {
						start: this.position,
						end: this.position
					},
					tokens: []
				}

				while(!this.tokensEnd) {
					scopeLevel += opening();
					scopeLevel -= closing();

					if(scopeLevel === 0) {
						break;
					}

					node.tokens.push(this.token);
					node.range.end = this.position++;
				}

				let range = node.range.start !== node.range.end,
					message = range ? 'range of tokens ['+node.range.start+':'+node.range.end+']' : 'token ['+node.range.start+']';

				this.report(1, node.range.start, node.type, 'At '+message+'.');

				return node;
			},
			/*
			 * Returns a list of nodes of the types, including the "unsupported" nodes if any occur.
			 *
			 * Additionally a (optional) separator between the nodes can be set.
			 *
			 * Stops at 0 (relatively to 1 at start) scope level or at the .tokensEnd.
			 *
			 * Warns about invalid separators and "unsupported" nodes.
			 *
			 * Useful for imprecise multiple enclosed(ing) nodes lookup.
			 */
			skippableNodes: (types, opening, closing, separating, optionalSeparator) => {
				let nodes = [],
					scopeLevel = 1;

				while(!this.tokensEnd) {
					let node;

					if(separating == null || nodes.length === 0 || nodes.at(-1).type === 'separator' || optionalSeparator) {
						for(let type of types) {
							node = this.rules[type]?.();

							if(node != null) {
								nodes.push(node);

								break;
							}
						}
					}

					if(closing() && scopeLevel === 1 || this.tokensEnd) {
						break;
					}

					if(separating?.()) {
						node = nodes.at(-1);

						if(node?.type !== 'separator') {
							node = {
								type: 'separator',
								range: {
									start: this.position,
									end: this.position
								}
							}

							nodes.push(node);
						} else {
							node.range.end = this.position;
						}

						this.position++;
					}

					if(node != null) {
						continue;
					}

					node = nodes.at(-1);

					if(node?.type !== 'unsupported') {
						node = {
							type: 'unsupported',
							range: {
								start: this.position,
								end: this.position
							},
							tokens: []
						}
					}

					scopeLevel += opening();
					scopeLevel -= closing();

					if(scopeLevel === 0) {
						break;
					}

					node.tokens.push(this.token);
					node.range.end = this.position++;

					if(node !== nodes.at(-1)) {
						nodes.push(node);
					}
				}

				for(let key in nodes) {
					let node = nodes[key],
						range = node.range.start !== node.range.end;

					if(node.type === 'separator') {
						if(key == 0) {
							this.report(0, node.range.start, node.type, 'Met before any supported type at token ['+node.range.start+'].');
						}
						if(range) {
							this.report(0, node.range.start, node.type, 'Sequence at range of tokens ['+node.range.start+':'+node.range.end+'].');
						}
						if(key == nodes.length-1) {
							this.report(0, node.range.start, node.type, 'Excess at token ['+node.range.start+'].');
						}
					}
					if(node.type === 'unsupported') {
						let message = range ? 'range of tokens ['+node.range.start+':'+node.range.end+']' : 'token ['+node.range.start+']';

						this.report(1, node.range.start, node.type, 'At '+message+'.');
					}
				}

				nodes = nodes.filter(v => v.type !== 'separator');

				return nodes;
			},
			/*
			 * Trying to set the node's value to a functionBody or an expressionsSequence.
			 *
			 * Trailing closures can be unwrapped from the condition-callExpression/subscriptExpression or from a last
			 * callExpression/subscriptExpression that is stored in the condition-expressionsSequence.
			 * Nested into prefixExpression ones are also supported.
			 *
			 * Useful for completing preconditional statements, such as if or for.
			 */
			preconditionalStatementValue: (node, conditionType, valueType) => {
				node[valueType] = this.rules.functionBody();

				if(node[conditionType] == null || node[valueType] != null) {
					return;
				}

				let node_ = node[conditionType],
					sequence,
					prefixed;

				if(sequence = node_.type === 'expressionsSequence') {
					node_ = node_.values.at(-1);
				}
				if(prefixed = node_.type === 'prefixExpression') {
					node_ = node_.value;
				}

				if(['callExpression', 'subscriptExpression'].includes(node_.type) && node_.closure != null && node_.closure.signature == null) {
					this.position = node_.closure.range.start;

					if(sequence) {
						if(prefixed) {
							node[conditionType].values.at(-1).value =     node[conditionType].values.at(-1).value.callee;
							node[conditionType].values.at(-1).range.end = node[conditionType].values.at(-1).value.range.end;
							node[conditionType].range.end =               node[conditionType].values.at(-1).range.end;
						} else {
							node[conditionType].values.splice(-1, 1, node[conditionType].values.at(-1).callee);
							node[conditionType].range.end =          node[conditionType].values.at(-1).range.end;
						}
					} else {
						if(prefixed) {
							node[conditionType].value =     node[conditionType].value.callee;
							node[conditionType].range.end = node[conditionType].value.range.end;
						} else {
							node[conditionType] = node[conditionType].callee;
						}
					}

					node[valueType] = this.rules.functionBody();
				}

				node[valueType] ??= this.rules.expressionsSequence();
			}
		}

		static get position() {
			return this.#position;
		}

		static set position(value) {
			if(value < this.#position) {  // Rollback global changes
				this.reports = this.reports.filter(v => v.position < value);
			}

			this.#position = value;
		}

		static get token() {
			return this.tokens[this.position] ?? {
				position: undefined,
				location: undefined,
				type: '',
				value: ''
			}
		}

		static get tokensEnd() {
			return this.position === this.tokens.length;
		}

		static report(level, position, type, string) {
			let location = this.tokens[position].location;

			if(this.reports.find(v =>
				v.location.line === location.line &&
				v.location.column === location.column &&
				v.string === string) != null
			) {
				return;
			}

			this.reports.push({
				level: level,
				position: position,
				location: location,
				string: type+' -> '+string
			});
		}

		static reset() {
			this.tokens = []
			this.#position = 0;
			this.reports = []
		}

		static parse(lexerResult) {
			this.reset();

			this.tokens = lexerResult.tokens;

			let result = {
				tree: this.rules.module(),
				reports: this.reports
			}

			this.reset();

			return result;
		}
	}

	class Interpreter {
		static memory;
		static preferences;

		static rules = {
			module: (node, scope) => {
				this.rules.statements(node.statements, scope);
			},
			classDeclaration: (node, scope) => {
				let composite = this.createClass(scope),
					modifiers = node.modifiers?.values ?? [],
					identifier = node.identifier.value,
					type = this.createType(false, true, [composite.address, 'Self'], false, false),
					value = composite,
					observers = []

				this.setMember(scope, modifiers, identifier, type, value, observers);
				this.rules.statements(node.body?.statements, composite);
			},
			enumerationDeclaration: (node, scope) => {
				let composite = this.createEnumeration(scope),
					modifiers = node.modifiers?.values ?? [],
					identifier = node.identifier.value,
					type = this.createType(false, true, [composite.address, 'Self'], false, false),
					value = composite,
					observers = []

				this.setMember(scope, modifiers, identifier, type, value, observers);
				this.rules.statements(node.body?.statements, composite);
			},
			namespaceDeclaration: (node, scope) => {
				let composite = this.createNamespace(scope),
					modifiers = node.modifiers?.values ?? [],
					identifier = node.identifier.value,
					type = this.createType(false, true, [composite.address, 'Self'], false, false),
					value = composite,
					observers = []

				this.setMember(scope, modifiers, identifier, type, value, observers);
				this.rules.statements(node.body?.statements, composite);
			},
			protocolDeclaration: (node, scope) => {
				let composite = this.createProtocol(scope),
					modifiers = node.modifiers?.values ?? [],
					identifier = node.identifier.value,
					type = this.createType(false, true, [composite.address, 'Self'], false, false),
					value = composite,
					observers = []

				this.setMember(scope, modifiers, identifier, type, value, observers);
				this.rules.statements(node.body?.statements, composite);
			},
			structureDeclaration: (node, scope) => {
				let composite = this.createStructure(scope),
					modifiers = node.modifiers?.values ?? [],
					identifier = node.identifier.value,
					type = this.createType(false, true, [composite.address, 'Self'], false, false),
					value = composite,
					observers = []

				this.setMember(scope, modifiers, identifier, type, value, observers);
				this.rules.statements(node.body?.statements, composite);
			},
			variableDeclaration: (node, scope) => {
				let modifiers = node.modifiers?.values ?? []

				for(let declarator of node.declarators) {
					let identifier = declarator.identifier.value,
						type = this.rules.type(declarator.type_, scope),
						value = this.rules[declarator.value?.type]?.(declarator.value, scope),
						observers = []

					this.setMember(scope, modifiers, identifier, type, value, observers);
				}
			},
			type: (node, scope) => {
				let type = this.createType(false, false, [], true, false);

				this.rules[node?.type]?.(node, type, scope);

				return type;
			},
			anyType: (node, type) => {
				type.inheritance.push(node.value);
			},
			compositeType: (node, type) => {
				type.inheritance.push(node.value);
			},
			primitiveType: (node, type) => {
				type.inheritance.push(node.value);
			},
			parenthesizedType: (node, type, scope) => {
				this.rules[node.value?.type]?.(node.value, type, scope);
			},
			variadicType: (node, type, scope) => {
				type.variadic = true;

				this.rules[node.value?.type]?.(node.value, type, scope);
			},
			inoutType: (node, type, scope) => {
				type.inout = true;

				this.rules[node.value?.type]?.(node.value, type, scope);
			},
			unionType: (node, type, scope) => {
				for(let subtype of node.subtypes) {
					let subinheritance = this.rules.type(subtype, scope)?.inheritance;

					if(subinheritance.length > 1) {
						type.inheritance.push(subinheritance);
					} else
					if(subinheritance.length === 1) {
						type.inheritance.push(subinheritance[0]);
					}
				}
			},
			intersectionType: (node, type, scope) => {
				for(let subtype of node.subtypes) {
					type.inheritance.push(...this.rules.type(subtype, scope)?.inheritance);
				}
			},
			typeReference: (node, type, scope) => {
				let member = this.findMember(scope, node.identifier.value);

				if(member == null || ['bool', 'float', 'int', 'string'].includes(member.type.inheritance[0])) {
					return;
				}

				type.inheritance.push({
					address: member.value,
					genericInheritance: []
				});
			},
			statements: (statements, scope) => {
				for(let statement of statements ?? []) {
					this.rules[statement.type]?.(statement, scope);
				}
			}
		}

		static serializeMemory() {
			return JSON.stringify(this.memory);
		}

		static createComposite(inheritance, scope) {
			let composite = {
				address: this.memory.reduce((a, b) => b.address > a ? b.address : a, -1)+1,
				inheritance: inheritance,
				scopeAddress: scope?.address,
				retainers: []  // List will allow to notify their observers if the composite will suddenly get destroyed
			}

			this.memory.push(composite);

			if(scope != null) {
				this.retainComposite(scope, composite);
			}

			return composite;
		}

		static destroyComposite(composite) {
			this.deleteImports(composite);
			this.deleteFunctionMembers(composite);
			this.deleteMembers(composite);
			this.deleteObservers(composite);

			let scope = this.getComposite(composite.scopeAddress);

			if(scope != null) {
				composite.scopeAddress = undefined;

				this.releaseComposite(scope, composite);
			}

			this.memory = this.memory.filter(v => v !== composite);
		}

		static getComposite(address) {
			return this.memory.find(v => v.address === address);
		}

		static retainComposite(retainedComposite, retainingComposite) {
			if(
				this.compositeRetains(retainedComposite, retainingComposite) &&
				!retainedComposite.retainers.includes(retainingComposite.address)
			) {
				retainedComposite.retainers.push(retainingComposite.address);
			}
		}

		/*
		 * Old note but not really much changed and tested:
		 *
		 * Most likely will not actually destroy any composite due to an internal retains by an owned members (etc.).
		 * Probably that retains should be weak (ignored) by default, or performance will decrease drastically,
		 * because, in favor of dynamic interpreting, we are not going to insert deallocs or anything into AST
		 * (like ObjC and Swift do at the compilation stage). Besides, a type composites in common don't
		 * have a way to be undeclared, but not in case of JS or Root, so that also should be kept in mind.
		 */
		static releaseComposite(retainedComposite, retainingComposite) {
			if(this.compositeRetains(retainedComposite, retainingComposite)) {
				return;
			}

			retainedComposite.retainers = retainedComposite.retainers.filter(v => v !== retainingComposite.address);

			if(!this.compositeRetained(retainedComposite)) {
				this.destroyComposite(retainedComposite);
			}
		}

		/*
		 * Returns a real state of retainment.
		 *
		 * Composite considered retained if:
		 * - It is used as a retainer's scope, while this retainer is not the Function type.
		 * - It is used by a retainer's import, member or observer.
		 */
		static compositeRetains(retainedComposite, retainingComposite) {
			return (
				retainedComposite.address === retainingComposite.scopeAddress &&
				retainingComposite.inheritance[0] !== 'Function' ||
				this.importRetains(retainedComposite, retainingComposite) ||
				this.memberRetains(retainedComposite, retainingComposite) ||
				this.observerRetains(retainedComposite, retainingComposite)
			);
		}

		/*
		 * Composite considered retained if:
		 * - It is accessible from global composite.
		 * - It is accessible from scope of any function in call stack.
		 */
		static compositeRetained(retainedComposite) {
			if(
				this.compositeAccessible(retainedComposite) ||
				this.compositeCalled(retainedComposite)
			) {
				return true;
			}
		}

		/*
		 * Returns true if the composite is accessible from the global one,
		 * recursively checking its retainers list.
		 */
		static compositeAccessible(retainedComposite) {
			if(retainedComposite.address === 0) {
				return true;
			}
			for(let retainer of retainedComposite.retainers) {
				let retainingComposite = this.getComposite(retainer);

				if(retainingComposite != null && this.compositeAccessible(retainingComposite)) {
					return true;
				}
			}
		}

		static compositeCalled(composite) {
			return false;
		}

		static createClass(scope) {
			let class_ = this.createComposite(['Class'], scope);

			class_.members = []
			class_.observers = []

			return class_;
		}

		static createEnumeration(scope) {
			let enumeration = this.createComposite(['Enumeration'], scope);

			enumeration.members = []

			return enumeration;
		}

		static createFunction(genericParameters, parameters, awaits, throws, returnType, statements, scope) {
			let function_ = this.createComposite(['Function'], scope);

			function_.genericParameters = genericParameters;
			function_.parameters = parameters;
			function_.awaits = awaits;
			function_.throws = throws;
			function_.returnType = returnType;
			function_.statements = statements;

			return function_;
		}

		/*
		 * Setting the scope forces a function to be run in it without creating an interlayering namespace.
		 * This can be useful for declarations, but scope itself can't be retained then.
		 */
		static callFunction(function_, arguments_, scope) {
			let namespace = scope ?? this.createNamespace(this.getComposite(function_.scopeAddress)),
				result;

			for(let argument of arguments_ ?? []) {
				this.setMember(namespace, [], argument.identifier, argument.type, argument.value, []);
			}

			result = this.rules.statements(function_.statements, namespace);

			if(scope == null) {
				this.releaseComposite(namespace, function_);
			}

			return result;
		}

		static createNamespace(scope) {
			let namespace = this.createComposite(['Namespace'], scope);

			namespace.imports = []
			namespace.operators = []
			namespace.members = []
			namespace.observers = []

			return namespace;
		}

		static createObject(scope) {
			let object = this.createComposite(['Object'], scope);

			object.members = []

			return object;
		}

		static createProtocol(scope) {
			let protocol = this.createComposite(['Protocol'], scope);

			protocol.members = []

			return protocol;
		}

		static createStructure(scope) {
			let structure = this.createComposite(['Structure'], scope);

			structure.members = []
			structure.observers = []

			return structure;
		}

		static createType(inout, fixed, inheritance, nillable, variadic) {
			return {
				inout: inout,
				fixed: fixed,
				inheritance: inheritance,
				nillable: nillable,
				variadic: variadic
			}
		}

		static findImport(composite, identifier) {
			while(composite != null) {
				let import_ = this.getImport(composite, identifier);

				if(import_ != null) {
					return import_;
				}

				composite = this.getComposite(composite.scopeAddress);
			}
		}

		static getImport(composite, identifier) {
			return composite.imports.find(v => v.identifier === identifier);
		}

		static setImport(composite, identifier, value) {
			let import_ = this.getImport(composite, identifier) ?? composite.imports[composite.imports.push({})-1]

			import_.identifier = identifier;
			import_.value = value?.address ?? value;
		}

		static deleteImport(composite, identifier) {
			let import_ = this.getImport(identifier);

			composite.imports = composite.imports.filter(v => v !== import_);

			let value = this.getComposite(import_.value);

			if(value != null) {
				this.releaseComposite(value, composite);
			}
		}

		static deleteImports(composite) {
			for(let import_ of composite.imports ?? []) {
				this.deleteImport(composite, import_.identifier);
			}
		}

		static importRetains(retainedComposite, retainingComposite) {
			return retainingComposite.imports?.some(v => v.value === retainedComposite.address);
		}

		static findOperator(composite, identifier) {
			while(composite != null) {
				let operator = this.getOperator(composite, identifier);

				if(operator != null) {
					return operator;
				}

				composite = this.getComposite(composite.scopeAddress);
			}
		}

		static getOperator(composite, identifier) {
			return composite.operators.find(v => v.identifier === identifier);
		}

		static setOperator(composite, modifiers, identifier, associativity, precedence) {
			let operator = this.getOperator(composite, identifier) ?? composite.operators[composite.operators.push({})-1]

			operator.modifiers = modifiers;
			operator.identifier = identifier;
			operator.associativity = associativity;
			operator.precedence = precedence;
		}

		static deleteOperator(composite, identifier) {
			let operator = this.getOperator(identifier);

			composite.operators = composite.operators.filter(v => v !== operator);
		}

		static findMember(composite, identifier) {
			while(composite != null) {
				let member = this.getMember(composite, identifier);

				if(member != null) {
					return member;
				}

				composite = this.getComposite(composite.scopeAddress);
			}
		}

		static getMember(composite, identifier) {
			return composite.members.find(v => v.identifier === identifier);
		}

		static setMember(composite, modifiers, identifier, type, value, observers) {
			let member = this.getMember(composite, identifier) ?? composite.members[composite.members.push({})-1],
				oldValue = typeof member.value === 'number' ? this.getComposite(member.value) : undefined;

			if(
				!modifiers.includes('private') &&
				!modifiers.includes('protected') &&
				!modifiers.includes('public')
			) {
				modifiers.push('public');
			}

			member.modifiers = modifiers;
			member.identifier = identifier;
			member.type = type;
			member.value = value?.address ?? value;
			member.observers = observers;

			if(oldValue != null && oldValue.address !== value?.address) {
				this.releaseComposite(oldValue, composite);
			}
			if(value?.address != null) {
				this.retainComposite(value, composite);
			}
		}

		static deleteMember(composite, identifier) {
			let member = this.getMember(composite, identifier);

			composite.members = composite.members.filter(v => v !== member);

			if(typeof member.value !== 'number') {
				return;
			}

			let value = this.getComposite(member.value);

			if(value != null) {
				this.releaseComposite(value, composite);
			}
		}

		static deleteMembers(composite) {
			for(let member of composite.members ?? []) {
				this.deleteMember(composite, member.identifier);
			}
		}

		static deleteFunctionMember(composite, functionMember) {
			if(typeof functionMember.value !== 'number') {
				return;
			}

			let function_ = this.getComposite(functionMember.value);

			if(function_?.inheritance[0] !== 'Function') {
				return;
			}

			composite.members = composite.members.filter(v => v !== functionMember);

			this.releaseComposite(function_, composite);
		}

		static deleteFunctionMembers(composite) {
			for(let member of composite.members ?? []) {
				this.deleteFunctionMember(composite, member);
			}
		}

		static memberRetains(retainedComposite, retainingComposite) {
			// TODO: Should also support in-type retains (or they should be ignored?) and retains by observers

			return retainingComposite.members?.some(v => v.value === retainedComposite.address);
		}

		static findFunction(composite, identifier, arguments_) {
			while(composite != null) {
				let function_ = this.getFunction(composite, identifier, arguments_);

				if(function_ != null) {
					return function_;
				}

				composite = this.getComposite(composite.scopeAddress);
			}
		}

		static getFunction(composite, identifier, arguments_) {

		}

		// findObserver, getObserver, setObserver

		static deleteObserver(composite, observer) {
			composite.observers = composite.observers.filter(v => v !== observer);

			let value = this.getComposite(observer.value);

			if(value != null) {
				this.releaseComposite(value, composite);
			}
		}

		static deleteObservers(composite) {
			for(let observer of composite.observers ?? []) {
				this.deleteObserver(composite, observer);
			}
		}

		static observerRetains(retainedComposite, retainingComposite) {
			return retainingComposite.observers?.some(v => v.value === retainedComposite.address);
		}

		static reset(memory, preferences) {
			this.memory = memory ?? []
			this.preferences = {
				allowedReportLevel: 2,
				metaprogrammingLevel: 3,
				arbitaryPrecisionArithmetics: true,
				...(preferences ?? {})
			}
		}

		static interpret(parserResult, memory = [], preferences = {}) {
			this.reset(memory, preferences);

			let namespace = this.getComposite(0) ?? this.createNamespace();

			this.rules.module(parserResult.tree, namespace);

			let result = this.memory;

			this.reset();

			return result;
		}
	}

	let input = document.getElementById('input'),
		output_lint = document.getElementById('output_lint'),
		output_tokens = document.getElementById('output_tokens'),
		output_ast = document.getElementById('output_ast'),
		output_console = document.getElementById('output_console'),
		change_tree = document.getElementById('change_tree');

	function parse() {
		let lexerResult = Lexer.tokenize(input.value),
			parserResult = Parser.parse(lexerResult),
			interpreterResult = Interpreter.interpret(parserResult),
			tokens = lexerResult.rawTokens,
			reports = [...lexerResult.reports, ...parserResult.reports]
					  .sort((a, b) => a.location.line-b.location.line || a.location.column-b.location.column);

		let lintHTML = '';

		for(let k = 0; k < tokens.length; k++) {
			let position = tokens[k].position,
				type = tokens[k].type,
				value = tokens[k].value,
				generated = tokens[k].generated,
				length = value.length,
				element;

			if(type === 'whitespace') {
				for(let i = 0; i < value.length; i++) {
					if(value[i] !== '\n') {
						element ??= document.createElement('span');
						element.innerText += value[i]

						if(value[i+1] === '\n' || i === value.length-1) {
							lintHTML += element.outerHTML;
							element = undefined;
						}
					}
					if(value[i] === '\n') {
						lintHTML += document.createElement('br').outerHTML;
					}
				}
			} else {
				element = document.createElement('span');
				element.innerText = value;

				if(type.startsWith('comment')) {
					element.style.color = 'rgb(95 179 63 / 1)';
				}
				if(type.startsWith('string') && !type.startsWith('stringExpression')) {
					element.style.color = 'rgb(191 127 95 / 1)';
				}
				if(type.startsWith('operator')) {
					element.style.color = 'rgb(255 191 0 / 1)';

					if(type.endsWith('Prefix')) {
						element.style.color = 'rgb(255 63 0 / 1)';
					}
					if(type.endsWith('Infix')) {
						element.style.color = 'rgb(255 95 0 / 1)';
					}
					if(type.endsWith('Postfix')) {
						element.style.color = 'rgb(255 127 0 / 1)';
					}
				}
				if(
					type.startsWith('parenthesis') ||
					type.startsWith('brace') ||
					type.startsWith('bracket') ||
					type === 'delimiter'
				) {
					element.style.color = 'rgb(255 255 255 / 1)';
				}
				if(type.startsWith('keyword')) {
					element.style.color = 'cornflowerblue';

					if([
						'nil',
						'true',
						'false'
					].includes(value)) {
						element.style.color = 'rgb(223 127 223 / 1)';
					}
				}
				if(type.startsWith('number')) {
					element.style.color = 'rgb(223 127 223 / 1)';
				}
				if(type === 'unsupported') {
					element.style.color = 'transparent';
				}
				if(generated) {
					element.style.fontStyle = 'italic';
				}

				lintHTML += element.outerHTML;
			}
		}

		let consoleHTML = '';

		console.clear();
		for(let report of reports) {
			let level = report.level.toString()
									.replace('0', 'Info')
									.replace('1', 'Warning')
									.replace('2', 'Error'),
				line = report.location.line+1,
				column = report.location.column+1,
				string = report.string,
				message = line+':'+column+': '+level+': '+string;

			consoleHTML += message+'\n';
			console.log(message);
		}
		console.log(lexerResult.tokens);
		console.log(parserResult.tree);
		console.log(interpreterResult)

		output_lint.innerHTML = lintHTML;
		output_tokens.innerText = JSON.stringify(lexerResult.tokens, null, 4);
		output_ast.innerText = JSON.stringify(parserResult.tree, null, 4);
		output_console.innerText = consoleHTML;
	}

	input.oninput = parse;
	input.onscroll = () => {
		output_lint.scrollTop = input.scrollTop;
		output_lint.scrollLeft = input.scrollLeft;
	}
	input.value = require('fs').readFileSync(global.__dirname+'/Resources/Modules/Test').toString();

	change_tree.onclick = () => {
		if(output_tokens.style.display !== 'none') {
			output_tokens.style.display = 'none';
			output_ast.style.display = 'block';
		} else {
			output_tokens.style.display = 'block';
			output_ast.style.display = 'none';
		}
	}

	parse();
</script>
</body>
</html>
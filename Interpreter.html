<html>
<body>
<style>
body {
	display: grid;
	grid-template-columns: 5fr 4fr;
	grid-template-rows: 2fr 1fr;
	grid-template-areas:
		'code trees'
		'console console';

	margin: 0;
}

#input,
#output_lint,
#output_trees,
#output_console {
	overflow: auto;

	font: 12px monospace;
	tab-size: 4;
	white-space: pre;
}

#input,
#output_lint {
	grid-area: code;

	box-sizing: border-box;

	padding: 2px;

	border: none;
	background: rgb(63 63 63 / 1);

	color: rgba(255 255 255 / 0.25);
	caret-color: white;
}

#output_lint {
	background: none;

	color: rgb(191 191 191 / 1);

	pointer-events: none;
}

#output_trees,
#output_console {
	grid-area: trees;

	overflow-x: auto;

	background: rgb(223 223 223 / 1);

	font-size: 10px;
}

#output_console {
	grid-area: console;

	background: none;
}
</style>
<textarea id="input"></textarea>
<div id="output_lint"></div>
<div id="output_trees">
	<button id="change_tree">Change tree</button>
	<div id="output_tokens" style="display: none;"></div>
	<div id="output_ast"></div>
	<div id="output_composites" style="display: none;"></div>
</div>
<div id="output_console"></div>
<script>
	let Lexer = require('./Lexer'),
		Parser = require('./Parser'),
		Interpreter = require('./Interpreter');

	let input = document.getElementById('input'),
		output_lint = document.getElementById('output_lint'),
		output_tokens = document.getElementById('output_tokens'),
		output_ast = document.getElementById('output_ast'),
		output_composites = document.getElementById('output_composites'),
		output_console = document.getElementById('output_console'),
		change_tree = document.getElementById('change_tree');

	function parse() {
		console.clear();

		let lexerResult = Lexer.tokenize(input.value),
			parserResult = Parser.parse(lexerResult),
			interpreterResult = Interpreter.interpret(lexerResult, parserResult),
			tokens = lexerResult.rawTokens,
			reports = [...parserResult.reports, ...interpreterResult.reports]
					  /*.sort((a, b) => a.location.line-b.location.line || a.location.column-b.location.column)*/;

		let lintHTML = '';

		for(let k = 0; k < tokens.length; k++) {
			let position = tokens[k].position,
				type = tokens[k].type,
				value = tokens[k].value,
				generated = tokens[k].generated,
				length = value.length,
				element;

			if(type === 'whitespace') {
				for(let i = 0; i < value.length; i++) {
					if(value[i] !== '\n') {
						element ??= document.createElement('span');
						element.innerText += value[i]

						if(value[i+1] === '\n' || i === value.length-1) {
							lintHTML += element.outerHTML;
							element = undefined;
						}
					}
					if(value[i] === '\n') {
						lintHTML += document.createElement('br').outerHTML;
					}
				}
			} else {
				element = document.createElement('span');
				element.innerText = value;

				if(type.startsWith('comment')) {
					element.style.color = 'rgb(95 179 63 / 1)';
				}
				if(type.startsWith('string') && !type.startsWith('stringExpression')) {
					element.style.color = 'rgb(191 127 95 / 1)';
				}
				if(type.startsWith('operator')) {
					element.style.color = 'rgb(255 191 0 / 1)';

					if(type.endsWith('Prefix')) {
						element.style.color = 'rgb(255 63 0 / 1)';
					}
					if(type.endsWith('Infix')) {
						element.style.color = 'rgb(255 95 0 / 1)';
					}
					if(type.endsWith('Postfix')) {
						element.style.color = 'rgb(255 127 0 / 1)';
					}
				}
				if(
					type.startsWith('parenthesis') ||
					type.startsWith('brace') ||
					type.startsWith('bracket') ||
					type === 'delimiter'
				) {
					element.style.color = 'rgb(255 255 255 / 1)';
				}
				if(type.startsWith('keyword')) {
					element.style.color = 'rgb(96 151 255 / 1)';

					if([
						'nil',
						'true',
						'false'
					].includes(value)) {
						element.style.color = 'rgb(223 127 223 / 1)';
					}
				}
				if(type === 'identifier' && value[0] === value[0].toUpperCase()) {
					element.style.color = 'rgb(223 223 223 / 1)';
				}
				if(type.startsWith('number')) {
					element.style.color = 'rgb(223 127 223 / 1)';
				}
				if(type === 'unsupported') {
					element.style.color = 'transparent';
				}
				if(generated) {
					element.style.fontStyle = 'italic';
				}

				lintHTML += element.outerHTML;
			}
		}

		let consoleHTML = '';

		for(let report of reports) {
			let level = report.level.toString()
									.replace('0', 'Info')
									.replace('1', 'Warning')
									.replace('2', 'Error'),
				line = report.location.line+1,
				column = report.location.column+1,
				string = report.string,
				message = line+':'+column+': '+level+': '+string;

			consoleHTML += message+'\n';
			console.log(message);
		}
		console.log(lexerResult.tokens);
		console.log(parserResult.tree);
		console.log(interpreterResult.composites);

		output_lint.innerHTML = lintHTML;
		output_tokens.innerText = JSON.stringify(lexerResult.tokens, null, 4);
		output_ast.innerText = JSON.stringify(parserResult.tree, null, 4);
		output_composites.innerText = JSON.stringify(interpreterResult.composites, null, 4);
		output_console.innerText = consoleHTML;
	}

	input.oninput = parse;
	input.onscroll = () => {
		output_lint.scrollTop = input.scrollTop;
		output_lint.scrollLeft = input.scrollLeft;
	}
	input.value = require('fs').readFileSync(global.__dirname+'/Resources/Modules/Test').toString();

	change_tree.onclick = () => {
		if(output_tokens.style.display !== 'none') {
			output_ast.style.display = 'block';

			output_tokens.style.display =
			output_composites.style.display = 'none';
		} else
		if(output_ast.style.display !== 'none') {
			output_composites.style.display = 'block';

			output_tokens.style.display =
			output_ast.style.display = 'none';
		} else {
			output_tokens.style.display = 'block';

			output_ast.style.display =
			output_composites.style.display = 'none';
		}
	}

	parse();
</script>
</body>
</html>
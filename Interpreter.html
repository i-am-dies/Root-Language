<html>
<body>
<style>
	#input {
		width: 768px;
		height: 512px;

		border: none;
		border-radius: 2px;
		background: white;
		box-shadow: 0 2px 4px gray;

		color: black;
	}
</style>
<textarea id="input">
// Foundation Source

struct Boolean {
	const value

	func initialize(value: bool) {
		self.value = value
	}

	func ==(rhs: bool & Boolean) -> Boolean {
		return rhs !is Boolean ? value == rhs : value == rhs.value
	}
}

struct Number {
	static const Pi = 3.14

	const value

	func initialize(value: int & decimal) {
		self.value = value
	}

	func ==(rhs: int & decimal & Number) -> Boolean {
		return rhs !is Number ? value == rhs : value == rhs.value
	}
}

struct Decimal: Number {
	func initialize(value: int & decimal) {
		if var v = value%2 && (v == 0 || v == 1) {
			throw 'Value can\'t be integer'
		}

		self.value = value
	}
}

struct Integer: Number {
	func initialize(value: int & decimal) {
		if var v = value%2 && v > 0 && v < 1 {
			throw 'Value can\'t be decimal'
		}

		self.value = value
	}
}

struct String {
	const value

	func initialize(value: string) {
		self.value = value
	}

	func ==(rhs: string & String) -> Boolean {
		return rhs !is String ? value == rhs : value == rhs.value
	}
}

// ---- ---- ---- ----

/* Comment
Block */

// Comment Line

import Foundation

alias Boolean = Foundation.Boolean,
	  Number = Foundation.Number,
	  Decimal = Foundation.Decimal,
	  Integer = Foundation.Integer,
	  String = Foundation.String

const constant = Number.Pi

var variable

if constant > 0 {
	variable = 1
}

class Class {
	const private constant: Number = 0.5

	var protected variable: Integer = 1

	var variable_01a = 'String'

	var private anotherVariableStorage

	var anotherVariable {
		willSet(newValue) {}
		set(newValue) {
			anotherVariableStorage = newValue
		}
		didSet(newValue) {}
		willGet {}
		get {
			return anotherVariableStorage
		}
		didGet {}
	}

	subscript(index: Integer) {
		get {}
		set(newValue) {}
	}

	func initialize(with parameter: Integer = 0, and parameter_: String) {
		print('Intitializing with \(parameter) and \(parameter_)')

		variable = parameter
		variable_01a = parameter_
	}

	func deinitialize {
		print('Deinitializing!')
	}
}

var instance = Class(with: 12, and: '2')

print('Testing nested template string: printing some \(identifier+'abc\(1+2+3)def'+0.125) and \(instance.variable)')

instance = nil
</textarea>
<script>
	let code = document.getElementById('input').value;

	class Lexer {
		static code;
		static position;
		static location;
		static tokens;
		static levels;
		static rules = [
			['/*', (v) => {
				if(this.levels.comment > 0 || this.levels.string > this.levels.stringExpression) {
					this.lastToken.value += v;
				} else {
					this.createToken('commentBlock', '');
				}
				if(this.lastToken.type === 'commentBlock') {
					this.levels.comment++;
				}
			}],
			['*/', (v) => {
				if(this.levels.comment > 0 && this.lastToken.type === 'commentLine' || this.levels.comment > 1 || this.levels.string > this.levels.stringExpression) {
					this.lastToken.value += v;
				}
				if(this.lastToken.type === 'commentBlock') {
					this.levels.comment--;
				}
			}],
			['//', (v) => {
				if(this.levels.comment > 0 || this.levels.string > this.levels.stringExpression) {
					this.lastToken.value += v;
				} else {
					this.createToken('commentLine', '');
					this.levels.comment++;
				}
			}],
			[['\\\\', '\\\'', '\\(', '\\b', '\\f', '\\n', '\\r', '\\t', '\\v', '\\'], (v) => {
				if(this.levels.comment > 0) {
					this.lastToken.value += v;
				} else
				if(this.levels.string > this.levels.stringExpression) {
					switch(v) {
						case '\\\\':	v = '\\';		break;
						case '\\\'':	v = '\'';		break;
						case '\\(':		return true;	break;
						case '\\b':		v = '\b';		break;
						case '\\f':		v = '\f';		break;
						case '\\n':		v = '\n';		break;
						case '\\r':		v = '\r';		break;
						case '\\t':		v = '\t';		break;
						case '\\v':		v = '\v';		break;
						case '\\':		v = '';			break;
					}

					this.lastToken.value += v;
				}
			}],
			[['\\(', ')'], (v) => {
				if(this.levels.comment > 0) {
					this.lastToken.value += v;
				} else {
					switch(v) {
						case '\\(':
							if(this.levels.string > this.levels.stringExpression) {
								this.lastToken.type = 'stringPart';
								this.createToken('stringExpressionOpen', v);
								this.levels.stringExpression++;
							}
						break;
						case ')':
							if(this.levels.string > this.levels.stringExpression || this.levels.stringExpression === 0 || this.levels.stringExpressionParenthesis > 0) {
								return true;
							}
							this.createToken('stringExpressionClosed', v);
							this.levels.stringExpression--;
							this.createToken('stringPart', '');
						break;
					}
				}
			}],
			[['!=', '!', '%', '&&', '&', '??', '?.', '?', '||', '==', '=', '<=', '<', '>=', '>', '--', '-=', '->', '-', '++', '+=', '+', '/=', '/', '*=', '*', ':', '.', ','], (v) => {
				if(this.levels.comment > 0 || this.levels.string > this.levels.stringExpression) {
					this.lastToken.value += v;
				} else {
					let title;

					switch(v) {
						case '!=':	title = 'NotEquals';		break;
						case '!':	title = 'Not';				break;
						case '%':	title = 'Remainder';		break;
						case '&&':	title = 'And';				break;
						case '&':	title = 'Ampersand';		break;
						case '??':	title = 'NullCoalescing';	break;
						case '?.':	title = 'OptionalChain';	break;
						case '?':	title = 'Question';			break;
						case '||':	title = 'Or';				break;
						case '==':	title = 'Equals';			break;
						case '=':	title = 'Assign';			break;
						case '<=':	title = 'SmallerEquals';	break;
						case '<':	title = 'Smaller';			break;
						case '>=':	title = 'BiggerEquals';		break;
						case '>':	title = 'Bigger';			break;
						case '--':	title = 'Decrement';		break;
						case '-=':	title = 'MinusAssign';		break;
						case '->':	title = 'Returns';			break;
						case '-':	title = 'Minus';			break;
						case '++':	title = 'Increment';		break;
						case '+=':	title = 'PlusAssign';		break;
						case '+':	title = 'Plus';				break;
						case '/=':	title = 'DivideAssign';		break;
						case '/':	title = 'Divide';			break;
						case '*=':	title = 'MultiplyAssign';	break;
						case '*':	title = 'Multiply';			break;
						case ':':	title = 'Colon';			break;
						case '.':
							if(this.lastToken.type === 'numberInteger') {
								return true;
							} else {
								title = 'Chain';
							}
						break;
						case ',':	title = 'Also';				break;
					}

					this.createToken('operator'+title, v);
				}
			}],
			[['(', ')', '{', '}', '[', ']'], (v) => {
				if(this.levels.comment > 0 || this.levels.string > this.levels.stringExpression) {
					this.lastToken.value += v;
				} else {
					let title;

					switch(v) {
						case '(':
							if(this.levels.stringExpression > 0) {
								this.levels.stringExpressionParenthesis++;
							}
							title = 'parenthesisOpen';
						break;
						case ')':
							if(this.levels.stringExpression > 0) {
								this.levels.stringExpressionParenthesis--;
							}
							title = 'parenthesisClosed';
						break;
						case '{':	title = 'braceOpen';			break;
						case '}':	title = 'braceClosed';			break;
						case '[':	title = 'bracketOpen';			break;
						case ']':	title = 'bracketClosed';		break;
					}

					this.createToken(title, v);
				}
			}],
			['\'', () => {
				if(this.levels.comment > 0) {
					return true;
				}
				if(this.levels.string === this.levels.stringExpression) {
					this.createToken('string', '');
					this.levels.string++;
				} else
				if(this.levels.string > this.levels.stringExpression) {
					this.levels.string--;
				}
			}],
			[/\s|;/, (v) => {
				if(this.levels.comment > 0 || this.levels.string > this.levels.stringExpression) {
					if(v === '\n' && this.lastToken.type === 'commentLine') {
						this.createToken('delimiter');
						this.levels.comment--;
					} else {
						this.lastToken.value += v;
					}
				} else
				if(this.lastToken.type === 'delimiter') {
					this.lastToken.value += v;
				} else {
					this.createToken('delimiter');
				}
			}],
			[/[0-9\.]/, (v) => {
				if(this.levels.comment > 0 || this.levels.string > this.levels.stringExpression || this.lastToken.type.startsWith('number') || this.lastToken.type === 'identifier' && v !== '.') {
					if(this.lastToken.type === 'numberInteger' && v === '.') {
						this.lastToken.type = 'numberFloat';
					}
					this.lastToken.value += v;
				} else
				if(v !== '.') {
					this.createToken('numberInteger');
				}
			}],
			[/[a-z_]/i, (v) => {
				if(this.levels.comment > 0 || this.levels.string > this.levels.stringExpression) {
					return true;
				}
				if(this.lastToken.type !== 'identifier' && !this.lastToken.type.startsWith('keyword')) {
					this.createToken('identifier', '');
				}
				this.lastToken.value += v;
				if([
					'alias',
					'break',
					'case',
					'class',
					'const',
					'continue',
					'default',
					'else',
					'false',
					'for',
					'func',
					'if',
					'import',
					'is',
					'nil',
					'private',
					'protected',
					'return',
					'self',
					'struct',
					'subscript',
					'super',
					'switch',
					'throw',
					'true',
					'var',
					'while'
				].includes(this.lastToken.value)) {
					this.lastToken.type = 'keyword'+this.lastToken.value[0].toUpperCase()+this.lastToken.value.slice(1);
				} else {
					this.lastToken.type = 'identifier';
				}
			}],
			[/.|\n/i, (v) => {
				if(this.lastToken.type === 'commentBlock' || this.lastToken.type === 'commentLine' && v !== '\n' || this.levels.string > this.levels.stringExpression) {
					this.lastToken.value += v;
				} else {
					this.report('Warning: No token of appropriate type was created before to accept this character and it doesn\'t represent any possible type independently: "'+v+'", skipping...');
				}
			}]
		]

		static get lastToken() {
			return this.tokens.at(-1) ?? {
				position: undefined,
				location: undefined,
				type: '',
				value: ''
			}
		}

		static createToken(type, value) {
			this.tokens.push({
				position: this.position,
				location: {...this.location},
				type: type,
				value: value != null ? value : this.code[this.position]
			});
		}

		static report(string) {
			console.log(this.location.x+':'+this.location.y+': '+string);
		}

		static reset() {
			this.code = undefined;
			this.position = undefined;
			this.location = {
				x: 0,
				y: 0
			}
			this.tokens = []
			this.levels = {
				comment: 0,
				string: 0,
				stringExpression: 0,
				stringExpressionParenthesis: 0
			}
		}

		static atPosition(substring) {
			return this.code.indexOf(substring, this.position) === this.position;
		}

		static tokenize(code) {
			this.reset();

			for(this.position = 0; this.position < (this.code = code).length; this.position++) {
				for(let rule of this.rules) {
					let triggers = rule[0],
						actions = rule[1],
						plain = typeof triggers === 'string',
						array = Array.isArray(triggers),
						regex = triggers instanceof RegExp,
						trigger;

					if(plain && this.atPosition(triggers)) {
						trigger = triggers;
					}
					if(array) {
						trigger = triggers.find(v => this.atPosition(v));
					}
					if(regex && triggers.test(this.code[this.position])) {
						trigger = this.code[this.position]
					}
					if(trigger != null && !actions(trigger)) {
						this.position += trigger.length-1;
						for(let character of trigger) {
							if(character === '\n') {
								this.location.x = 0;
								this.location.y++;
							} else {
								this.location.x++;
							}
						}

						break;
					}
				}
			}

			let tokens = this.tokens.filter(v => !(v.type === 'delimiter' && !v.value.includes('\n') && !v.value.includes(';')));

			this.reset();

			return tokens;
		}
	}

	class Parser {
		static tokens;
		static position;
		static tree;
		static grammar = {
			binaryExpression: 'binaryExpressionSide binaryExpressionOperator binaryExpressionSide',
			binaryExpressionOperator: [
				'operatorBigger',
				'operatorBiggerEquals',
				'operatorEquals',
				'operatorNotEquals',
				'operatorSmaller',
				'operatorSmallerEquals'
			],
			binaryExpressionSide: [
				'identifier',
				'keywordFalse',
				'keywordNil',
				'keywordTrue',
				'numberFloat',
				'numberInteger',
				'string'
			],
			classDeclaration: 'keywordClass memberDeclarationBlock',
			codeBlock: 'braceOpen codeBlockItemList braceClosed',
			codeBlockItemList: [
				'aliasDeclaration',
				'classDeclaration',
				'delimiter',
				'functionCallExpression',
				'functionDeclaration',
				'ifStatement',
				'importDeclaration',
				'structureDeclaration',
				'variableAssignment',
				'variableDeclaration'
			],
			condition: [
				'conditionalExpression',
				'parenthesisOpen condition parenthesisClosed'
			],
			conditionalExpression: [
				'binaryExpression',
				'logicalExpression'
			],
			functionDeclaration: [
				'keywordFunc identifier codeBlock',
				'keywordFunc identifier operatorReturns identifier codeBlock'
			],
			ifStatement: 'keywordIf condition codeBlock',
			logicalExpression: 'condition logicalExpressionOperator condition',
			logicalExpressionOperator: [
				'operatorAnd',
				'operatorOr'
			],
			memberDeclarationBlock: 'braceOpen memberDeclarationList braceClosed',
			memberDeclarationList: [
				'classDeclaration',
				'functionDeclaration',
				'structureDeclaration',
				'variableDeclaration'
			],
			module: 'codeBlockItemList',
			structureDeclaration: 'keywordStruct memberDeclarationBlock'
		}
		static rules = {
			logicalExpression: () => {}
		}

		static createNode(parent = this.tree, type) {
			parent.children ??= []

			parent.children.push({
				type: type ?? 'node',
				parent: parent
			});
		}

		static reset() {
			this.tokens = []
			this.position = 0;
			this.tree = {
				type: 'module'
			}
		}

		static parse(tokens) {
			this.reset();

			tokens = tokens.filter(v => !v.type.startsWith('comment') && v.type !== 'delimiter');

			for(this.position; this.position < (this.tokens = tokens).length; this.position++) {
				this.rules[this.tokens[this.position].type]?.();
			}

			this.reset();

			return this.tree;
		}
	}

	let tokens = Lexer.tokenize(code);//,
	//	tree = Parser.parse(tokens);

	console.log(tokens);
	//console.log(tree);
</script>
</body>
</html>
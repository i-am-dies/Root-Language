<html>
<body>
<style>
body {
	display: grid;
	grid-template-columns: 5fr 4fr;
	grid-template-rows: 2fr 1fr;
	grid-template-areas:
		'code trees'
		'console console';

	margin: 0;
}

#input,
#output_lint,
#output_trees,
#output_console {
	overflow: auto;

	font: 12px monospace;
	tab-size: 4;
	white-space: pre;
}

#input,
#output_lint {
	grid-area: code;

	box-sizing: border-box;

	padding: 2px;

	border: none;
	background: rgb(63 63 63 / 1);

	color: rgba(255 255 255 / 0.25);
	caret-color: white;
}

#output_lint {
	background: none;

	color: rgb(191 191 191 / 1);

	pointer-events: none;
}

#output_trees,
#output_console {
	grid-area: trees;

	overflow-x: auto;

	background: rgb(223 223 223 / 1);

	font-size: 10px;
}

#output_console {
	grid-area: console;

	background: none;
}
</style>
<textarea id="input">
if a { notClosure }

if b { closure }.inside { closure }
{ notClosure }

.outside

if c {
	notClosure
}

if d { closure } {
	notClosure
}

if e { closure } { closure
} {
	notClosure
}

if f { closure }.inside {
	{ notClosure }
}

if g {
	notClosure
}

.outside {
	notClosure
}

if h {
	notClosure
}

(outside) {
	notClosure
}

if k { closure }.inside { closure }
/**/ { notClosure }

.outside

if l {
  {
    {
      {
        if i {
          notClosure
        }
      }
    }
  }
}

if o /**/
{ /**/
/**/
}

if m { n /**/
/**/
}
/**/
{
/**/
}

// Foundation Source

postfix operator ++
postfix operator --

prefix operator ++
prefix operator --

/* private */ infix operator == {
	associativity: left
	precedence: 64
}

struct Boolean {
	private final var value

	init(value: bool) {
		self.value = value  // .value = value
	}

	static func ==(lhs: bool & Self, rhs: bool & Self) -> Self {
		var leftValue = lhs !is Self ? lhs : lhs.value,
			rightValue = rhs !is Self ? rhs : rhs.value

		return leftValue == rightValue
	}
}

struct Number {
	static final var Pi = 3.141592653589793

	protected final var value

	init(value: int & float) {
		.value = value
	}

	static func ==(lhs: int & float & Self, rhs: int & float & Self) -> Boolean {
		var leftValue = lhs !is Self ? lhs : lhs.value,
			rightValue = rhs !is Self ? rhs : rhs.value

		return leftValue == rightValue
	}
}

struct Float: Number {
	init(value: int & float) {
		if var v = value%2 && (v == 0 || v == 1) {
			throw 'Value can\'t be integer'
		}

		.value = value
	}
}

struct Integer: Number {
	init(value: int & float) {
		if var v = value%2 && v > 0 && v < 1 {
			throw 'Value can\'t be float'
		}

		.value = value
	}
}

struct String {
	private final var value

	init(value: string) {
		.value = value
	}

	static func ==(lhs: string & Self, rhs: string & Self) -> Boolean {
		var leftValue = lhs !is Self ? lhs : lhs.value,
			rightValue = rhs !is Self ? rhs : rhs.value

		return leftValue == rightValue
	}
}

class Array {}

class Dictionary {}

// ---- ---- ---- ----

/* Multiblock
	/* Comment */
		Block */

// Comment Line

import Foundation

final var Boolean = Foundation.Boolean,
	  	  Number = Foundation.Number,
	  	  Decimal = Foundation.Decimal,
	  	  Integer = Foundation.Integer,
	  	  String = Foundation.String,
	  	  Array = Foundation.Array,
	  	  Dictionary = Foundation.Dictionary

final var constant = Number.Pi

var variable

if constant > 0 {
	variable = 1
}

class A {
	private final var constant: Number = 0.5

	protected var variable: Integer = 1

	var variable_01a = 'String'

	var anotherVariable {
		willGet {}
		get {
			return value
		}
		didGet {}

		willSet {}
		set {
			value = newValue
		}
		didSet {}
	}

	chain {
		get {
			return metaSelf.members[key]?.value
		}
		set {
			metaSelf.members[key] = value
		}
		delete {
			delete metaSelf.members[key]
		}
	}

	subscript(a: Integer, b: Integer) -> Integer {
		get {
			return a+b
		}
		set {
			print(a, b)
		}
	}

	init(with number: Integer = 0, and string_: String) {
		print('Intitializing with \(number) and \(string_)')

		variable = number
		variable_01a = string_
	}

	deinit {
		print('Deinitializing!')
	}
}

var instance = A(with: 12, and: '2')

/*
var self.A: self.Class = class { ... }

var self.instance = A(with: 12, and: '2')
*/

print('Testing nested template string: printing some \(identifier+'abc\(1+2+3)def'+0.125) and \(instance.variable)')

var instance_2 = struct {
	init(test: Integer) {
		print('Initialized anonymous struct with testing variable: '+test)
	}
}(12)

instance =
instance_2 = nil

enum B {
	case first
	case second
	case third
	case fourth
}

var enum_value: B = .first

var function

/*
function = { x in x > 0 } - 1

function = (x) in x > 0
function = (x) { x > 0 }
function = (x) { return x > 0 } - 2

function = func (x) in x > 0
function = func (x) { x > 0 }
function = func (x) { return x > 0 } - 3

func getMnemonic(color: Color) =
    when color {
        .RED -> "кот"
        .ORANGE -> "охотник"
        .YELLOW -> "желает"
        .GREEN -> "знать"
        .BLUE -> "где"
        .INDIGO -> "сидят"
        .VIOLET -> "фазаны"
	}

func getWarmth(color: Int) = when(color) {
    RED, YELLOW -> "warm"
    GREEN -> "neutral"
    BLUE -> "cold"
    else -> "unknown"
}

when catImageView.visibility {
    View.VISIBLE -> println('visible')
    View.INVISIBLE -> println('invisible')
    else -> println('gone')
}
*/

var A = 1

print(A)		// 1

if true {		// If statements have local scopes
	print(A)	// class (Declarations execute first)

	class A {}
}

print(A)		// 1

A = class {}

print(A)		// class
</textarea>
<div id="output_lint"></div>
<div id="output_trees">
	<button id="change_tree">Change tree</button>
	<div id="output_tokens" style="display: none;"></div>
	<div id="output_ast"></div>
</div>
<div id="output_console"></div>
<script>
	class Lexer {
		static code;
		static position;
		static location;
		static tokens;
		static states;
		static reports;

		static rules = [
			[['/*', '*/'], (v) => {
				if(this.atComments || this.atString) {
					this.ruleHelpers.continueString();
					this.token.value += v;
				} else
				if(v === '/*') {
					this.addToken('commentBlock', v);
				}
				if(this.token.type === 'commentBlock') {
					if(v === '/*') {
						this.addState('comment');
					} else {
						this.removeState('comment');
					}
				}
			}],
			['//', (v) => {
				if(this.atComments || this.atString) {
					this.ruleHelpers.continueString();
					this.token.value += v;
				} else {
					this.addToken('commentLine', v);
					this.addState('comment');
				}
			}],
			[['\\\\', '\\\'', '\\(', '\\b', '\\f', '\\n', '\\r', '\\t', '\\v', '\\'], (v) => {
				if(this.atComments) {
					this.token.value += v;

					return;
				}
				if(!this.atString) {
					this.ruleHelpers.reportSkip(v);

					return;
				}
				if(v === '\\(') {
					return true;
				}

				this.ruleHelpers.continueString();
				this.token.value += ({
					'\\\\': '\\',
					'\\\'': '\'',
					'\\b': '\b',
					'\\f': '\f',
					'\\n': '\n',
					'\\r': '\r',
					'\\t': '\t',
					'\\v': '\v',
					'\\': ''
				})[v]
			}],
			[['\\(', ')'], (v) => {
				if(this.atComments) {
					this.token.value += v;

					return;
				}

				if(v === '\\(' && this.atString) {
					this.addToken('stringExpressionOpen', v);
					this.addState('stringExpression');
				}
				if(v === ')' && this.atStringExpression) {
					this.addToken('stringExpressionClosed');
					this.removeState('stringExpression');
				} else {
					return v === ')';
				}
			}],
			[['!', '%', '&', '*', '+', ',', '-', '.', '/', ':', '<', '=', '>', '?', '^', '|', '~'], (v) => {
				let initializers = [',', '.', ':'],	// Create new token if value exists in the list and current (operator) token doesn't initialized with it
					singletons = ['!', '?']			// Create new token if current (postfix operator) token matches any value in the list

				let initializer = initializers.includes(v) && !this.token.value.startsWith(v),
					singleton = this.token.type === 'operatorPostfix' && singletons.includes(this.token.value),
					closingAngle = this.atState('angle', []) && v === '>';

				if(this.atComments || this.atString) {
					this.ruleHelpers.continueString();
					this.token.value += v;

					return;
				}
				if(this.token.type.startsWith('operator') && !initializer && !singleton && !closingAngle) {
					this.ruleHelpers.finalizeOperator(true, false);
					this.token.value += v;

					return;
				}
				if(singleton) {
					this.addToken(this.token.type);

					return;
				}

				let type = 'operator';

				if(
					['string', 'identifier'].includes(this.token.type) ||
					this.token.type.endsWith('Closed') ||
					this.token.type.startsWith('number') ||
					this.token.type.startsWith('keyword')
				) {
					type += 'Postfix';
				}

				this.ruleHelpers.finalizeOperator(false);
				this.addToken(type);

				if(v === '<') this.addState('angle');
				if(v === '>') this.removeState('angle');
			}],
			[['(', ')', '[', ']', '{', '}'], (v) => {
				if(this.atComments || this.atString) {
					this.ruleHelpers.continueString();
					this.token.value += v;

					return;
				}

				let type = ({
					'(': 'parenthesisOpen',
					')': 'parenthesisClosed',
					'[': 'bracketOpen',
					']': 'bracketClosed',
					'{': 'braceOpen',
					'}': 'braceClosed'
				})[v]

				this.ruleHelpers.finalizeOperator(false, type.endsWith('Open'));
				this.addToken(type);
				this.removeState('angle', 2);  // Balanced tokens except </> are allowed right after generic types but not inside them

				if(v === '{' && this.atStatement && this.atToken((t, v) => t === 'whitespace' && v.includes('\n'), this.ignorable, -1)) {
					this.addState('statementBody');

					return;
				}
				if(v === '}' && this.atStatementBody) {
					this.addToken('delimiter', ';');
					this.token.generated = true;
					this.removeState('statement');

					return;
				}

				if(this.atStringExpressions) {
					if(v === '(') this.addState('parenthesis');
					if(v === ')') this.removeState('parenthesis');
				}
				if(this.atStatements) {
					if(v === '{') this.addState('brace');
					if(v === '}') this.removeState('brace');
				}
			}],
			['\'', (v) => {
				if(this.atComments) {
					this.token.value += v;

					return;
				}

				if(!this.atString) {
					this.ruleHelpers.finalizeOperator();
					this.addToken('stringOpen');
					this.addState('string');
				} else {
					this.addToken('stringClosed');
					this.removeState('string');
				}
			}],
			[';', (v) => {
				if(this.atComments || this.atString) {
					this.ruleHelpers.continueString();
					this.token.value += v;

					return;
				}

				if(this.token.type === 'delimiter' && this.token.generated) {
					delete this.token.generated;
				} else {
					this.addToken('delimiter');
				}
			}],
			[/\n/g, (v) => {
				if(this.atComments && this.token.type !== 'commentLine' || this.atString) {
					this.ruleHelpers.continueString();
					this.token.value += v;

					return;
				}

				if(this.token.type !== 'whitespace') {
					this.addToken('whitespace', v);

					if(this.getToken(-1).type === 'commentLine') {
						this.removeState('comment');
					}
				} else {
					this.token.value += v;
				}

				if(this.atStatement && this.token.value.match(/\n/g).length === 1) {
					let braceOpen = (t) => t === 'braceOpen';

					if(this.atToken(braceOpen, this.ignorable)) {
						this.addState('statementBody');
					} else
					if(!this.atState('brace') && !this.atFutureToken(braceOpen, this.ignorable)) {
						this.removeState('statement');
					}
				}
			}],
			[/[^\S\n]+/g, (v) => {
				if(this.atComments || this.atString || this.token.type === 'whitespace') {
					this.ruleHelpers.continueString();
					this.token.value += v;

					return;
				}

				this.addToken('whitespace', v);
			}],
			[/[0-9]+/g, (v) => {
				if(this.atComments || this.atString) {
					this.ruleHelpers.continueString();
					this.token.value += v;

					return;
				}
				if(this.token.type === 'operatorPostfix' && this.token.value === '.' && this.getToken(-1).type === 'numberInteger') {
					this.removeToken();
					this.token.type = 'numberFloat';
					this.token.value += '.'+v;

					return;
				}

				this.ruleHelpers.finalizeOperator();
				this.addToken('numberInteger', v);
			}],
			[/[a-z_][a-z0-9_]*/gi, (v) => {
				if(this.atComments || this.atString) {
					this.ruleHelpers.continueString();
					this.token.value += v;

					return;
				}

				let keywords = [
					// Flow-related words (async, class, for, return...)
					// Literals (false, nil, true...)
					// Types (Any, bool, _, ...)

					// Words as Self, arguments, metaSelf or self are not allowed because they all
					// have dynamic values and it's logical to distinguish them at the interpretation stage

					'Any',
					'Class',
					'Enumeration',
					'Function',
					'Namespace',
					'Object',
					'Protocol',
					'Structure',
					'any', 'async', 'await', 'awaits',
					'bool', 'break',
					'case', 'catch', 'class', 'continue',
					'default', 'do',
					'else', 'enum', 'extension',
					'fallthrough', 'false', 'final', 'float', 'for', 'func',
					'if', 'import', 'in', 'infix', 'int', 'is',
					'lazy',
					'namespace', 'nil',
					'operator',
					'postfix', 'prefix', 'private', 'protected', 'protocol', 'public',
					'return',
					'static', 'string', 'struct', 'switch',
					'throw', 'throws', 'true', 'try',
					'var',
					'while',
					'_'
				]

				let type = 'identifier';

				if(keywords.includes(v)) {
					type = 'keyword';

					if(v === '_') {
						type += 'Underscore';
					}

					let value = v[0].toUpperCase()+v.slice(1);

					type += v[0] === value[0] ? 'Capital'+value : value;
				}

				this.ruleHelpers.finalizeOperator(type.startsWith('keyword'));
				this.addToken(type, v);

				if(['keywordIf', 'keywordSwitch', 'keywordWhile'].includes(type)) {
					this.addState('statement');
				}
			}],
			[/./g, (v) => {
				if(this.token.type === 'commentBlock' || this.token.type === 'commentLine' && v !== '\n' || this.atString) {
					this.ruleHelpers.continueString();
					this.token.value += v;

					return;
				}

				this.ruleHelpers.reportSkip(v);
			}]
		]

		static ruleHelpers = {
			continueString: () => {
				if(['stringOpen', 'stringExpressionClosed'].includes(this.token.type)) {
					this.addToken('stringSegment', '');
				}
			},
			finalizeOperator: (merge = true, specifyType = true) => {
				if(merge) {
					this.removeState('angle', 2);

					for(let i = this.tokens.length; i >= 0; i--) {
						if(!this.token.type.startsWith('operator') || !this.getToken(-1).type.startsWith('operator')) {
							break;
						}

						this.getToken(-1).value += this.token.value;
						this.removeToken();
					}
				}
				if(specifyType) {
					switch(this.token.type) {
						case 'operator':		this.token.type = 'operatorPrefix';	break;
						case 'operatorPostfix':	this.token.type = 'operatorInfix';	break;
					}
				}
			},
			reportSkip: (v) => {
				this.report(0, 'No token of an appropriate type was created before to accept this character and it doesn\'t represent any possible type independently: "'+v+'", skipping...');
			}
		}

		static get codeEnd() {
			return this.position >= this.code.length;
		}

		static get token() {
			return this.getToken();
		}

		static get atComments() {
			return this.atState('comment');
		}

		static get atString() {
			return this.atState('string', []);
		}

		static get atStringExpression() {
			return this.atState('stringExpression', []);
		}

		static get atStringExpressions() {
			return this.atState('stringExpression');
		}

		static get atStatement() {
			return this.atState('statement', ['brace']);
		}

		static get atStatements() {
			return this.atState('statement');
		}

		static get atStatementBody() {
			return this.atState('statementBody', []);
		}

		static ignorable = (t) => t === 'whitespace' || t.startsWith('comment');

		static getToken(offset = 0) {
			return this.tokens[this.tokens.length-1+offset] ?? {
				position: undefined,
				location: undefined,
				type: '',
				value: ''
			}
		}

		static addToken(type, value) {
			this.tokens.push({
				position: this.position,
				location: {...this.location},
				type: type,
				value: value ?? this.code[this.position]
			});
		}

		static removeToken(offset = 0) {
			this.tokens = this.tokens.filter((v, k) => k !== this.tokens.length-1+offset);
		}

		/*
		 * Check for token(s) starting from rightmost (inclusively if no offset set), using combinations of type and value within predicate.
		 *
		 * Strict by default, additionally whitelist predicate can be set.
		 *
		 * Useful for complex token sequences check.
		 */
		static atToken(conforms, whitelisted, offset = 0) {
			for(let i = this.tokens.length-1+offset; i >= 0; i--) {
				let token = this.tokens[i],
					type = token.type,
					value = token.value;

				if(conforms(type, value)) {
					return true;
				}
				if(whitelisted != null && !whitelisted(type, value)) {
					return;
				}
			}
		}

		/*
		 * Future-time version of atToken(). Rightmost (at the moment) token is not included in a search.
		 */
		static atFutureToken(conforms, whitelisted) {
			let save = this.getSave(),
				result;

			this.position += this.token.value.length;

			while(!this.codeEnd) {
				this.nextToken();

				let token = this.tokens.at(-1),
					type = token?.type,
				    value = token?.value;

				if(conforms(type, value)) {
					result = true;

					break;
				}
				if(whitelisted != null && !whitelisted(type, value)) {
					break;
				}
			}

			this.restoreSave(save);

			return result;
		}

		static addState(type) {
			this.states.push(type);
		}

		/*
		 * <= 0 - Remove states starting from rightmost found (inclusively)
		 *    1 - Remove states starting from leftmost found (inclusively)
		 *    2 - Remove found states, ignoring order
		 */
		static removeState(type, mode = 0) {
			if(mode < 2) {
				let i = mode === 1 ? this.states.indexOf(type) : this.states.lastIndexOf(type);

				if(i > -1) {
					this.states.length = i;
				}
			}
			if(mode === 2) {
				this.states = this.states.filter(v => v !== type);
			}
		}

		/*
		 * Check for state starting from rightmost (inclusively).
		 *
		 * Unstrict by default, additionaly whitelist can be set.
		 */
		static atState(type, whitelist) {
			for(let i = this.states.length-1; i >= 0; i--) {
				if(this.states[i] === type) {
					return true;
				}
				if(whitelist != null && !whitelist.includes(this.states[i])) {
					return;
				}
			}
		}

		static report(level, string) {
			this.reports.push({
				level: level,
				position: this.position,
				location: {...this.location},
				string: string
			});
		}

		static getSave() {
			return {
				position: this.position,
				location: {...this.location},
				tokens: this.tokens.length,
				token: {...this.token},  // Tokens themself are mutable too
				states: this.states.length,
				reports: this.reports.length
			}
		}

		static restoreSave(save) {
			this.position = save.position;
			this.location = {...save.location}
			this.tokens.length = save.tokens;
			this.states.length = save.states;
			this.reports.length = save.reports;

			if(this.tokens.length > 0) {
				this.tokens.pop();
				this.tokens.push({...save.token});
			}
		}

		static reset() {
			this.code = '';
			this.position = 0;
			this.location = {
				line: 0,
				column: 0
			}
			this.tokens = []
			this.states = []
				// angle - used to distinguish between common operator and generic type's closing >
				// brace - used in statements
				// parenthesis - used in string expressions
			this.reports = []
		}

		static atSubstring(substring) {
			return this.code.indexOf(substring, this.position) === this.position;
		}

		static atRegex(regex) {
			let substring;

			if(!regex.global) {
				regex = new RegExp(regex.source, 'g');
			}

			regex.lastIndex = this.position;
			substring = regex.exec(this.code);
			substring = substring?.index === this.position ? substring[0] : undefined;

			return substring;
		}

		static nextToken() {
			for(let rule of this.rules) {
				let triggers = rule[0],
					actions = rule[1],
					plain = typeof triggers === 'string',
					array = Array.isArray(triggers),
					regex = triggers instanceof RegExp,
					trigger;

				if(plain && this.atSubstring(triggers)) {
					trigger = triggers;
				}
				if(array) {
					trigger = triggers.find(v => this.atSubstring(v));
				}
				if(regex) {
					trigger = this.atRegex(triggers);
				}

				if(trigger != null && !actions(trigger)) {  // Multiple rules can be executed on same position if some of them return true
					this.position += trigger.length;  // Rules shouldn't explicitly set position

					for(let character of trigger) {
						if(character === '\n') {
							this.location.line++;
							this.location.column = 0;
						} else {
							this.location.column++;
						}
					}

					break;
				}
			}
		}

		static tokenize(code) {
			this.reset();

			this.code = code;

			while(!this.codeEnd) {
				this.nextToken();  // Zero-length position commits will lead to forever loop, rules developer attention is advised
			}

			let result = {
				rawTokens: this.tokens,
				tokens: this.tokens.filter(v => !this.ignorable(v.type)),
				reports: this.reports
			}

			this.reset();

			return result;
		}
	}

	class Parser {
		static tokens;
		static #position;
		static reports;

		static rules = {
			anyType: () => {
				let node = {
					type: 'anyType',
					range: {},
					value: undefined
				}

				if(this.token.type !== 'keywordUnderscore') {
					return;
				}

				node.value = this.token.value;
				node.range.start =
				node.range.end = this.position++;

				return node;
			},
			argument: () => {
				let node = {
					type: 'argument',
					range: {
						start: this.position
					},
					label: this.rules.identifier(),
					value: undefined
				}

				if(node.label != null && this.token.type.startsWith('operator') && this.token.value === ':') {
					this.position++;
				} else {
					this.position = node.range.start;
					node.label = undefined;
				}

				node.value = this.rules.expressionsSequence();
				if(node.label == null && node.value == null) {
					return;
				}

				node.range.end = this.position-1;

				return node;
			},
			arrayLiteral: () => {
				let node = {
					type: 'arrayLiteral',
					range: {},
					values: []
				}

				if(this.token.type !== 'bracketOpen') {
					return;
				}

				node.range.start = this.position++;
				node.values = this.ruleHelpers.sequentialNodes(
					['expressionsSequence'],
					() => this.token.type.startsWith('operator') && this.token.value === ','
				);

				if(this.token.type !== 'bracketClosed') {
					this.position = node.range.start;

					return;
				}

				node.range.end = this.position++;

				return node;
			},
			arrayType: () => {
				let node = {
					type: 'arrayType',
					range: {},
					value: undefined
				}

				if(this.token.type !== 'bracketOpen') {
					return;
				}

				node.range.start = this.position++;
				node.value = this.rules.type();

				if(this.token.type !== 'bracketClosed') {
					this.position--;

					return;
				}

				node.range.end = this.position++;

				return node;
			},
			asyncExpression: () => {
				let node = {
					type: 'asyncExpression',
					range: {},
					value: undefined
				}

				if(this.token.type !== 'keywordAsync') {
					return;
				}

				node.range.start = this.position++;
				node.value = this.rules.expression();

				if(node.value == null) {
					this.position--;

					return;
				}

				node.range.end = this.position-1;

				return node;
			},
			awaitExpression: () => {
				let node = {
					type: 'awaitExpression',
					range: {},
					value: undefined
				}

				if(this.token.type !== 'keywordAwait') {
					return;
				}

				node.range.start = this.position++;
				node.value = this.rules.expression();

				if(node.value == null) {
					this.position--;

					return;
				}

				node.range.end = this.position-1;

				return node;
			},
			body: (type) => {
				let node = {
					type: type+'Body',
					range: {},
					statements: []
				}

				if(this.token.type !== 'braceOpen') {
					return;
				}

				node.range.start = this.position++;
				node.statements = this.rules[type+'Statements']?.();

				if(node.statements.length === 0) {
					this.report(0, node.range.start, node.type, 'No statements.');
				}

				if(!this.tokensEnd) {
					node.range.end = this.position++;
				} else {
					node.range.end = this.position-1;

					this.report(1, node.range.start, node.type, 'Node doesn\'t have the closing brace and was decided to be autoclosed at the end of stream.');
				}

				return node;
			},
			booleanLiteral: () => {
				let node = {
					type: 'booleanLiteral',
					range: {},
					value: undefined
				}

				if(!['keywordFalse', 'keywordTrue'].includes(this.token.type)) {
					return;
				}

				node.value = this.token.value;
				node.range.start =
				node.range.end = this.position++;

				return node;
			},
			breakStatement: () => {
				let node = {
					type: 'breakStatement',
					range: {},
					label: undefined
				}

				if(this.token.type !== 'keywordBreak') {
					return;
				}

				node.range.start = this.position++;
				node.label = this.rules.identifier();
				node.range.end = this.position-1;

				return node;
			},
			callExpression: (node_) => {
				let node = {
					type: 'callExpression',
					range: {
						start: node_.range.start
					},
					callee: node_,
					genericArguments: [],
					arguments: [],
					closure: undefined
				}

				if(this.token.type.startsWith('operator') && this.token.value === '<') {
					this.position++;
					node.genericArguments = this.ruleHelpers.sequentialNodes(
						['type'],
						() => this.token.type.startsWith('operator') && this.token.value === ','
					);

					if(this.token.type.startsWith('operator') && this.token.value === '>') {
						this.position++;
					} else {
						this.position = node_.range.end+1;
					}
				}

				if(this.token.type === 'parenthesisOpen') {
					this.position++;
					node.arguments = this.ruleHelpers.skippableNodes(
						['argument'],
						() => this.token.type === 'parenthesisOpen',
						() => this.token.type === 'parenthesisClosed',
						() => this.token.type.startsWith('operator') && this.token.value === ','
					);

					if(this.token.type === 'parenthesisClosed') {
						this.position++;
					} else {
						node.range.end = this.position-1;

						this.report(1, node.range.start, node.type, 'Node doesn\'t have the closing parenthesis and was decided to be autoclosed at the end of stream.');

						return node;
					}
				}

				node.closure = this.rules.closureExpression();

				if(node.closure == null && node.arguments.length === 0) {
					return;
				}

				node.range.end = this.position-1;

				return node;
			},
			caseDeclaration: () => {
				let node = {
					type: 'caseDeclaration',
					range: {},
					identifiers: []
				}

				if(this.token.type !== 'keywordCase') {
					return;
				}

				node.range.start = this.position++;
				node.identifiers = this.ruleHelpers.sequentialNodes(
					['identifier'],
					() => this.token.type.startsWith('operator') && this.token.value === ','
				);

				if(node.identifiers.length === 0) {
					this.report(0, node.range.start, node.type, 'No identifiers(s).');
				}

				node.range.end = this.position-1;

				return node;
			},
			chainBody: (strict) => {
				let node = this.rules.body('chain');

				if(node != null && strict && !node?.statements.some(v => v.type !== 'unsupported')) {
					this.position = node.range.start;

					return;
				}

				return node;
			},
			chainDeclaration: () => {
				let node = {
					type: 'chainDeclaration',
					range: {
						start: this.position
					},
					modifiers: this.rules.modifiers(),
					body: undefined
				}

				if(this.token.type !== 'identifier' || this.token.value !== 'chain') {
					this.position = node.range.start;

					return;
				}

				node.range.start = this.position++;
				node.body = this.rules.chainBody();

				if(node.modifiers?.values.some(v => v !== 'static')) {
					this.report(1, node.range.start, node.type, 'Can only have specific modifier (static).');
				}
				if(node.body == null) {
					this.report(0, node.range.start, node.type, 'No body.');
				}

				node.range.end = this.position-1;

				return node;
			},
			chainExpression: (node_) => {
				let node = {
					type: 'chainExpression',
					range: {
						start: node_.range.start
					},
					composite: node_,
					member: undefined
				}

				if(!['operator', 'operatorInfix'].includes(this.token.type) || this.token.value !== '.') {
					return;
				}

				this.position++;
				node.member =
					this.rules.identifier() ??
					this.rules.stringLiteral();

				if(node.member == null) {
					this.position = node_.range.end+1;

					return;
				}

				node.range.end = node.member.range.end;

				return node;
			},
			chainIdentifier: (node_) => {
				let node = {
					type: 'chainIdentifier',
					range: {
						start: node_.range.start
					},
					supervalue: node_,
					value: undefined
				}

				if(!['operatorPrefix', 'operatorInfix'].includes(this.token.type) || this.token.value !== '.') {
					return;
				}

				this.position++;
				node.value = this.rules.identifier();

				if(node.value == null) {
					this.position = node_.range.end+1;

					return;
				}

				node.range.end = node.value.range.end;

				return node;
			},
			chainStatements: () => {
				return this.rules.statements(['observerDeclaration']);
			},
			classBody: () => {
				return this.rules.body('class');
			},
			classDeclaration: (anonymous) => {
				let node = {
					type: 'class'+(!anonymous ? 'Declaration' : 'Expression'),
					range: {
						start: this.position
					},
					modifiers: this.rules.modifiers(),
					identifier: undefined,
					genericParameters: undefined,
					inheritance: undefined,
					body: undefined
				}

				if(this.token.type !== 'keywordClass') {
					this.position = node.range.start;

					return;
				}

				this.position++;
				node.identifier = this.rules.identifier();

				if(anonymous) {
					if(node.modifiers != null || node.identifier != null) {
						this.position = node.range.start;

						return;
					}

					delete node.modifiers;
					delete node.identifier;
				} else
				if(node.identifier == null) {
					this.report(2, node.range.start, node.type, 'No identifier.');
				}

				node.genericParameters = this.rules.genericParametersClause();
				node.inheritance = this.rules.inheritanceClause();
				node.body = this.rules.classBody();

				if(node.modifiers?.values.some(v => !['private', 'protected', 'public', 'static', 'final'].includes(v))) {
					this.report(1, node.range.start, node.type, 'Wrong modifier(s).');
				}
				if(node.body == null) {
					this.report(0, node.range.start, node.type, 'No body.');
				}

				node.range.end = this.position-1;

				return node;
			},
			classExpression: () => {
				return this.rules.classDeclaration(true);
			},
			classStatements: () => {
				return this.rules.statements([
					'chainDeclaration',
					'classDeclaration',
					'deinitializerDeclaration',
					'enumerationDeclaration',
					'functionDeclaration',
					'initializerDeclaration',
					'namespaceDeclaration',
					'protocolDeclaration',
					'structureDeclaration',
					'subscriptDeclaration',
					'variableDeclaration'
				]);
			},
			closureExpression: () => {
				let node = {
					type: 'closureExpression',
					range: {},
					signature: undefined,
					statements: []
				}

				if(this.token.type !== 'braceOpen') {
					return;
				}

				node.range.start = this.position++;
				node.signature = this.rules.functionSignature();

				if(node.signature != null) {
					if(this.token.type !== 'keywordIn') {
						this.position = node.range.start;

						return;
					}

					this.position++;
				} else {
					this.report(0, node.range.start, node.type, 'No signature.');
				}

				node.statements = this.rules.functionStatements();

				if(node.statements.length === 0) {
					this.report(0, node.range.start, node.type, 'No statements.');
				}

				if(!this.tokensEnd) {
					node.range.end = this.position++;
				} else {
					node.range.end = this.position-1;

					this.report(1, node.range.start, node.type, 'Node doesn\'t have the closing brace and was decided to be autoclosed at the end of stream.');
				}

				return node;
			},
			compositeType: () => {
				let node = {
					type: 'compositeType',
					range: {},
					value: undefined
				}

				if(![
					'keywordCapitalAny',
					'keywordCapitalClass',
					'keywordCapitalEnumeration',
					'keywordCapitalFunction',
					'keywordCapitalNamespace',
					'keywordCapitalObject',
					'keywordCapitalProtocol',
					'keywordCapitalStructure'
				].includes(this.token.type)) {
					return;
				}

				node.value = this.token.value;
				node.range.start =
				node.range.end = this.position++;

				return node;
			},
			conditionalOperator: () => {
				let node = {
					type: 'conditionalOperator',
					range: {},
					expression: undefined
				}

				if(!this.token.type.startsWith('operator') || this.token.value !== '?') {
					return;
				}

				node.range.start = this.position++;
				node.expression = this.rules.expressionsSequence();

				if(!this.token.type.startsWith('operator') || this.token.value !== ':') {
					this.position = node.range.start;

					return;
				}

				node.range.end = this.position++;

				return node;
			},
			continueStatement: () => {
				let node = {
					type: 'continueStatement',
					range: {},
					label: undefined
				}

				if(this.token.type !== 'keywordContinue') {
					return;
				}

				node.range.start = this.position++;
				node.label = this.rules.identifier();
				node.range.end = this.position-1;

				return node;
			},
			controlTransferStatement: () => {
				let node =
					this.rules.breakStatement() ??
					this.rules.continueStatement() ??
					this.rules.fallthroughStatement() ??
					this.rules.returnStatement() ??
					this.rules.throwStatement();

				return node;
			},
			declaration: () => {
				let node =
					this.rules.chainDeclaration() ??
					this.rules.classDeclaration() ??
					this.rules.deinitializerDeclaration() ??
					this.rules.enumerationDeclaration() ??
					this.rules.functionDeclaration() ??
					this.rules.importDeclaration() ??
					this.rules.initializerDeclaration() ??
					this.rules.namespaceDeclaration() ??
					this.rules.operatorDeclaration() ??
					this.rules.protocolDeclaration() ??
					this.rules.structureDeclaration() ??
					this.rules.subscriptDeclaration() ??
					this.rules.variableDeclaration();

				return node;
			},
			declarator: () => {
				let node = {
					type: 'declarator',
					range: {
						start: this.position
					},
					identifier: this.rules.identifier(),
					type_: undefined,
					value: undefined,
					body: undefined
				}

				if(node.identifier == null) {
					return;
				}

				node.type_ = this.rules.typeClause();
				node.value = this.rules.initializerClause();
				node.body = this.rules.chainBody(true) ?? this.rules.functionBody();
				node.range.end = this.position-1;

				return node;
			},
			defaultExpression: (node_) => {
				let node = {
					type: 'defaultExpression',
					range: {
						start: node_.range.start
					},
					value: node_
				}

				if(this.token.type !== 'operatorPostfix' || this.token.value !== '!') {
					return;
				}

				node.range.end = this.position++;

				return node;
			},
			defaultType: (node_) => {
				let node = {
					type: 'defaultType',
					range: {
						start: node_.range.start
					},
					value: node_
				}

				if(this.token.type !== 'operatorPostfix' || this.token.value !== '!') {
					return;
				}

				node.range.end = this.position++;

				return node;
			},
			deinitializerDeclaration: () => {
				let node = {
					type: 'deinitializerDeclaration',
					range: {},
					body: undefined
				}

				if(this.token.type !== 'identifier' || this.token.value !== 'deinit') {
					return;
				}

				this.position++;
				node.body = this.rules.functionBody();

				if(node.body == null) {
					this.report(0, node.range.start, node.type, 'No body.');
				}

				node.range.end = this.position-1;

				return node;
			},
			deleteExpression: () => {
				let node = {
					type: 'deleteExpression',
					range: {},
					value: undefined
				}

				if(this.token.type !== 'identifier' || this.token.value !== 'delete') {
					return;
				}

				node.range.start = this.position++;
				node.value = this.rules.expression();

				if(node.value == null) {
					this.position--;

					return;
				}

				node.range.end = this.position-1;

				return node;
			},
			dictionaryLiteral: () => {
				let node = {
					type: 'dictionaryLiteral',
					range: {},
					entries: []
				}

				if(this.token.type !== 'bracketOpen') {
					return;
				}

				node.range.start = this.position++;
				node.entries = this.ruleHelpers.sequentialNodes(
					['entry'],
					() => this.token.type.startsWith('operator') && this.token.value === ','
				);

				if(node.entries.length === 0 && this.token.type.startsWith('operator') && this.token.value === ':') {
					this.position++;
				}

				if(this.token.type === 'bracketClosed') {
					node.range.end = this.position++;
				} else {
					this.position = node.range.start;

					return;
				}

				return node;
			},
			dictionaryType: () => {
				let node = {
					type: 'dictionaryType',
					range: {},
					key: undefined,
					value: undefined
				}

				if(this.token.type !== 'bracketOpen') {
					return;
				}

				node.range.start = this.position++;
				node.key = this.rules.type();

				if(!this.token.type.startsWith('operator') || this.token.value !== ':') {
					this.position--;

					return;
				}

				this.position++;
				node.value = this.rules.type();

				if(this.token.type !== 'bracketClosed') {
					this.position = node.range.start;

					return;
				}

				node.range.end = this.position++;

				return node;
			},
			elseClause: () => {
				let node,
					start = this.position;

				if(this.token.type !== 'keywordElse') {
					return;
				}

				this.position++;
				node =
					this.rules.functionBody() ??
					this.rules.ifStatement();

				if(node == null) {
					this.report(0, start, 'elseClause', 'No body.');
				}

				return node;
			},
			entry: () => {
				let node = {
					type: 'entry',
					range: {
						start: this.position
					},
					key: this.rules.expressionsSequence(),
					value: undefined
				}
				if(node.key == null || !this.token.type.startsWith('operator') || this.token.value !== ':') {
					this.position = node.range.start;

					return;
				}

				this.position++;
				node.value = this.rules.expressionsSequence();

				if(node.value == null) {
					this.position = node.range.start;

					return;
				}

				node.range.end = this.position-1;

				return node;
			},
			enumerationBody: () => {
				return this.rules.body('enumeration');
			},
			enumerationDeclaration: (anonymous) => {
				let node = {
					type: 'enumeration'+(!anonymous ? 'Declaration' : 'Expression'),
					range: {
						start: this.position
					},
					modifiers: this.rules.modifiers(),
					identifier: undefined,
					inheritance: undefined,
					body: undefined
				}

				if(this.token.type !== 'keywordEnum') {
					this.position = node.range.start;

					return;
				}

				this.position++;
				node.identifier = this.rules.identifier();

				if(anonymous) {
					if(node.identifier != null) {
						this.position = node.range.start;

						return;
					} else {
						delete node.identifier;
					}
				} else
				if(node.identifier == null) {
					this.report(2, node.range.start, node.type, 'No identifier.');
				}

				node.inheritance = this.rules.inheritanceClause();
				node.body = this.rules.enumerationBody();

				if(node.modifiers?.values.some(v => !['private', 'protected', 'public', 'static', 'final'].includes(v))) {
					this.report(1, node.range.start, node.type, 'Wrong modifier(s).');
				}
				if(node.body == null) {
					this.report(0, node.range.start, node.type, 'No body.');
				}

				node.range.end = this.position-1;

				return node;
			},
			enumerationExpression: () => {
				return this.rules.enumerationDeclaration(true);
			},
			enumerationStatements: () => {
				return this.rules.statements([
					'caseDeclaration',
					'enumerationDeclaration'
				]);
			},
			expression: () => {
				let node =
					this.rules.asyncExpression() ??
					this.rules.awaitExpression() ??
					this.rules.deleteExpression() ??
					this.rules.tryExpression() ??
					this.rules.prefixExpression();

				return node;
			},
			expressionsSequence: () => {
				let node = {
					type: 'expressionsSequence',
					range: {
						start: this.position
					},
					values: []
				}

				let subsequentialTypes = ['inOperator', 'isOperator']

				node.values = this.ruleHelpers.sequentialNodes(['expression', 'infixExpression'], undefined, subsequentialTypes);

				if(node.values.length === 0) {
					return;
				}
				if(node.values.filter(v => !subsequentialTypes.includes(v.type)).length%2 === 0) {
					this.position = node.values.at(-1).range.start;

					node.values.pop();
				}
				if(node.values.length === 1) {
					return node.values[0]
				}

				node.range.end = this.position-1;

				return node;
			},
			fallthroughStatement: () => {
				let node = {
					type: 'fallthroughStatement',
					range: {},
					label: undefined
				}

				if(this.token.type !== 'keywordFallthrough') {
					return;
				}

				node.range.start = this.position++;
				node.label = this.rules.identifier();
				node.range.end = this.position-1;

				return node;
			},
			floatLiteral: () => {
				let node = {
					type: 'floatLiteral',
					range: {},
					value: undefined
				}

				if(this.token.type !== 'numberFloat') {
					return;
				}

				node.value = this.token.value;
				node.range.start =
				node.range.end = this.position++;

				return node;
			},
			forStatement: () => {},
			functionBody: () => {
				return this.rules.body('function');
			},
			functionDeclaration: (anonymous) => {
				let node = {
					type: 'function'+(!anonymous ? 'Declaration' : 'Expression'),
					range: {
						start: this.position
					},
					modifiers: this.rules.modifiers(),
					identifier: undefined,
					signature: undefined,
					body: undefined
				}

				if(this.token.type !== 'keywordFunc') {
					this.position = node.range.start;

					return;
				}

				this.position++;
				node.identifier =
					this.rules.identifier() ??
					this.rules.operator();

				if(anonymous) {
					if(node.modifiers != null || node.identifier != null) {
						this.position = node.range.start;

						return;
					}

					delete node.modifiers;
					delete node.identifier;
				} else
				if(node.identifier == null) {
					this.report(2, node.range.start, node.type, 'No identifier.');
				}

				node.signature = this.rules.functionSignature();
				node.body = this.rules.functionBody();

				if(node.signature == null) {
					this.report(2, node.range.start, node.type, 'No signature.');
				}
				if(node.body == null) {
					this.report(0, node.range.start, node.type, 'No body.');
				}

				node.range.end = this.position-1;

				return node;
			},
			functionExpression: () => {
				return this.rules.functionDeclaration(true);
			},
			functionSignature: () => {
				let node = {
					type: 'functionSignature',
					range: {
						start: this.position
					},
					genericParameters: this.rules.genericParametersClause(),
					parameters: [],
					awaits: false,
					throws: false,
					return: undefined
				}

				if(this.token.type === 'parenthesisOpen') {
					this.position++;
					node.parameters = this.ruleHelpers.skippableNodes(
						['parameter'],
						() => this.token.type === 'parenthesisOpen',
						() => this.token.type === 'parenthesisClosed',
						() => this.token.type.startsWith('operator') && this.token.value === ','
					);

					if(this.token.type === 'parenthesisClosed') {
						this.position++;
					} else {
						node.range.end = this.position-1;

						this.report(1, node.range.start, node.type, 'Parameters don\'t have the closing parenthesis and were decided to be autoclosed at the end of stream.');

						return node;
					}
				}

				while(['keywordAwaits', 'keywordThrows'].includes(this.token.type)) {
					if(this.token.type === 'keywordAwaits') {
						this.position++;
						node.awaits = true;
					}
					if(this.token.type === 'keywordThrows') {
						this.position++;
						node.throws = true;
					}
				}

				if(this.token.type.startsWith('operator') && this.token.value === '->') {
					this.position++;
					node.return = this.rules.type();
				}

				node.range.end = this.position-1;

				if(node.range.end < node.range.start) {
					return;
				}

				return node;
			},
			functionStatements: () => {
				return this.rules.statements([
					'expressionsSequence',  // Expressions must be parsed first as they may include (anonymous) declarations
					'declaration',
					'controlTransferStatement',
					'forStatement',
					'ifStatement',
					'whileStatement'
				]);
			},
			functionType: () => {
				let node = {
					type: 'functionType',
					range: {
						start: this.position,
						end: this.position
					},
					genericParameters: [],
					parameters: [],
					awaits: false,
					throws: false,
					return: undefined
				}

				if(this.token.type.startsWith('operator') && this.token.value === '<') {
					this.position++;
					node.genericParameters = this.ruleHelpers.sequentialNodes(
						['type'],
						() => this.token.type.startsWith('operator') && this.token.value === ','
					);

					if(this.token.type.startsWith('operator') && this.token.value === '>') {
						node.range.end = this.position++;
					} else {
						this.position = node.range.start;

						return;
					}
				}

				if(this.token.type !== 'parenthesisOpen') {
					this.position = node.range.start;

					return;
				}

				this.position++;
				node.parameters = this.ruleHelpers.sequentialNodes(
					['type'],
					() => this.token.type.startsWith('operator') && this.token.value === ','
				);

				if(this.token.type !== 'parenthesisClosed') {
					this.position = node.range.start;

					return;
				}

				while(['keywordAsync', 'keywordThrows'].includes(this.token.type)) {
					if(this.token.type === 'keywordAsync') {
						this.position++;
						node.awaits = true;

						if(this.token.type === 'operatorPostfix' && this.token.value === '?') {
							this.position++;
							node.awaits = undefined;
						}
					}
					if(this.token.type === 'keywordThrows') {
						this.position++;
						node.throws = true;

						if(this.token.type === 'operatorPostfix' && this.token.value === '?') {
							this.position++;
							node.throws = undefined;
						}
					}
				}

				if(this.token.type.startsWith('operator') && this.token.value === '->') {
					this.position++;
					node.return = this.rules.type();
				}

				node.range.end = this.position-1;

				return node;
			},
			genericParameter: () => {
				let node = {
					type: 'genericParameter',
					range: {
						start: this.position
					},
					identifier: this.rules.identifier(),
					type_: undefined
				}

				if(node.identifier == null) {
					return;
				}

				node.type_ = this.rules.typeClause();
				node.range.end = this.position-1;

				return node;
			},
			genericParametersClause: () => {
				let nodes = [],
					start = this.position;

				if(!this.token.type.startsWith('operator') || this.token.value !== '<') {
					return nodes;
				}

				this.position++;
				nodes = this.ruleHelpers.skippableNodes(
					['genericParameter'],
					() => this.token.type.startsWith('operator') && this.token.value === '<',
					() => this.token.type.startsWith('operator') && this.token.value === '>',
					() => this.token.type.startsWith('operator') && this.token.value === ','
				);

				if(!this.token.type.startsWith('operator') || this.token.value !== '>') {
					this.report(1, start, 'genericParametersClause', 'Node doesn\'t have the closing angle and was decided to be autoclosed at the end of stream.');

					return nodes;
				}

				this.position++;

				return nodes;
			},
			identifier: () => {
				let node = {
					type: 'identifier',
					range: {},
					value: undefined
				}

				if(this.token.type !== 'identifier') {
					return;
				}

				node.value = this.token.value;
				node.range.start =
				node.range.end = this.position++;

				return node;
			},
			ifStatement: () => {
				let node = {
					type: 'ifStatement',
					range: {},
					condition: undefined,
					then: undefined,
					else: undefined
				}

				if(this.token.type !== 'keywordIf') {
					return;
				}

				node.range.start = this.position++;
				node.condition = this.rules.expressionsSequence();
				node.then = this.rules.functionBody();

				if(node.then == null && node.condition != null) {
					let sequence = node.condition.type === 'expressionsSequence',
						node_ = sequence ? node.condition.values.at(-1) : node.condition;

					if(node_.type === 'callExpression' && node_.closure != null && node_.closure.signature == null) {
						this.position = node_.closure.range.start;

						if(sequence) {
							node.condition.values.pop();
							node.condition.values.push(node_.callee);
						} else {
							node.condition = node_.callee;
						}

						node.then = this.rules.functionBody();
					}
				}

				node.else = this.rules.elseClause();

				if(node.condition == null) {
					this.report(2, node.range.start, node.type, 'No condition.');
				}
				if(node.then == null) {
					this.report(0, node.range.start, node.type, 'No body.');
				}

				node.range.end = this.position-1;

				return node;
			},
			implicitChainExpression: () => {
				let node = {
					type: 'implicitChainExpression',
					range: {},
					member: undefined
				}

				if(this.token.type !== 'operatorPrefix' || this.token.value !== '.') {
					return;
				}

				node.range.start = this.position++;
				node.member =
					this.rules.identifier() ??
					this.rules.stringLiteral();

				if(node.member == null) {
					this.position--;

					return;
				}

				node.range.end = node.member.range.end;

				return node;
			},
			implicitChainIdentifier: () => {
				let node = {
					type: 'implicitChainIdentifier',
					range: {},
					value: undefined
				}

				if(this.token.type !== 'operatorPrefix' || this.token.value !== '.') {
					return;
				}

				node.range.start = this.position++;
				node.value = this.rules.identifier();

				if(node.value == null) {
					this.position--;

					return;
				}

				node.range.end = node.value.range.end;

				return node;
			},
			importDeclaration: () => {
				let node = {
					type: 'importDeclaration',
					range: {},
					value: undefined
				}

				if(this.token.type !== 'keywordImport') {
					return;
				}

				node.range.start =
				node.range.end = this.position++;
				node.value = this.rules.identifier();

				if(node.value != null) {
					while(!this.tokensEnd) {
						let node_ = this.rules.chainIdentifier(node.value);

						if(node_ == null) {
							break;
						}

						node.value = node_;
					}
				} else {
					this.report(1, node.range.start, node.type, 'No value.');
				}

				node.range.end =
					node.value?.range.end ??
					node.range.end;

				return node;
			},
			infixExpression: () => {
				let node =
					this.rules.conditionalOperator() ??
					this.rules.inOperator() ??
					this.rules.isOperator() ??
					this.rules.infixOperator();

				return node;
			},
			infixOperator: () => {
				let node = {
					type: 'infixOperator',
					range: {},
					value: undefined
				}

				let exceptions = [',', ':']  // Enclosing nodes can use operators from the list as delimiters

				if(!['operator', 'operatorInfix'].includes(this.token.type) || exceptions.includes(this.token.value)) {
					return;
				}

				node.value = this.token.value;
				node.range.start =
				node.range.end = this.position++;

				return node;
			},
			inheritanceClause: () => {
				let nodes = [],
					start = this.position;

				if(!this.token.type.startsWith('operator') || this.token.value !== ':') {
					return;
				}

				this.position++;
				nodes = this.ruleHelpers.sequentialNodes(
					['typeReference'],
					() => this.token.type.startsWith('operator') && this.token.value === ','
				);

				if(nodes.length === 0) {
					this.report(0, start, 'inheritanceClause', 'No types.');
				}

				return nodes;
			},
			initializerClause: () => {
				let node,
					start = this.position;

				if(!this.token.type.startsWith('operator') || this.token.value !== '=') {
					return;
				}

				this.position++;
				node = this.rules.expressionsSequence();

				if(node == null) {
					this.report(0, start, 'initializerClause', 'No value.');
				}

				return node;
			},
			initializerDeclaration: () => {
				let node = {
					type: 'initializerDeclaration',
					range: {
						start: this.position
					},
					modifiers: this.rules.modifiers(),
					signature: undefined,
					body: undefined
				}

				if(this.token.type !== 'identifier' || this.token.value !== 'init') {
					this.position = node.range.start;

					return;
				}

				this.position++;
				node.signature = this.rules.functionSignature();
				node.body = this.rules.functionBody();

				if(node.modifiers?.values.some(v => !['private', 'protected', 'public'].includes(v))) {
					this.report(1, node.range.start, node.type, 'Wrong modifier(s).');
				}
				if(node.signature == null) {
					this.report(0, node.range.start, node.type, 'No signature.');
				}
				if(node.body == null) {
					this.report(0, node.range.start, node.type, 'No body.');
				}

				node.range.end = this.position-1;

				return node;
			},
			inOperator: () => {
				let node = {
					type: 'inOperator',
					range: {
						start: this.position
					},
					negatiated: false,
					composite: undefined
				}

				if(this.token.type === 'operatorPrefix' && this.token.value === '!') {
					this.position++;
					node.negatiated = true;
				}

				if(this.token.type !== 'keywordIn') {
					this.position = node.range.start;

					return;
				}

				this.position++;
				node.composite = this.rules.expressionsSequence();

				if(node.composite == null) {
					this.position = node.range.start;

					return;
				}

				node.range.end = this.position-1;

				return node;
			},
			inoutExpression: () => {
				let node = {
					type: 'inoutExpression',
					range: {},
					identifier: undefined
				}

				if(this.token.type !== 'operatorPrefix' || this.token.value !== '&') {
					return;
				}

				node.range.start = this.position++;
				node.identifier = this.rules.identifier();

				if(node.identifier == null) {
					this.position--;

					return;
				}

				node.range.end = node.identifier.range.end;

				return node;
			},
			integerLiteral: () => {
				let node = {
					type: 'integerLiteral',
					range: {},
					value: undefined
				}

				if(this.token.type !== 'numberInteger') {
					return;
				}

				node.value = this.token.value;
				node.range.start =
				node.range.end = this.position++;

				return node;
			},
			intersectionType: () => {
				let node = {
					type: 'intersectionType',
					range: {
						start: this.position
					},
					subtypes: this.ruleHelpers.sequentialNodes(
						['postfixType'],
						() => this.token.type.startsWith('operator') && this.token.value === '&'
					)
				}

				if(node.subtypes.length === 0) {
					return;
				}
				if(node.subtypes.length === 1) {
					return node.subtypes[0]
				}

				node.range.end = this.position-1;

				return node;
			},
			isOperator: () => {
				let node = {
					type: 'isOperator',
					range: {
						start: this.position
					},
					type_: undefined,
					negatiated: false
				}

				if(this.token.type === 'operatorPrefix' && this.token.value === '!') {
					this.position++;
					node.negatiated = true;
				}

				if(this.token.type !== 'keywordIs') {
					this.position = node.range.start;

					return;
				}

				this.position++;
				node.type_ = this.rules.type();

				if(node.type_ == null) {
					this.position = node.range.start;

					return;
				}

				node.range.end = this.position-1;

				return node;
			},
			literalExpression: () => {
				let node =
					this.rules.arrayLiteral() ??
					this.rules.booleanLiteral() ??
					this.rules.dictionaryLiteral() ??
					this.rules.floatLiteral() ??
					this.rules.integerLiteral() ??
					this.rules.nilLiteral() ??
					this.rules.stringLiteral();

				return node;
			},
			modifiers: () => {
				let node = {
					type: 'modifiers',
					range: {
						start: this.position
					},
					values: []
				}

				while([
					'keywordInfix',
					'keywordPostfix',
					'keywordPrefix',
					'keywordPrivate',
					'keywordProtected',
					'keywordPublic',
					'keywordStatic',
					'keywordLazy',
					'keywordFinal'
				].includes(this.token.type)) {
					node.values.push(this.token.value);
					node.range.end = this.position++;
				}

				if(node.values.length === 0) {
					return;
				}

				return node;
			},
			module: () => {
				let node = {
					type: 'module',
					range: {
						start: this.position
					},
					statements: this.rules.functionStatements()
				}

				node.range.end = node.statements.length > 0 ? this.position-1 : 0;

				return node;
			},
			namespaceBody: () => {
				return this.rules.body('namespace');
			},
			namespaceDeclaration: (anonymous) => {
				let node = {
					type: 'namespace'+(!anonymous ? 'Declaration' : 'Expression'),
					range: {
						start: this.position
					},
					modifiers: this.rules.modifiers(),
					identifier: undefined,
					body: undefined
				}

				if(this.token.type !== 'keywordNamespace') {
					this.position = node.range.start;

					return;
				}

				this.position++;
				node.identifier = this.rules.identifier();

				if(anonymous) {
					if(node.modifiers != null || node.identifier != null) {
						this.position = node.range.start;

						return;
					}

					delete node.modifiers;
					delete node.identifier;
				} else
				if(node.identifier == null) {
					this.report(2, node.range.start, node.type, 'No identifier.');
				}

				node.body = this.rules.namespaceBody();

				if(node.modifiers?.values.some(v => !['private', 'protected', 'public', 'static', 'final'].includes(v))) {
					this.report(1, node.range.start, node.type, 'Wrong modifier(s).');
				}
				if(node.body == null) {
					this.report(0, node.range.start, node.type, 'No body.');
				}

				node.range.end = this.position-1;

				return node;
			},
			namespaceExpression: () => {
				return this.rules.namespaceDeclaration(true);
			},
			namespaceStatements: () => {
				return this.rules.statements(['declaration']);
			},
			nillableExpression: (node_) => {
				let node = {
					type: 'nillableExpression',
					range: {
						start: node_.range.start
					},
					value: node_
				}

				if(this.token.type !== 'operatorPostfix' || this.token.value !== '?') {
					return;
				}

				node.range.end = this.position++;

				return node;
			},
			nillableType: (node_) => {
				let node = {
					type: 'nillableType',
					range: {
						start: node_.range.start
					},
					value: node_
				}

				if(this.token.type !== 'operatorPostfix' || this.token.value !== '?') {
					return;
				}

				node.range.end = this.position++;

				return node;
			},
			nilLiteral: () => {
				let node = {
					type: 'nilLiteral',
					range: {}
				}

				if(this.token.type !== 'keywordNil') {
					return;
				}

				node.range.start =
				node.range.end = this.position++;

				return node;
			},
			observerDeclaration: () => {
				let node = {
					type: 'observerDeclaration',
					range: {
						start: this.position
					},
					identifier: this.rules.identifier(),
					body: undefined
				}

				if(![
					'willGet',
					'get',
					'didGet',
					'willSet',
					'set',
					'didSet',
					'willDelete',
					'delete',
					'didDelete'
				].includes(node.identifier?.value)) {
					this.position = node.range.start;

					return;
				}

				node.body = this.rules.functionBody();

				if(node.body == null) {
					this.report(0, node.range.start, node.type, 'No body.');
				}

				node.range.end = this.position-1;

				return node;
			},
			operator: () => {
				let node = {
					type: 'operator',
					range: {},
					value: undefined
				}

				if(!this.token.type.startsWith('operator')) {
					return;
				}

				node.value = this.token.value;
				node.range.start =
				node.range.end = this.position++;

				return node;
			},
			operatorBody: () => {
				return this.rules.body('operator');
			},
			operatorDeclaration: () => {
				let node = {
					type: 'operatorDeclaration',
					range: {
						start: this.position
					},
					modifiers: this.rules.modifiers(),
					operator: undefined,
					body: undefined
				}

				if(this.token.type !== 'keywordOperator') {
					this.position = node.range.start;

					return;
				}

				this.position++;
				node.operator = this.rules.operator();
				node.body = this.rules.operatorBody();

				if(!node.modifiers?.values.some(v => ['infix', 'postfix', 'prefix'].includes(v))) {
					this.report(2, node.range.start, node.type, 'Should have specific modifier (infix, postfix, prefix).');
				}
				if(node.operator == null) {
					this.report(2, node.range.start, node.type, 'No operator.');
				}
				if(node.body == null) {
					this.report(0, node.range.start, node.type, 'No body.');
				} else {
					for(let entry of node.body.statements.filter(v => v.type === 'entry')) {
						if(entry.key.type !== 'identifier' || !['associativity', 'precedence'].includes(entry.key.value)) {
							this.report(1, entry.range.start, node.type, 'Should have only identifiers as keys (associativity, precedence).');
						} else {
							if(entry.key.value === 'associativity') {
								if(entry.value.type !== 'identifier') {
									this.report(2, entry.range.start, node.type, 'Associativity value should be identifier.');
								}
								if(!['left', 'right', 'none'].includes(entry.value.value)) {
									this.report(2, entry.range.start, node.type, 'Associativity accepts only one of following values: left, right, none.');
								}
							}
							if(entry.key.value === 'precedence' && entry.value.type !== 'integerLiteral') {
								this.report(2, entry.range.start, node.type, 'Precedence value should be integer.');
							}
						}
					}
				}

				node.range.end = this.position-1;

				return node;
			},
			operatorStatements: () => {
				return this.rules.statements(['entry']);
			},
			parameter: () => {
				let node = {
					type: 'parameter',
					range: {
						start: this.position
					},
					label: this.rules.identifier(),
					identifier: undefined,
					type_: undefined,
					value: undefined
				}

				if(node.label == null) {
					return;
				}

				node.identifier = this.rules.identifier();

				if(node.identifier == null) {
					node.identifier = node.label;
					node.label = undefined;
				}

				node.type_ = this.rules.typeClause();
				node.value = this.rules.initializerClause();
				node.range.end = this.position-1;

				return node;
			},
			parenthesizedExpression: () => {
				let node = {
					type: 'parenthesizedExpression',
					range: {},
					value: undefined
				}

				if(this.token.type !== 'parenthesisOpen') {
					return;
				}

				node.range.start = this.position++;
				node.value = this.ruleHelpers.skippableNode(
					'expressionsSequence',
					() => this.token.type === 'parenthesisOpen',
					() => this.token.type === 'parenthesisClosed'
				);

				if(this.token.type === 'parenthesisClosed') {
					node.range.end = this.position++;
				} else
				if(this.tokensEnd) {
					node.range.end = this.position-1;

					this.report(1, node.range.start, node.type, 'Node doesn\'t have the closing parenthesis and was decided to be autoclosed at the end of stream.');
				} else {
					this.position = node.range.start;

					return;
				}

				return node;
			},
			parenthesizedType: () => {
				let node = {
					type: 'parenthesizedType',
					range: {},
					value: undefined
				}

				if(this.token.type !== 'parenthesisOpen') {
					return;
				}

				node.range.start = this.position++;
				node.value = this.rules.type();

				if(this.token.type !== 'parenthesisClosed') {
					this.position = node.range.start;

					return;
				}

				node.range.end = this.position++;

				return node;
			},
			postfixExpression: () => {
				let node = {
					type: 'postfixExpression',
					range: {
						start: this.position
					},
					value: this.rules.primaryExpression(),
					operator: undefined
				}

				if(node.value == null) {
					return;
				}

				while(!this.tokensEnd) {
					let node_ =
						this.rules.callExpression(node.value) ??
						this.rules.chainExpression(node.value) ??
						this.rules.defaultExpression(node.value) ??
						this.rules.nillableExpression(node.value) ??
						this.rules.subscriptExpression(node.value);

					if(node_ == null) {
						break;
					}

					node.value = node_;
				}

				node.operator = this.rules.postfixOperator();

				if(node.operator == null) {
					return node.value;
				}

				node.range.end = node.operator.range.end;

				return node;
			},
			postfixOperator: () => {
				let node = {
					type: 'postfixOperator',
					range: {},
					value: undefined
				}

				let exceptions = [',', ':']  // Enclosing nodes can use trailing operators from the list

				if(this.token.type !== 'operatorPostfix' || exceptions.includes(this.token.value)) {
					return;
				}

				node.value = this.token.value;
				node.range.start =
				node.range.end = this.position++;

				return node;
			},
			postfixType: () => {
				let node = this.rules.primaryType();

				if(node == null) {
					return;
				}

				while(!this.tokensEnd) {
					let node_ =
						this.rules.defaultType(node) ??
						this.rules.nillableType(node);

					if(node_ == null) {
						break;
					}

					node = node_;
				}

				return node;
			},
			prefixExpression: () => {
				let node = {
					type: 'prefixExpression',
					range: {
						start: this.position
					},
					operator: this.rules.prefixOperator(),
					value: undefined
				}

				node.value = this.rules.postfixExpression();

				if(node.value == null) {
					this.position = node.range.start;

					return;
				}
				if(node.operator == null) {
					return node.value;
				}

				node.range.end = node.value.range.end;

				return node;
			},
			prefixOperator: () => {
				let node = {
					type: 'prefixOperator',
					range: {},
					value: undefined
				}

				let exceptions = ['&', '.']  // primaryExpressions can start with operators from the list

				if(this.token.type !== 'operatorPrefix' || exceptions.includes(this.token.value)) {
					return;
				}

				node.value = this.token.value;
				node.range.start =
				node.range.end = this.position++;

				return node;
			},
			primaryExpression: () => {
				let node =
					this.rules.classExpression() ??
					this.rules.closureExpression() ??
					this.rules.enumerationExpression() ??
					this.rules.functionExpression() ??
					this.rules.identifier() ??
					this.rules.implicitChainExpression() ??
					this.rules.inoutExpression() ??
					this.rules.literalExpression() ??
					this.rules.namespaceExpression() ??
					this.rules.parenthesizedExpression() ??
					this.rules.protocolExpression() ??
					this.rules.structureExpression();

				return node;
			},
			primaryType: () => {
				let node =
					this.rules.anyType() ??
					this.rules.arrayType() ??
					this.rules.compositeType() ??
					this.rules.dictionaryType() ??
					this.rules.functionType() ??
					this.rules.parenthesizedType() ??
					this.rules.primitiveType() ??
					this.rules.protocolType() ??
					this.rules.typeReference();

				return node;
			},
			primitiveType: () => {
				let node = {
					type: 'primitiveType',
					range: {},
					value: undefined
				}

				if(![
					'keywordAny',
					'keywordBool',
					'keywordFloat',
					'keywordInt',
					'keywordString'
				].includes(this.token.type)) {
					return;
				}

				node.value = this.token.value;
				node.range.start =
				node.range.end = this.position++;

				return node;
			},
			protocolBody: () => {
				return this.rules.body('protocol');
			},
			protocolDeclaration: (anonymous) => {
				let node = {
					type: 'protocol'+(!anonymous ? 'Declaration' : 'Expression'),
					range: {
						start: this.position
					},
					modifiers: this.rules.modifiers(),
					identifier: undefined,
					inheritance: undefined,
					body: undefined
				}

				if(this.token.type !== 'keywordProtocol') {
					this.position = node.range.start;

					return;
				}

				this.position++;
				node.identifier = this.rules.identifier();

				if(anonymous) {
					if(node.modifiers != null || node.identifier != null) {
						this.position = node.range.start;

						return;
					}

					delete node.modifiers;
					delete node.identifier;
				} else
				if(node.identifier == null) {
					this.report(2, node.range.start, node.type, 'No identifier.');
				}

				node.inheritance = this.rules.inheritanceClause();
				node.body = this.rules.protocolBody();

				if(node.modifiers?.values.some(v => !['private', 'protected', 'public', 'static', 'final'].includes(v))) {
					this.report(1, node.range.start, node.type, 'Wrong modifier(s).');
				}
				if(node.body == null) {
					this.report(0, node.range.start, node.type, 'No body.');
				}

				node.range.end = this.position-1;

				return node;
			},
			protocolExpression: () => {
				return this.rules.protocolDeclaration(true);
			},
			protocolStatements: () => {
				return this.rules.statements([
					'classDeclaration',
					'enumerationDeclaration',
					'functionDeclaration',
					'namespaceDeclaration',
					'protocolDeclaration',
					'structureDeclaration',
					'variableDeclaration'
				]);
			},
			protocolType: () => {
				return this.rules.protocolBody();
			},
			returnStatement: () => {
				let node = {
					type: 'returnStatement',
					range: {},
					value: undefined
				}

				if(this.token.type !== 'keywordReturn') {
					return;
				}

				node.range.start = this.position++;
				node.value = this.rules.expressionsSequence();
				node.range.end = this.position-1;

				return node;
			},
			statements: (types) => {
				return this.ruleHelpers.skippableNodes(
					types,
					() => this.token.type === 'braceOpen',
					() => this.token.type === 'braceClosed',
					() => this.token.type === 'delimiter',
					true
				);
			},
			stringExpression: () => {
				let node = {
					type: 'stringExpression',
					range: {},
					value: undefined
				}

				if(this.token.type !== 'stringExpressionOpen') {
					return;
				}

				node.range.start = this.position++;
				node.value = this.ruleHelpers.skippableNode(
					'expressionsSequence',
					() => this.token.type === 'stringExpressionOpen',
					() => this.token.type === 'stringExpressionClosed'
				);

				if(this.token.type === 'stringExpressionClosed') {
					node.range.end = this.position++;
				} else
				if(this.tokensEnd) {
					node.range.end = this.position-1;

					this.report(1, node.range.start, node.type, 'Node doesn\'t have the closing parenthesis and was decided to be autoclosed at the end of stream.');
				} else {
					this.position = node.range.start;

					return;
				}

				return node;
			},
			stringLiteral: () => {
				let node = {
					type: 'stringLiteral',
					range: {},
					segments: []
				}

				if(this.token.type !== 'stringOpen') {
					return;
				}

				node.range.start = this.position++;
				node.segments = this.ruleHelpers.skippableNodes(
					['stringSegment', 'stringExpression'],
					() => this.token.type === 'stringOpen',
					() => this.token.type === 'stringClosed'
				);

				if(this.token.type === 'stringClosed') {
					node.range.end = this.position++;
				} else {
					node.range.end = this.position-1;

					this.report(1, node.range.start, node.type, 'Node doesn\'t have the closing apostrophe and decided to be autoclosed at the end of stream.');
				}

				return node;
			},
			stringSegment: () => {
				let node = {
					type: 'stringSegment',
					range: {},
					value: undefined
				}

				if(this.token.type !== 'stringSegment') {
					return;
				}

				node.value = this.token.value;
				node.range.start =
				node.range.end = this.position++;

				return node;
			},
			structureBody: () => {
				return this.rules.body('structure');
			},
			structureDeclaration: (anonymous) => {
				let node = {
					type: 'structure'+(!anonymous ? 'Declaration' : 'Expression'),
					range: {
						start: this.position
					},
					modifiers: this.rules.modifiers(),
					identifier: undefined,
					genericParameters: undefined,
					inheritance: undefined,
					body: undefined
				}

				if(this.token.type !== 'keywordStruct') {
					this.position = node.range.start;

					return;
				}

				this.position++;
				node.identifier = this.rules.identifier();

				if(anonymous) {
					if(node.modifiers != null || node.identifier != null) {
						this.position = node.range.start;

						return;
					}

					delete node.modifiers;
					delete node.identifier;
				} else
				if(node.identifier == null) {
					this.report(2, node.range.start, node.type, 'No identifier.');
				}

				node.genericParameters = this.rules.genericParametersClause();
				node.inheritance = this.rules.inheritanceClause();
				node.body = this.rules.structureBody();

				if(node.modifiers?.values.some(v => !['private', 'protected', 'public', 'static', 'final'].includes(v))) {
					this.report(1, node.range.start, node.type, 'Wrong modifier(s).');
				}
				if(node.body == null) {
					this.report(0, node.range.start, node.type, 'No body.');
				}

				node.range.end = this.position-1;

				return node;
			},
			structureExpression: () => {
				return this.rules.structureDeclaration(true);
			},
			structureStatements: () => {
				return this.rules.statements([
					'chainDeclaration',
					'classDeclaration',
					'deinitializerDeclaration',
					'enumerationDeclaration',
					'functionDeclaration',
					'initializerDeclaration',
					'namespaceDeclaration',
					'protocolDeclaration',
					'structureDeclaration',
					'subscriptDeclaration',
					'variableDeclaration'
				]);
			},
			subscriptBody: (strict) => {
				let node = this.rules.body('subscript');

				if(node != null && strict && !node?.statements.some(v => v.type !== 'unsupported')) {
					this.position = node.range.start;

					return;
				}

				return node;
			},
			subscriptDeclaration: () => {
				let node = {
					type: 'subscriptDeclaration',
					range: {
						start: this.position
					},
					modifiers: this.rules.modifiers(),
					signature: undefined,
					body: undefined
				}

				if(this.token.type !== 'identifier' || this.token.value !== 'subscript') {
					this.position = node.range.start;

					return;
				}

				node.range.start = this.position++;
				node.signature = this.rules.functionSignature();
				node.body = this.rules.subscriptBody(true) ?? this.rules.functionBody();

				if(node.modifiers?.values.some(v => !['private', 'protected', 'public', 'static'].includes(v))) {
					this.report(1, node.range.start, node.type, 'Wrong modifier(s).');
				}
				if(node.signature == null) {
					this.report(2, node.range.start, node.type, 'No signature.');
				}
				if(node.body == null) {
					this.report(0, node.range.start, node.type, 'No body.');
				}

				node.range.end = this.position-1;

				return node;
			},
			subscriptExpression: (node_) => {
				let node = {
					type: 'subscriptExpression',
					range: {
						start: node_.range.start
					},
					composite: node_,
					arguments: undefined
				}

				if(this.token.type !== 'bracketOpen') {
					return;
				}

				this.position++;
				node.arguments = this.ruleHelpers.skippableNodes(
					['argument'],
					() => this.token.type === 'bracketOpen',
					() => this.token.type === 'bracketClosed',
					() => this.token.type.startsWith('operator') && this.token.value === ','
				);

				if(this.token.type === 'bracketClosed') {
					node.range.end = this.position++;
				} else {
					node.range.end = this.position-1;

					this.report(1, node.range.start, node.type, 'Node doesn\'t have the closing bracket and decided to be autoclosed at the end of stream.');
				}

				return node;
			},
			subscriptStatements: () => {
				return this.rules.statements(['observerDeclaration']);
			},
			throwStatement: () => {
				let node = {
					type: 'throwStatement',
					range: {},
					value: undefined
				}

				if(this.token.type !== 'keywordThrow') {
					return;
				}

				node.range.start = this.position++;
				node.value = this.rules.expressionsSequence();
				node.range.end = this.position-1;

				return node;
			},
			tryExpression: () => {
				let node = {
					type: 'tryExpression',
					range: {},
					nillable: false,
					value: undefined
				}

				if(this.token.type !== 'keywordTry') {
					return;
				}

				node.range.start = this.position++;

				if(this.token.type === 'operatorPostfix' && this.token.value === '?') {
					this.position++;
					node.nillable = true;
				}

				node.value = this.rules.expression();

				if(node.value == null) {
					this.position = node.range.start;

					return;
				}

				node.range.end = this.position-1;

				return node;
			},
			type: () => {
				return this.rules.unionType();
			},
			typeClause: () => {
				let node,
					start = this.position;

				if(!this.token.type.startsWith('operator') || this.token.value !== ':') {
					return;
				}

				this.position++;
				node = this.rules.type();

				if(node == null) {
					this.report(0, start, 'typeClause', 'No value.');
				}

				return node;
			},
			typeReference: () => {
				let node = {
					type: 'typeReference',
					range: {
						start: this.position
					},
					identifier:
						this.rules.identifier() ??
						this.rules.implicitChainIdentifier(),
					genericArguments: []
				}

				if(node.identifier == null) {
					return;
				}

				while(!this.tokensEnd) {
					let node_ = this.rules.chainIdentifier(node.identifier);

					if(node_ == null) {
						break;
					}

					node.identifier = node_;
				}

				node.range.end = this.position-1;

				if(!this.token.type.startsWith('operator') || this.token.value !== '<') {
					return node;
				}

				this.position++;
				node.genericArguments = this.ruleHelpers.sequentialNodes(
					['type'],
					() => this.token.type.startsWith('operator') && this.token.value === ','
				);

				if(!this.token.type.startsWith('operator') || this.token.value !== '>') {
					this.position = node.range.end+1;
					node.genericArguments = []
				} else {
					node.range.end = this.position++;
				}

				return node;
			},
			unionType: () => {
				let node = {
					type: 'unionType',
					range: {
						start: this.position
					},
					subtypes: this.ruleHelpers.sequentialNodes(
						['intersectionType'],
						() => this.token.type.startsWith('operator') && this.token.value === '|'
					)
				}

				if(node.subtypes.length === 0) {
					return;
				}
				if(node.subtypes.length === 1) {
					return node.subtypes[0]
				}

				node.range.end = this.position-1;

				return node;
			},
			variableDeclaration: () => {
				let node = {
					type: 'variableDeclaration',
					range: {
						start: this.position
					},
					modifiers: this.rules.modifiers(),
					declarators: []
				}

				if(this.token.type !== 'keywordVar') {
					this.position = node.range.start;

					return;
				}

				this.position++;
				node.declarators = this.ruleHelpers.sequentialNodes(
					['declarator'],
					() => this.token.type.startsWith('operator') && this.token.value === ','
				);

				if(node.modifiers?.values.some(v => !['private', 'protected', 'public', 'static', 'lazy', 'final'].includes(v))) {
					this.report(1, node.range.start, node.type, 'Wrong modifier(s).');
				}
				if(node.declarators.length === 0) {
					this.report(0, node.range.start, node.type, 'No declarator(s).');
				}

				node.range.end = this.position-1;

				return node;
			},
			whileStatement: () => {
				let node = {
					type: 'whileStatement',
					range: {},
					condition: undefined,
					body: undefined
				}

				if(this.token.type !== 'keywordWhile') {
					return;
				}

				node.range.start = this.position++;
				node.condition = this.rules.expressionsSequence();
				node.body = this.rules.functionBody();

				if(node.body == null && node.condition != null) {
					let sequence = node.condition.type === 'expressionsSequence',
						node_ = sequence ? node.condition.values.at(-1) : node.condition;

					if(node_.type === 'callExpression' && node_.closure != null && node_.closure.signature == null) {
						this.position = node_.closure.range.start;

						if(sequence) {
							node.condition.values.pop();
							node.condition.values.push(node_.callee);
						} else {
							node.condition = node_.callee;
						}

						node.body = this.rules.functionBody();
					}
				}

				if(node.condition == null) {
					this.report(2, node.range.start, node.type, 'No condition.');
				}
				if(node.body == null) {
					this.report(0, node.range.start, node.type, 'No body.');
				}

				node.range.end = this.position-1;

				return node;
			}
		}

		static ruleHelpers = {
			/*
			 * Returns a list of nodes of the types in sequential order like [1, 2, 3, 1...].
			 *
			 * Additionally a separator between the nodes can be set.
			 * Also types can be marked subsequential and therefore have no impact on offset in iterations.
			 *
			 * Stops when an unsupported type occurs.
			 *
			 * Useful for precise sequences lookup.
			 */
			sequentialNodes: (types, separating, subsequentialTypes) => {
				let nodes = [],
					offset = 0;

				while(!this.tokensEnd) {
					let type = types[offset%types.length],
						node = this.rules[type]?.();

					if(node == null) {
						break;
					}

					nodes.push(node);

					if(!subsequentialTypes?.includes(node.type)) {
						offset++;
					}

					if(separating != null && offset > 0) {
						if(separating()) {
							this.position++;
						} else {
							break;
						}
					}
				}

				return nodes;
			},
			/*
			 * Returns a node of the type or the "unsupported" node if not closed immediately.
			 *
			 * Stops if node found, at 0 (relatively to 1 at start) scope level or at the .tokensEnd.
			 *
			 * Warns about "unsupported" nodes.
			 *
			 * Useful for imprecise single enclosed(ing) nodes lookup.
			 */
			skippableNode: (type, opening, closing) => {
				let node,
					start = this.position,
					scopeLevel = 1;

				node = this.rules[type]?.();

				if(node != null || closing() || this.tokensEnd) {
					return node;
				}

				node = {
					type: 'unsupported',
					range: {
						start: this.position,
						end: this.position
					},
					tokens: []
				}

				while(!this.tokensEnd) {
					scopeLevel += opening();
					scopeLevel -= closing();

					if(scopeLevel === 0) {
						break;
					}

					node.tokens.push(this.token);
					node.range.end = this.position++;
				}

				let range = node.range.start !== node.range.end,
					message = range ? 'range of tokens ['+node.range.start+':'+node.range.end+']' : 'token ['+node.range.start+']';

				this.report(1, node.range.start, node.type, 'At '+message+'.');

				return node;
			},
			/*
			 * Returns a list of nodes of the types, including the "unsupported" nodes if any occur.
			 *
			 * Additionally a (optionally nillable) separator between the nodes can be set.
			 *
			 * Stops at 0 (relatively to 1 at start) scope level or at the .tokensEnd.
			 *
			 * Warns about invalid separators and "unsupported" nodes.
			 *
			 * Useful for imprecise multiple enclosed(ing) nodes lookup.
			 */
			skippableNodes: (types, opening, closing, separating, nillableSeparating) => {
				let nodes = [],
					scopeLevel = 1;

				while(!this.tokensEnd) {
					let node;

					if(separating == null || nodes.length === 0 || nodes.at(-1).type === 'separator' || nillableSeparating) {
						for(let type of types) {
							node = this.rules[type]?.();

							if(node != null) {
								nodes.push(node);

								break;
							}
						}
					}

					if(closing() && scopeLevel === 1 || this.tokensEnd) {
						break;
					}

					if(separating?.()) {
						node = nodes.at(-1);

						if(node?.type !== 'separator') {
							node = {
								type: 'separator',
								range: {
									start: this.position,
									end: this.position
								}
							}

							nodes.push(node);
						} else {
							node.range.end = this.position;
						}

						this.position++;
					}

					if(node != null) {
						continue;
					}

					node = nodes.at(-1);

					if(node?.type !== 'unsupported') {
						node = {
							type: 'unsupported',
							range: {
								start: this.position,
								end: this.position
							},
							tokens: []
						}
					}

					scopeLevel += opening();
					scopeLevel -= closing();

					if(scopeLevel === 0) {
						break;
					}

					node.tokens.push(this.token);
					node.range.end = this.position++;

					if(node !== nodes.at(-1)) {
						nodes.push(node);
					}
				}

				for(let key in nodes) {
					let node = nodes[key],
						range = node.range.start !== node.range.end;

					if(node.type === 'separator') {
						if(key == 0) {
							this.report(0, node.range.start, node.type, 'Met before any supported type at token ['+node.range.start+'].');
						}
						if(range) {
							this.report(0, node.range.start, node.type, 'Sequence at range of tokens ['+node.range.start+':'+node.range.end+'].');
						}
						if(key == nodes.length-1) {
							this.report(0, node.range.start, node.type, 'Excess at token ['+node.range.start+'].');
						}
					}
					if(node.type === 'unsupported') {
						let message = range ? 'range of tokens ['+node.range.start+':'+node.range.end+']' : 'token ['+node.range.start+']';

						this.report(1, node.range.start, node.type, 'At '+message+'.');
					}
				}

				nodes = nodes.filter(v => v.type !== 'separator');

				return nodes;
			}
		}

		static get position() {
			return this.#position;
		}

		static set position(value) {
			if(value < this.#position) {  // Rollback global changes
				this.reports = this.reports.filter(v => v.position < value);
			}

			this.#position = value;
		}

		static get token() {
			return this.tokens[this.position] ?? {
				position: undefined,
				location: undefined,
				type: '',
				value: ''
			}
		}

		static get tokensEnd() {
			return this.position === this.tokens.length;
		}

		static report(level, position, type, string) {
			let location = this.tokens[position].location;

			if(this.reports.find(v =>
				v.location.line === location.line &&
				v.location.column === location.column &&
				v.string === string) != null
			) {
				return;
			}

			this.reports.push({
				level: level,
				position: position,
				location: location,
				string: type+' -> '+string
			});
		}

		static reset() {
			this.tokens = []
			this.#position = 0;
			this.reports = []
		}

		static parse(lexerResult) {
			this.reset();

			this.tokens = lexerResult.tokens;

			let result = {
				tree: this.rules.module(),
				reports: this.reports
			}

			this.reset();

			return result;
		}
	}

	class Interpreter {
		static tree;
		static hash = {}  // List of AST nodes of composite types (address: reference)

		static memory = [
			{
				address: 0,
				inheritance: ['Namespace'],
				imports: [
					/*
					{
						identifier: 'Foundation',
						value: 0
					}
					*/
				],
				operators: [
					{
						modifiers: ['postfix'],
						identifier: '++',
						associativity: null,
						precedence: null
					},
					{
						modifiers: ['postfix'],
						identifier: '--',
						associativity: null,
						precedence: null
					},
					{
						modifiers: ['prefix'],
						identifier: '++',
						associativity: null,
						precedence: null
					},
					{
						modifiers: ['prefix'],
						identifier: '--',
						associativity: null,
						precedence: null
					},
					{
						modifiers: [/* 'private', */ 'infix'],
						identifier: '+',
						associativity: 'left',
						precedence: 64
					}
				],
				members: [
					{
						modifiers: ['public', 'static'],
						identifier: 'TestClass',
						typed: true,
						inheritance: [1],
						nillable: true,
						value: '1',
						observers: []
					},
					{
						modifiers: ['public', 'static', 'final'],
						identifier: 'testPi',
						typed: true,
						inheritance: ['float'],
						nillable: true,
						value: '3.14',
						observers: []
					},
					{
						modifiers: ['public', 'static'],
						identifier: 'testClassInstance',
						typed: true,
						inheritance: [2],
						nillable: true,
						value: '3',
						observers: []
					},
					{
						modifiers: ['public'],
						identifier: 'computedInstanceProperty',
						typed: false,
						inheritance: [],
						nillable: true,
						value: null,
						observers: [
							{
								identifier: 'willGet',  // 'get', 'didGet', 'willSet', 'set', 'didSet', 'willDelete', 'delete', 'didDelete'
								value: null  // Function address
							}
						]
					}
				],
				observers: {
					chain: [
						{
							identifier: 'willGet',  // ...
							value: null  // Function address
						}
					],
					subscript: []
				},
				scope: null,
				retains: 1
			},
			{
				address: 1,
				inheritance: ['Class'],
				generics: [],
				members: [
					{
						modifiers: ['public', 'static', 'final'],
						identifier: 'init',
						typed: true,
						inheritance: [
							/*
							{
								type: 'Function',
								generics: [],  // [null] - Unspecified list, [] - Empty list
								parameters: [
									{
										typed: false,
										inheritance: [],
										nillable: true,
										variadic: true
									},
									{
										typed: false,
										inheritance: [],
										nillable: true,
										variadic: true
									}
								],
								awaits: 0,  // -1 - Unspecified, 0 - False, 1 - True
								throws: 0,
								return: {
									typed: true,
									inheritance: ['bool'],
									nillable: false
								}
							}
							*/
							'Function'
						],
						nillable: false,
						value: '2',
						observers: []
					},
					{
						modifiers: ['public'],
						identifier: 'testVariable',
						typed: true,
						inheritance: ['int'],
						nillable: true,
						value: null,
						observers: []
					}
				],
				observers: {
					chain: [],
					subscript: []
				},
				scope: 0,
				retains: 1
			},
			{
				address: 2,
				inheritance: ['Function'],
				generics: [
					/*
					{
						identifier: 'A',
						typed: false,
						inheritance: [],
						nillable: true
					},
					*/
				],
				parameters: [
					{
						label: null,
						identifier: 'firstArgument',
						inout: false,
						typed: true,
						inheritance: ['float'],
						nillable: false,
						variadic: false
					},
					{
						label: null,
						identifier: 'secondArgument',
						inout: false,
						typed: true,
						inheritance: ['bool'],
						nillable: true,
						variadic: false
					}
				],
				awaits: false,
				throws: false,
				return: {
					typed: true,
					inheritance: ['bool'],
					nillable: true
				},
				body: '\ttestVariable = 2 print(\'Test: \'+firstArgument)\n\n\treturn secondArgument',  // Body node from Parser's result
				members: [
					{
						identifier: 'parametersCount',
						inheritance: ['int'],
						value: '2'
					}
				],
				scope: 1,
				retains: 1
			},
			{
				address: 3,
				inheritance: ['Object', 1],
				members: [
					{
						identifier: 'testVariable',
						value: '2'
					}
				],
				scope: 0,
				retains: 1
			}
		]
		static contexts = []

		static rules = {
			module: (node) => {
				return this.rules.statements(node.statements);
			},
			compositeDeclaration: (node) => {
				let statements = this.rules.statements(node.body.statements);

				node.declarations = statements.declarations;

				return this.addHash(node);
			},
			namespaceDeclaration: (node) => {
				return this.rules.compositeDeclaration(node);
			},
			structureDeclaration: (node) => {
				return this.rules.compositeDeclaration(node);
			},
			protocolDeclaration: (node) => {
				return this.rules.compositeDeclaration(node);
			},
			enumerationDeclaration: (node) => {
				return this.rules.compositeDeclaration(node);
			},
			statements: (statements) => {
				let operators = [],
					declarations = []

				for(let statement of statements) {
					let type = statement.type;

					declarations.push(this.rules[type]?.(statement));
				}

				return {
					operators: operators,
					declarations: declarations
				}
			}
		}

		static addHash(node) {
			let address = Math.max.apply(undefined, Object.keys(this.hash));

			address = (address > -1 ? address : 0)+1;
			this.hash[address] = node;

			return address;
		}

		static interpret(node) {
			return this.rules[node.type]?.(node);
		}

		static createInheritance(primary, ...secondary) {
			if(![
				'argument',
				'class',
				'enumeration',
				'function',
				'instance',
				'namespace',
				'protocol',
				'structure',
				'variable'
			].includes(primary)) {
				throw new RangeError();
			}
			if(['argument', 'variable'].includes(primary)) {
				if(
					![
						'_',
						'Any',
						'any',
						'bool',
						'float',
						'int',
						'string'
					].includes(secondary[0]) ||
					secondary?.some(v => typeof v !== 'string' && !Number.isInteger(v))
				) {
					throw new TypeError();
				}
			}

			return [primary, ...secondary]
		}

		static createModifiers(...values) {
			for(value of values) {
				if(![
					'infix',
					'postfix',
					'prefix',
					'private',
					'protected',
					'public',
					'static'
				].includes(value)) {
					return;
				}
			}

			return values;
		}

		static createMember(inheritance, parameters) {
			let member;

			if(inheritance[0] === 'variable') {
				member = {
					/*
					modifiers: modifiers,
					identifier: identifier,
					typed: typed,
					inheritance: inheritance,
					nillable: nillable,
					value: value
					*/
				}
			}
			return member;
		}

		static getComposite(address) {
			let composite = this.memory.find(v => v.address === address);

			if(composite == null) {
				return;
			}

			return new Proxy(composite, {
				get: (t, k) => {
					if(k === 'metaSelf') {
						return t;
					}

					let members = t.members ?? [],
						member = members.find(v => v.identifier === k),
						identifier = member?.identifier,
						inheritance = member?.inheritance ?? [],
						value = member?.value;

					if(member == null) {
						return;
					}

					if(inheritance.length > 0 && inheritance.every(v => Number.isInteger(v))) {
						let address = value*1;

						return this.getComposite(address);
					} else {
						return member;
					}
				},
				ownKeys: (t) => {
					let members = t.members ?? [],
						keys = members.map(v => v.identifier);

					keys.push('metaSelf');

					return keys;
				},
				getOwnPropertyDescriptor: (t, k) => {
					if(k === 'metaSelf') {
						return {
							enumerable: true,
							configurable: true,
							value: t
						}
					}

					let members = t.members ?? [],
						member = members.find(v => v.identifier === k),
						inheritance = member?.inheritance ?? [],
						value = member?.value;

					if(member == null) {
						return;
					}

					if(inheritance.length > 0 && inheritance.every(v => Number.isInteger(v))) {
						let address = value*1;

						member = this.getComposite(address);
					}

					return {
						enumerable: true,
						configurable: true,
						value: member
					}
				}
			});
		}

		static createMainContext() {
		//  this.memory.push();

			if(this.contexts.length === 0) {
				this.contexts.push(this.getComposite(0));
			}
		}
	}

	let input = document.getElementById('input'),
		output_lint = document.getElementById('output_lint'),
		output_tokens = document.getElementById('output_tokens'),
		output_ast = document.getElementById('output_ast'),
		output_console = document.getElementById('output_console'),
		change_tree = document.getElementById('change_tree');

	function parse() {
		let lexerResult = Lexer.tokenize(input.value),
			parserResult = Parser.parse(lexerResult),
			interpreterResult = Interpreter.interpret(parserResult.tree);
			tokens = lexerResult.rawTokens,
			reports = [...lexerResult.reports, ...parserResult.reports]
					  .sort((a, b) => a.location.line-b.location.line || a.location.column-b.location.column);

		let lintHTML = '';

		for(let k = 0; k < tokens.length; k++) {
			let position = tokens[k].position,
				type = tokens[k].type,
				value = tokens[k].value,
				generated = tokens[k].generated,
				length = value.length,
				element;

			if(type === 'whitespace') {
				for(let i = 0; i < value.length; i++) {
					if(value[i] !== '\n') {
						element ??= document.createElement('span');
						element.innerText += value[i]

						if(value[i+1] === '\n' || i === value.length-1) {
							lintHTML += element.outerHTML;
							element = undefined;
						}
					}
					if(value[i] === '\n') {
						lintHTML += document.createElement('br').outerHTML;
					}
				}
			} else {
				element = document.createElement('span');
				element.innerText = value;

				if(type.startsWith('comment')) {
					element.style.color = 'rgb(95 179 63 / 1)';
				}
				if(type.startsWith('string') && !type.startsWith('stringExpression')) {
					element.style.color = 'rgb(191 127 95 / 1)';
				}
				if(type.startsWith('operator')) {
					element.style.color = 'rgb(255 191 0 / 1)';

					if(type.endsWith('Prefix')) {
						element.style.color = 'rgb(255 63 0 / 1)';
					}
					if(type.endsWith('Infix')) {
						element.style.color = 'rgb(255 95 0 / 1)';
					}
					if(type.endsWith('Postfix')) {
						element.style.color = 'rgb(255 127 0 / 1)';
					}
				}
				if(
					type.startsWith('parenthesis') ||
					type.startsWith('brace') ||
					type.startsWith('bracket') ||
					type === 'delimiter'
				) {
					element.style.color = 'rgb(255 255 255 / 1)';
				}
				if(type.startsWith('keyword')) {
					element.style.color = 'cornflowerblue';

					if([
						'nil',
						'true',
						'false'
					].includes(value)) {
						element.style.color = 'rgb(223 127 223 / 1)';
					}
				}
				if(type.startsWith('number')) {
					element.style.color = 'rgb(223 127 223 / 1)';
				}
				if(generated) {
					element.style.fontStyle = 'italic';
				}

				lintHTML += element.outerHTML;
			}
		}

		let consoleHTML = '';

		console.clear();
		for(let report of reports) {
			let level = report.level.toString()
									.replace('0', 'Info')
									.replace('1', 'Warning')
									.replace('2', 'Error'),
				line = report.location.line+1,
				column = report.location.column+1,
				string = report.string,
				message = line+':'+column+': '+level+': '+string;

			consoleHTML += message+'\n';
			console.log(message);
		}
		console.log(lexerResult.tokens);
		console.log(parserResult.tree);
		console.log(interpreterResult)

		output_lint.innerHTML = lintHTML;
		output_tokens.innerText = JSON.stringify(lexerResult.tokens, null, 4);
		output_ast.innerText = JSON.stringify(parserResult.tree, null, 4);
		output_console.innerText = consoleHTML;
	}

	input.oninput = parse;
	input.onscroll = () => {
		output_lint.scrollTop = input.scrollTop;
		output_lint.scrollLeft = input.scrollLeft;
	}
	input.value = input.value.trim();

	change_tree.onclick = () => {
		if(output_tokens.style.display !== 'none') {
			output_tokens.style.display = 'none';
			output_ast.style.display = 'block';
		} else {
			output_tokens.style.display = 'block';
			output_ast.style.display = 'none';
		}
	}

	parse();
</script>
</body>
</html>
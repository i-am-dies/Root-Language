<html>
<body>
<style>
body {
	display: flex;
}

#input,
#output_lint {
	width: 768px;
	height: 512px;
	overflow: auto;

	border: none;
	border-radius: 2px;
	background: rgb(63 63 63 / 1);
	box-shadow: 0 2px 4px gray;

	color: rgb(191 191 191 / 1);
	font: 12px monospace;
	tab-size: 4;
	white-space: pre;
}
</style>
<textarea id="input">
'one\('two\(three)four')five'
'\()'
0.1.0.1
'one\(two)three\(four)five\(six)seven'

'abc\(2+2+(4*(7/9)+1)+6+1)def';

long.identifiers?.chain_.with_().call.to[].subscript_
.implicit.chaining

// Foundation Source

struct Boolean {
	private const value

	init(value: bool) {
		self.value = value
	}

	static func ==(lhs: bool & Boolean, rhs: bool & Boolean) -> Boolean {
		var leftValue = lhs !is Boolean ? lhs : lhs.value,
			rightValue = rhs !is Boolean ? rhs : rhs.value

		return leftValue == rightValue
	}
}

struct Number {
	static const Pi = 3.141592653589793

	protected const value

	init(value: int & float) {
		self.value = value
	}

	static func ==(lhs: int & float & Number, rhs: int & float & Number) -> Boolean {
		var leftValue = lhs !is Number ? lhs : lhs.value,
			rightValue = rhs !is Number ? rhs : rhs.value

		return leftValue == rightValue
	}
}

struct Float: Number {
	init(value: int & float) {
		if var v = value%2 && (v == 0 || v == 1) {
			throw 'Value can\'t be integer'
		}

		self.value = value
	}
}

struct Integer: Number {
	init(value: int & float) {
		if var v = value%2 && v > 0 && v < 1 {
			throw 'Value can\'t be float'
		}

		self.value = value
	}
}

struct String {
	private const value

	init(value: string) {
		self.value = value
	}

	static func ==(lhs: string & String, rhs: string & String) -> Boolean {
		var leftValue = lhs !is String ? lhs : lhs.value,
			rightValue = rhs !is String ? rhs : rhs.value

		return leftValue == rightValue
	}
}

class Array {}

class Dictionary {}

// ---- ---- ---- ----

/* Multiblock
	/* Comment */
		Block */

// Comment Line

import Foundation

const Boolean = Foundation.Boolean,
	  Number = Foundation.Number,
	  Decimal = Foundation.Decimal,
	  Integer = Foundation.Integer,
	  String = Foundation.String,
	  Array = Foundation.Array,
	  Dictionary = Foundation.Dictionary

const constant = Number.Pi

var variable

if constant > 0 {
	variable = 1
}

class A {
	private const constant: Number = 0.5

	protected var variable: Integer = 1

	var variable_01a = 'String'

	private var anotherVariableStorage

	var anotherVariable {
		get {
			return anotherVariableStorage
		}
		set {
			anotherVariableStorage = newValue
		}

		willGet {}
		didGet {}
		willSet {}
		didSet {}
	}

	chain {
		get {
			return metaSelf.properties[key]?.value
		}
		set {
			metaSelf.properties[key] = value
		}
	}

	subscript(a: Integer, b: Integer) -> Integer {
		get {
			return a+b
		}
		set {
			print(a, b)
		}
	}

	init(with number: Integer = 0, and string: String) {
		print('Intitializing with \(number) and \(string)')

		variable = number
		variable_01a = string
	}

	deinit {
		print('Deinitializing!')
	}
}

var instance = A(with: 12, and: '2')

/*
var self.A: self.Class = class { ... }

var self.instance = A(with: 12, and: '2')
*/

print('Testing nested template string: printing some \(identifier+'abc\(1+2+3)def'+0.125) and \(instance.variable)')

var instance_2 = struct {
	init(test: Integer) {
		print('Initialized anonymous struct with testing variable: '+test)
	}
}(12)

instance =
instance_2 = nil

enum B {
	case first
	case second
	case third
	case fourth
}

var enum_value: B = .first

var function

/*
function = { x in x > 0 } - 1

function = (x) in x > 0
function = (x) { x > 0 }
function = (x) { return x > 0 } - 2

function = func (x) in x > 0
function = func (x) { x > 0 }
function = func (x) { return x > 0 } - 3
*/
</textarea>
<div id="output_lint"></div>
<script>
	let code = document.getElementById('input').value;

	class Lexer {
		static code;
		static position;
		static location;
		static tokens;
		static levels;
		static reports;

		static rules = [
			[['/*', '*/'], (v) => {
				if(this.atCommentLevel || this.atStringLevel) {
					this.ruleHelpers.continueString();
					this.token.value += v;
				} else
				if(v === '/*') {
					this.addToken('commentBlock', v);
				}
				if(this.token.type === 'commentBlock') {
					if(v === '/*') {
						this.levels.comment++;
					} else {
						this.levels.comment--;
					}
				}
			}],
			['//', (v) => {
				if(this.atCommentLevel || this.atStringLevel) {
					this.ruleHelpers.continueString();
					this.token.value += v;
				} else {
					this.addToken('commentLine', v);
					this.levels.comment++;
				}
			}],
			[['\\\\', '\\\'', '\\(', '\\b', '\\f', '\\n', '\\r', '\\t', '\\v', '\\'], (v) => {
				if(this.atCommentLevel) {
					this.token.value += v;

					return;
				}
				if(!this.atStringLevel) {
					return;
				}
				if(v === '\\(') {
					return true;
				}

				this.ruleHelpers.continueString();
				this.token.value += ({
					'\\\\': '\\',
					'\\\'': '\'',
					'\\b': '\b',
					'\\f': '\f',
					'\\n': '\n',
					'\\r': '\r',
					'\\t': '\t',
					'\\v': '\v',
					'\\': ''
				})[v]
			}],
			[['\\(', ')'], (v) => {
				if(this.atCommentLevel) {
					this.token.value += v;

					return;
				}

				switch(v) {
					case '\\(':
						if(this.atStringLevel) {
							this.addToken('stringExpressionOpen', v);
							this.levels.stringExpression++;
						}
					break;
					case ')':
						if(this.atStringExpressionLevel && this.levels.stringExpressionParenthesis === 0) {
							this.addToken('stringExpressionClosed');
							this.levels.stringExpression--;
						} else {
							return true;
						}
					break;
				}
			}],
			[['!', '%', '&', '*', '+', ',', '-', '.', '/', ':', '<', '=', '>', '?', '^', '|', '~'], (v) => {
				let initializers = [',', '.', ':']  // Create new token if value exists in list and current token doesn't initialized with it

				if(this.atCommentLevel || this.atStringLevel || this.token.type.startsWith('operator') && (!initializers.includes(v) || this.token.value.startsWith(v))) {
					this.ruleHelpers.continueString();
					this.token.value += v;

					return;
				}

				let type = 'operator';

				if(
					['string', 'identifier'].includes(this.token.type) ||
					this.token.type.endsWith('Closed') ||
					this.token.type.startsWith('number') ||
					this.token.type.startsWith('keyword')
				) {
					type += 'Postfix';
				}

				this.addToken(type);
			}],
			[['(', ')', '{', '}', '[', ']'], (v) => {
				if(this.atCommentLevel || this.atStringLevel) {
					this.ruleHelpers.continueString();
					this.token.value += v;

					return;
				}

				let type = ({
					'(': 'parenthesisOpen',
					')': 'parenthesisClosed',
					'{': 'braceOpen',
					'}': 'braceClosed',
					'[': 'bracketOpen',
					']': 'bracketClosed'
				})[v]

				if(this.atStringExpressionLevel) {
					if(v === '(') {
						this.levels.stringExpressionParenthesis++;
					}
					if(v === ')') {
						this.levels.stringExpressionParenthesis--;
					}
				}
				if(type.endsWith('Open')) {
					this.ruleHelpers.specifyOperatorType();
				}

				this.addToken(type);
			}],
			['\'', (v) => {
				if(this.atCommentLevel) {
					this.token.value += v;

					return;
				}

				if(!this.atStringLevel) {
					this.ruleHelpers.specifyOperatorType();
					this.addToken('stringOpen');
					this.levels.string++;
				} else {
					this.addToken('stringClosed');
					this.levels.string--;
				}
			}],
			[/\s|;/, (v) => {
				if(this.atCommentLevel || this.atStringLevel) {
					if(v === '\n' && this.token.type === 'commentLine') {
						this.addToken('delimiter');
						this.levels.comment--;
					} else {
						this.ruleHelpers.continueString();
						this.token.value += v;
					}

					return;
				}

				if(this.token.type !== 'delimiter') {
					this.addToken('delimiter');
				} else {
					this.token.value += v;
				}
			}],
			[/[0-9]/, (v) => {
				if(this.atCommentLevel || this.atStringLevel || this.token.type.startsWith('number') || this.token.type === 'identifier') {
					this.ruleHelpers.continueString();
					this.token.value += v;

					return;
				}
				if(this.token.type === 'operatorPostfix' && this.token.value === '.' && this.getToken(-1).type === 'numberInteger') {
					this.removeToken();
					this.token.type = 'numberFloat';
					this.token.value += '.'+v;

					return;
				}

				this.ruleHelpers.specifyOperatorType();
				this.addToken('numberInteger');
			}],
			[/[a-z_]/i, (v) => {
				if(this.atCommentLevel || this.atStringLevel) {
					this.ruleHelpers.continueString();
					this.token.value += v;

					return;
				}

				if(this.token.type !== 'identifier' && !this.token.type.startsWith('keyword')) {
					this.ruleHelpers.specifyOperatorType();
					this.addToken('identifier', '');
				}
				this.token.value += v;

				let keywords = [
					'Any',
					'Class',
					'Enumeration',
					'Function',
					'Namespace',
					'Object',
					'Protocol',
					'Self', 'Structure',
					'any', /*'arguments',*/
					'bool', 'break',
					'case', 'catch', 'class', 'const', 'continue',
					'default',
					'else', 'enum', 'extension',
					'false', 'float', 'for', 'func',
					'if', 'import', 'in', 'int', 'is',
					'metaSelf',
					'namespace', 'nil',
					'private', 'protected', 'protocol', 'public',
					'return',
					'self', 'static', 'string', 'struct', 'super', 'switch',
					'throw', 'true', 'try',
					'var',
					'while'
				]

				if(keywords.includes(this.token.value)) {
					this.token.type = 'keyword'+this.token.value[0].toUpperCase()+this.token.value.slice(1);
				} else {
					this.token.type = 'identifier';
				}
			}],
			[/.|\n/i, (v) => {
				if(this.token.type === 'commentBlock' || this.token.type === 'commentLine' && v !== '\n' || this.atStringLevel) {
					this.ruleHelpers.continueString();
					this.token.value += v;

					return;
				}

				this.report(0, 'No token of an appropriate type was created before to accept this character and it doesn\'t represent any possible type independently: "'+v+'", skipping...');
			}]
		]

		static ruleHelpers = {
			continueString: () => {
				if(['stringOpen', 'stringExpressionClosed'].includes(this.token.type)) {
					this.addToken('stringSegment', '');
				}
			},
			specifyOperatorType: () => {
				switch(this.token.type) {
					case 'operator':		this.token.type = 'operatorPrefix';	break;
					case 'operatorPostfix':	this.token.type = 'operatorInfix';	break;
				}
			}
		}

		static get token() {
			return this.getToken();
		}

		static get atCommentLevel() {
			return this.levels.comment > 0;
		}

		static get atStringLevel() {
			return this.levels.string > this.levels.stringExpression;
		}

		static get atStringExpressionLevel() {
			return this.levels.string > 0 && this.levels.string === this.levels.stringExpression;
		}

		static getToken(offset = 0) {
			return this.tokens[this.tokens.length-1+offset] ?? {
				position: undefined,
				location: undefined,
				type: '',
				value: ''
			}
		}

		static addToken(type, value) {
			this.tokens.push({
				position: this.position,
				location: {...this.location},
				type: type,
				value: value ?? this.code[this.position]
			});
		}

		static removeToken(offset = 0) {
			this.tokens = this.tokens.filter((v, k) => k !== this.tokens.length-1+offset);
		}

		static report(level, string) {
			this.reports.push({
				level: level,
				location: {...this.location},
				string: string
			});
		}

		static reset() {
			this.code = undefined;
			this.position = undefined;
			this.location = {
				line: 0,
				column: 0
			}
			this.tokens = []
			this.levels = {
				comment: 0,
				string: 0,
				stringExpression: 0,
				stringExpressionParenthesis: 0
			}
			this.reports = []
		}

		static atPosition(substring) {
			return this.code.indexOf(substring, this.position) === this.position;
		}

		static tokenize(code) {
			this.reset();

			this.code = code;

			for(this.position = 0; this.position < this.code.length; this.position++) {
				for(let rule of this.rules) {
					let triggers = rule[0],
						actions = rule[1],
						plain = typeof triggers === 'string',
						array = Array.isArray(triggers),
						regex = triggers instanceof RegExp,
						trigger;

					if(plain && this.atPosition(triggers)) {
						trigger = triggers;
					}
					if(array) {
						trigger = triggers.find(v => this.atPosition(v));
					}
					if(regex && triggers.test(this.code[this.position])) {
						trigger = this.code[this.position]
					}

					if(trigger != null && !actions(trigger)) {
						this.position += trigger.length-1;

						for(let character of trigger) {
							if(character === '\n') {
								this.location.line++;
								this.location.column = 0;
							} else {
								this.location.column++;
							}
						}

						break;
					}
				}
			}

			let result = {
				rawTokens: this.tokens,
				tokens: this.tokens.filter(v => !v.type.startsWith('comment') && v.type !== 'delimiter'),
				reports: this.reports
			}

			this.reset();

			return result;
		}
	}

	class Parser {
		static tokens;
		static position;
		static reports;
		static rules = {
			booleanLiteral: () => {
				let node = {
					type: 'booleanLiteral',
					range: {},
					value: undefined
				}

				if(!['keywordFalse', 'keywordTrue'].includes(this.token.type)) {
					return;
				}

				node.value = this.token.value === 'true';
				node.range.start =
				node.range.end = this.position++;

				return node;
			},
			callExpression: (node_) => {
				let node = {
					type: 'callExpression',
					range: {
						start: node_.range.start
					},
					callee: node_,
					arguments: undefined
				}

				if(this.token.type !== 'parenthesisOpen') {
					return;
				}

				this.position++;
			//  node.arguments = this.rules.functionArguments();

				if(this.token.type !== 'parenthesisClosed') {
					this.position = node_.range.end+1;

					return;
				}

				node.range.end = this.position++;

				return node;
			},
			caseDeclaration: () => {},
			chainExpression: (node_) => {
				let node = {
					type: 'chainExpression',
					range: {
						start: node_.range.start
					},
					composite: node_,
					member: undefined
				}

				if(!['operatorPrefix', 'operatorInfix'].includes(this.token.type) || this.token.value !== '.') {
					return;
				}

				this.position++;
				node.member =
					this.rules.identifier() /*??
					this.rules.stringLiteral()*/;

				if(node.member == null) {
					this.position = node_.range.end+1;

					return;
				}

				node.range.end = node.member.range.end;

				return node;
			},
			classBody: () => {
				return this.rules.compositeBody('class');
			},
			classDeclaration: (anonymous) => {
				let node = {
					type: 'class'+(!anonymous ? 'Declaration' : 'Expression'),
					range: {},
					id: undefined,
					inheritance: undefined,
					body: undefined
				}

				if(this.token.type !== 'keywordClass') {
					return;
				}

				node.range.start = this.position++;
				node.id = this.rules.identifier();
				node.inheritance = this.rules.typeInheritanceClause();
				node.body = this.rules.classBody();

				if(anonymous) {
					delete node.id;
				} else
				if(node.id == null) {
					this.report(2, node.range.start, 'No identifier set for class.');
				}
				if(node.body == null) {
					this.report(1, node.range.start, 'Class doesn\'t have body.');
				}

				node.range.end =
					node.body?.range.end ??
					node.inheritance?.range.end ??
					node.id?.range.end ??
					node.range.start;

				return node;
			},
			classExpression: () => {
				return this.rules.classDeclaration(true);
			},
			classMembers: () => {
				return this.rules.compositeMembers([
					'classDeclaration',
					'enumerationDeclaration',
					'functionDeclaration',
					'namespaceDeclaration',
					'protocolDeclaration',
					'structureDeclaration',
					'variableDeclaration'
				]);
			},
			compositeBody: (type) => {
				let node = {
					type: type+'Body',
					range: {},
					members: []
				}

				if(this.token.type !== 'braceOpen') {
					return;
				}

				node.range.start = this.position++;
				node.members = this.rules[type+'Members']?.();

				if(node.members.length === 0) {
					this.report(1, node.range.start, 'Body is empty.');
				}

				if(this.token.type !== 'braceClosed' && !this.tokensEnd) {
					this.position = node.range.start;

					return;
				}

				if(!this.tokensEnd) {
					node.range.end = this.position++;
				} else {
					node.range.end = this.position-1;

					this.report(1, node.range.start, 'Body doesn\'t have the closing brace and decided to be autoclosed at the end of stream.');
				}

				return node;
			},
			compositeMembers: (types) => {
				return this.rules.nestedNodes(types, 'braceOpen', 'braceClosed');
			},
			nestedNodes: (types, openingTokenType, closingTokenType) => {
				let nodes = []

				while(!this.tokensEnd) {
					let node;

					for(let type of types) {
						node = this.rules[type]?.();

						if(node != null) {
							nodes.push(node);

							break;
						}
					}
					if(node != null) {
						continue;
					}

					node = nodes.at(-1);

					if(node?.type !== 'unsupported') {
						node = {
							type: 'unsupported',
							range: {
								start: this.position,
								end: this.position
							},
							scopeLevel: 1
						}

						nodes.push(node);
					} else {
						node.range.end = this.position;
					}

					switch(this.token.type) {
						case openingTokenType: node.scopeLevel++; break;
						case closingTokenType: node.scopeLevel--; break;
					}

					if(node.scopeLevel === 0) {
						node.range.end--;

						if(node.range.start > node.range.end) {
							nodes.pop();
						}

						break;
					}

					this.position++;
				}

				for(let node of nodes.filter(v => v.type === 'unsupported')) {
					delete node.scopeLevel;

					this.report(1, node.range.start, 'Unsupported type at range of tokens ['+node.range.start+':'+node.range.end+'].');
				}

				return nodes;
			},
			declaration: () => {
				let node =
					this.rules.classDeclaration() ??
					this.rules.enumerationDeclaration() ??
					this.rules.functionDeclaration() ??
					this.rules.importDeclaration() ??
					this.rules.namespaceDeclaration() ??
					this.rules.protocolDeclaration() ??
					this.rules.structureDeclaration() ??
					this.rules.variableDeclaration();

				return node;
			},
			enumerationBody: () => {
				return this.rules.compositeBody('enumeration');
			},
			enumerationDeclaration: (anonymous) => {
				let node = {
					type: 'enumeration'+(!anonymous ? 'Declaration' : 'Expression'),
					range: {},
					id: undefined,
					inheritance: undefined,
					body: undefined
				}

				if(this.token.type !== 'keywordEnum') {
					return;
				}

				node.range.start = this.position++;
				node.id = this.rules.identifier();
				node.inheritance = this.rules.typeInheritanceClause();
				node.body = this.rules.enumerationBody();

				if(anonymous) {
					delete node.id;
				} else
				if(node.id == null) {
					this.report(2, node.range.start, 'No identifier set for enumeration.');
				}
				if(node.body == null) {
					this.report(1, node.range.start, 'Enumeration doesn\'t have body.');
				}

				node.range.end =
					node.body?.range.end ??
					node.inheritance?.range.end ??
					node.id?.range.end ??
					node.range.start;

				return node;
			},
			enumerationExpression: () => {
				return this.rules.enumerationDeclaration(true);
			},
			enumerationMembers: () => {
				return this.rules.compositeMembers(['caseDeclaration']);
			},
			floatLiteral: () => {
				let node = {
					type: 'floatLiteral',
					range: {},
					value: undefined
				}

				if(this.token.type !== 'numberFloat') {
					return;
				}

				node.value = this.token.value;
				node.range.start =
				node.range.end = this.position++;

				return node;
			},
			forStatement: () => {},
			functionBody: () => {
				return this.rules.compositeBody('function');
			},
			functionDeclaration: (anonymous) => {
				let node = {
					type: 'function'+(!anonymous ? 'Declaration' : 'Expression'),
					range: {},
					id: undefined,
					signature: undefined,
					body: undefined
				}

				if(this.token.type !== 'keywordFunc') {
					return;
				}

				node.range.start = this.position++;
				node.id = this.rules.identifier() ?? this.rules.operator();
				node.signature = this.rules.functionSignature();
				node.body = this.rules.functionBody();

				if(anonymous) {
					delete node.id;
				} else
				if(node.id == null) {
					this.report(2, node.range.start, 'No identifier set for function.');
				}
				if(node.signature == null) {
					this.report(2, node.range.start, 'Function lacks of signature.');
				}
				if(node.body == null) {
					this.report(1, node.range.start, 'Function doesn\'t have body.');
				}

				node.range.end =
					node.body?.range.end ??
					node.signature?.range.end ??
					node.id?.range.end ??
					node.range.start;

				return node;
			},
			functionExpression: () => {
				return this.rules.functionDeclaration(true);
			},
			functionMembers: () => {
				return this.rules.compositeMembers([
					'postfixExpression',  // Postfixes must be parsed before nodes that they can begin with
					'declaration',
					'forStatement',
					'ifStatement',
					'literalExpression',
					'variableAssignment',
					'whileStatement'
				]);
			},
			functionParameter: () => {},
			functionSignature: () => {
				let node = {
					type: 'functionSignature',
					range: {},
					parameters: undefined
				}

				if(this.token.type !== 'parenthesisOpen') {
					return;
				}

				node.range.start = this.position++;

				while(true) {
					let node_ = this.rules.functionParameter();

					if(node_ == null) {
						break;
					}

					node.parameters.push(node_);

					if(this.token.type !== 'operator' || this.token.value !== ',') {
						break;
					}

					this.position++;
				}

				if(this.token.type !== 'parenthesisClosed') {
					this.position = node.range.start;

					return;
				}

				node.range.end = this.position++;

				return node;
			},
			identifier: () => {
				let node = {
					type: 'identifier',
					range: {},
					value: undefined
				}

				if(this.token.type !== 'identifier') {
					return;
				}

				node.value = this.token.value;
				node.range.start =
				node.range.end = this.position++;

				return node;
			},
			ifStatement: () => {},
			implicitChainExpression: () => {
				let node = {
					type: 'implicitChainExpression',
					range: {},
					member: undefined
				}

				if(this.token.type !== 'operatorPrefix' || this.token.value !== '.') {
					return;
				}

				node.range.start = this.position++;
				node.member = this.rules.identifier();

				if(node.member == null) {
					this.position = node.range.start;

					return;
				}

				node.range.end = node.member.range.end;

				return node;
			},
			importDeclaration: () => {},
			initializerClause: () => {
				let node = {
					type: 'initializerClause',
					range: {},
					id: undefined
				}

				if(this.token.type !== 'operator' || this.token.value !== '=') {
					return;
				}

				node.value = this.token.value;
				node.range.start =
				node.range.end = this.position++;
				node.id = this.rules.identifier();

				if(node.id == null) {
					this.position = node.range.start;

					return;
				}

				node.range.end = node.id.range.end;

				return node;
			},
			integerLiteral: () => {
				let node = {
					type: 'integerLiteral',
					range: {},
					value: undefined
				}

				if(this.token.type !== 'numberInteger') {
					return;
				}

				node.value = this.token.value;
				node.range.start =
				node.range.end = this.position++;

				return node;
			},
			literalExpression: () => {
				let node =
				//  this.rules.arrayLiteral() ??
					this.rules.booleanLiteral() ??
				//  this.rules.dictionaryLiteral() ??
					this.rules.floatLiteral() ??
					this.rules.integerLiteral() ??
					this.rules.nilLiteral() ??
					this.rules.stringLiteral();

				return node;
			},
			logicalExpression: () => {},
			module: () => {
				let node = {
					type: 'module',
					range: {
						start: 0,
						end: 0
					},
					members: this.rules.functionMembers()
				}

				if(node.members.length > 0) {
					node.range.start = node.members[0].range.start;
					node.range.end = node.members.at(-1).range.end;
				}

				return node;
			},
			namespaceBody: () => {
				return this.rules.compositeBody('namespace');
			},
			namespaceDeclaration: (anonymous) => {
				let node = {
					type: 'namespace'+(!anonymous ? 'Declaration' : 'Expression'),
					range: {},
					id: undefined,
					body: undefined
				}

				if(this.token.type !== 'keywordNamespace') {
					return;
				}

				node.range.start = this.position++;
				node.id = this.rules.identifier();
				node.body = this.rules.namespaceBody();

				if(anonymous) {
					delete node.id;
				} else
				if(node.id == null) {
					this.report(2, node.range.start, 'No identifier set for namespace.');
				}
				if(node.body == null) {
					this.report(1, node.range.start, 'Namespace doesn\'t have body.');
				}

				node.range.end =
					node.body?.range.end ??
					node.id?.range.end ??
					node.range.start;

				return node;
			},
			namespaceExpression: () => {
				return this.rules.namespaceDeclaration(true);
			},
			namespaceMembers: () => {
				return this.rules.compositeMembers([
					'classDeclaration',
					'enumerationDeclaration',
					'functionDeclaration',
					'namespaceDeclaration',
					'protocolDeclaration',
					'structureDeclaration',
					'variableDeclaration'
				]);
			},
			nillableExpression: (node_) => {
				let node = {
					type: 'nillableExpression',
					range: {
						start: node_.range.start
					},
					value: node_
				}

				if(this.token.type !== 'operatorPostfix' || this.token.value !== '?') {
					return;
				}

				node.range.end = this.position++;

				return node;
			},
			nilLiteral: () => {
				let node = {
					type: 'nilLiteral',
					range: {}
				}

				if(this.token.type !== 'keywordNil') {
					return;
				}

				node.range.start =
				node.range.end = this.position++;

				return node;
			},
			operator: () => {
				let node = {
					type: 'operator',
					range: {},
					value: undefined
				}

				if(!this.token.type.startsWith('operator')) {
					return;
				}

				node.value = this.token.value;
				node.range.start =
				node.range.end = this.position++;

				return node;
			},
			postfixExpression: () => {
				let node =
					this.rules.classExpression() ??
					this.rules.enumerationExpression() ??
					this.rules.functionExpression() ??
					this.rules.identifier() ??
					this.rules.implicitChainExpression() ??
					this.rules.literalExpression() ??
					this.rules.namespaceExpression() ??
					this.rules.protocolExpression() ??
					this.rules.structureExpression();

				if(node == null) {
					return;
				}

				for(let i = 0; i < Infinity; i++) {
					let node_ =
						this.rules.callExpression(node) ??
						this.rules.chainExpression(node) ??
						this.rules.nillableExpression(node) ??
						this.rules.subscriptExpression(node);

					if(node_ == null) {
						if(i === 0) {
							this.position = node.range.start;

							return;
						}

						break;
					}

					node = node_;
				}

				return node;
			},
			protocolBody: () => {
				return this.rules.compositeBody('protocol');
			},
			protocolDeclaration: (anonymous) => {
				let node = {
					type: 'protocol'+(!anonymous ? 'Declaration' : 'Expression'),
					range: {},
					id: undefined,
					inheritance: undefined,
					body: undefined
				}

				if(this.token.type !== 'keywordProtocol') {
					return;
				}

				node.range.start = this.position++;
				node.id = this.rules.identifier();
				node.inheritance = this.rules.typeInheritanceClause();
				node.body = this.rules.protocolBody();

				if(anonymous) {
					delete node.id;
				} else
				if(node.id == null) {
					this.report(2, node.range.start, 'No identifier set for protocol.');
				}
				if(node.body == null) {
					this.report(1, node.range.start, 'Protocol doesn\'t have body.');
				}

				node.range.end =
					node.body?.range.end ??
					node.inheritance?.range.end ??
					node.id?.range.end ??
					node.range.start;

				return node;
			},
			protocolExpression: () => {
				return this.rules.protocolDeclaration(true);
			},
			protocolMembers: () => {
				return this.rules.compositeMembers([
					'classDeclaration',
					'enumerationDeclaration',
					'functionDeclaration',
					'namespaceDeclaration',
					'protocolDeclaration',
					'structureDeclaration',
					'variableDeclaration'
				]);
			},
			stringLiteral: () => {
				let node = {
					type: 'stringLiteral',
					range: {},
					segments: []
				}

				if(this.token.type !== 'stringOpen') {
					return;
				}

				node.range.start = this.position++;
				node.segments = this.rules.stringSegments();

				if(this.token.type !== 'stringClosed' && !this.tokensEnd) {
					this.position = node.range.start;

					return;
				}

				if(!this.tokensEnd) {
					node.range.end = this.position++;
				} else {
					node.range.end = this.position-1;

					this.report(1, node.range.start, 'String doesn\'t have the closing apostrophe and decided to be autoclosed at the end of stream.');
				}

				return node;
			},
			stringSegments: () => {
				return this.rules.nestedNodes([
					'stringSegment',
					'stringExpression'
				], 'stringOpen', 'stringClosed');
			},
			stringSegment: () => {
				if(this.token.type === 'stringSegment') {
					let value = this.token.value;

					this.position++;

					return value;
				}
			},
			stringExpression: () => {
				let node = {
					type: 'stringExpression',
					range: {},
					value: undefined
				}

				if(this.token.type !== 'stringExpressionOpen') {
					return;
				}

				node.range.start = this.position++;
				node.value = this.rules.nestedNodes([
					'postfixExpression',
					'identifier',
					'stringLiteral'
				], 'stringExpressionOpen', 'stringExpressionClosed');

				if(this.token.type !== 'stringExpressionClosed' && !this.tokensEnd) {
					this.position = node.range.start;

					return;
				}

				if(!this.tokensEnd) {
					node.range.end = this.position++;
				} else {
					node.range.end = this.position-1;

					this.report(1, node.range.start, 'String expression doesn\'t have the closing parenthesis and decided to be autoclosed at the end of stream.');
				}

				return node;
			},
			structureBody: () => {
				return this.rules.compositeBody('structure');
			},
			structureDeclaration: (anonymous) => {
				let node = {
					type: 'structure'+(!anonymous ? 'Declaration' : 'Expression'),
					range: {},
					id: undefined,
					inheritance: undefined,
					body: undefined
				}

				if(this.token.type !== 'keywordStruct') {
					return;
				}

				node.range.start = this.position++;
				node.id = this.rules.identifier();
				node.inheritance = this.rules.typeInheritanceClause();
				node.body = this.rules.structureBody();

				if(anonymous) {
					delete node.id;
				} else
				if(node.id == null) {
					this.report(2, node.range.start, 'No identifier set for structure.');
				}
				if(node.body == null) {
					this.report(1, node.range.start, 'Structure doesn\'t have body.');
				}

				node.range.end =
					node.body?.range.end ??
					node.inheritance?.range.end ??
					node.id?.range.end ??
					node.range.start;

				return node;
			},
			structureExpression: () => {
				return this.rules.structureDeclaration(true);
			},
			structureMembers: () => {
				return this.rules.compositeMembers([
					'classDeclaration',
					'enumerationDeclaration',
					'functionDeclaration',
					'namespaceDeclaration',
					'protocolDeclaration',
					'structureDeclaration',
					'variableDeclaration'
				]);
			},
			subscriptExpression: (node_) => {
				let node = {
					type: 'subscriptExpression',
					range: {
						start: node_.range.start
					},
					composite: node_,
					arguments: undefined
				}

				if(this.token.type !== 'bracketOpen') {
					return;
				}

				this.position++;
			//  node.arguments = this.rules.functionArguments();

				if(this.token.type !== 'bracketClosed') {
					this.position = node_.range.end+1;

					return;
				}

				node.range.end = this.position++;

				return node;
			},
			typeInheritanceClause: () => {
				let node = {
					type: 'typeInheritanceClause',
					range: {},
					identifiers: []
				}

				if(!this.token.type.startsWith('operator') || this.token.value !== ':') {
					return;
				}

				node.range.start = this.position++;

				while(true) {
					let node_ = this.rules.identifier();

					if(node_ == null) {
						break;
					}

					node.identifiers.push(node_);

					if(this.token.type !== 'operator' || this.token.value !== ',') {
						break;
					}

					this.position++;
				}

				if(node.identifiers.length === 0) {
					this.position = node.range.start;

					return;
				}

				node.range.end = node.identifiers.at(-1).range.end;

				return node;
			},
			variableAssignment: () => {
				let node = {
					type: 'variableAssignment',
					range: {},
					identifier: undefined,
					operator: undefined,
					value: undefined
				}
			},
			variableDeclaration: () => {
				let node = {
					type: 'variableDeclaration',
					range: {},
					kind: undefined,
					initializers: []
				}
			},
			whileStatement: () => {}
		}

		static get token() {
			return this.getToken();
		}

		static get tokensEnd() {
			return this.position === this.tokens.length;
		}

		static getToken(offset = 0) {
			return this.tokens[this.position+offset] ?? {
				position: undefined,
				location: undefined,
				type: '',
				value: ''
			}
		}

		static report(level, position, string) {
			let location = this.tokens[position].location;

			if(this.reports.find(v =>
				v.location.line === location.line &&
				v.location.column === location.column &&
				v.string === string) != null
			) {
				return;
			}

			this.reports.push({
				level: level,
				location: location,
				string: string
			});
		}

		static reset() {
			this.tokens = []
			this.position = 0;
			this.reports = []
		}

		static parse(lexerResult) {
			this.reset();

			this.tokens = lexerResult.tokens;

			let result = {
				tree: this.rules.module(),
				reports: this.reports
			}

			this.reset();

			return result;
		}
	}

	class Interpreter {
		static memory = [
			{
				address: 0,
				inheritance: ['Namespace'],
				members: [
					{
						accessibility: ['public', 'static'],
						constant: false,
						title: 'TestClass',
						typed: true,
						inheritance: [1],
						nillable: true,
						value: '1',
						observers: {}
					},
					{
						accessibility: ['public', 'static'],
						constant: true,
						title: 'testPi',
						typed: true,
						inheritance: ['float'],
						nillable: true,
						value: '3.14',
						observers: {}
					},
					{
						accessibility: ['public', 'static'],
						constant: false,
						title: 'testClassInstance',
						typed: true,
						inheritance: [2],
						nillable: true,
						value: '3',
						observers: {}
					},
					{
						accessibility: ['public'],
						constant: false,
						title: 'computedInstanceProperty',
						typed: false,
						inheritance: [],
						nillable: true,
						value: null,
						observers: {
							willGet: null, // Function address,
							get: null,
							didGet: null,
							willSet: null,
							set: null,
							didSet: null,
							willDelete: null,
							delete: null,
							didDelete: null
						}
					}
				],
				observers: [
					{
						type: 'chain', // 'subscript'
						willGet: null, // Function address,
						get: null,
						didGet: null,
						willSet: null,
						set: null,
						didSet: null,
						willDelete: null,
						delete: null,
						didDelete: null
					}
				],
				scope: null,
				retains: 1
			},
			{
				address: 1,
				inheritance: ['Class'],
				generics: [],
				members: [
					{
						accessibility: ['public', 'static'],
						constant: true,
						title: 'init',
						typed: true,
						inheritance: [
							/*
							{
								type: 'Function',
								generics: [],  // [null] - Unspecified list, [] - Empty list
								parameters: [
									{
										typed: false,
										inheritance: [],
										nillable: true,
										variadic: true
									},
									{
										typed: false,
										inheritance: [],
										nillable: true,
										variadic: true
									}
								],
								asynchronous: 0,  // -1 - Unspecified, 0 - False, 1 - True
								throws: 0,
								return: {
									typed: true,
									inheritance: ['bool'],
									nillable: false
								}
							}
							*/
							'Function'
						],
						nillable: false,
						value: '2',
						observers: {}
					},
					{
						accessibility: ['public'],
						constant: false,
						title: 'testVariable',
						typed: true,
						inheritance: ['int'],
						nillable: true,
						value: null,
						observers: {}
					}
				],
				observers: [],
				scope: 0,
				retains: 1
			},
			{
				address: 2,
				inheritance: ['Function'],
				generics: [
					/*
					{
						title: 'A',
						typed: false,
						inheritance: [],
						nillable: true
					},
					*/
				],
				parameters: [
					{
						label: null,
						title: 'firstArgument',
						inout: false,
						typed: true,
						inheritance: ['float'],
						nillable: false,
						variadic: false
					},
					{
						label: null,
						title: 'secondArgument',
						inout: false,
						typed: true,
						inheritance: ['bool'],
						nillable: true,
						variadic: false
					}
				],
				asynchronous: 0,
				throws: 0,
				return: {
					typed: true,
					inheritance: ['bool'],
					nillable: true
				},
				body: '\ttestVariable = 2 print(\'Test: \'+firstArgument)\n\n\treturn secondArgument', // Function body from Parser result
				members: [
					{
						title: 'parametersCount',
						inheritance: ['int'],
						value: '2'
					}
				],
				scope: 1,
				retains: 1
			},
			{
				address: 3,
				inheritance: ['Object', 1],
				members: [
					{
						title: 'testVariable',
						value: '2'
					}
				],
				scope: 0,
				retains: 1
			}
		]
		static contexts = []

		static rules = {
			module: (node) => {
				let namespace = this.rules.namespace(node);

				if(node.members.length > 0) {
					this.rules.members(namespace, node.members);
				}
			},
			namespace: (node) => {

			},
			members: (context, members) => {

			}
		}

		static createInheritance(primary, ...secondary) {
			if(![
				'argument',
				'class',
				'enumeration',
				'function',
				'instance',
				'namespace',
				'protocol',
				'structure',
				'variable'
			].includes(primary)) {
				throw new RangeError();
			}
			if(['argument', 'variable'].includes(primary)) {
				if(
					![
						'_',
						'Any',
						'any',
						'bool',
						'float',
						'int',
						'string'
					].includes(secondary[0]) ||
					secondary?.some(v => typeof v !== 'string' && !Number.isInteger(v))
				) {
					throw new TypeError();
				}
			}

			return [primary, ...secondary]
		}

		static createAccessibility(...values) {
			for(value of values) {
				if(![
					'private',
					'protected',
					'public',
					'static'
				].includes(value)) {
					return;
				}
			}

			return values;
		}

		static createMember(inheritance, parameters) {
			let member;

			if(inheritance[0] === 'variable') {
				member = {
					/*
					accessibility: accessibility,
					constant: constant,
					title: title,
					typed: typed,
					inheritance: inheritance,
					nillable: nillable,
					value: value
					*/
				}
			}
			return member;
		}

		static getComposite(address) {
			let composite = this.memory.find(v => v.address === address);

			if(composite == null) {
				return;
			}

			return new Proxy(composite, {
				get: (t, k) => {
					if(k === 'metaSelf') {
						return t;
					}

					let members = t.members ?? [],
						member = members.find(v => v.title === k),
						title = member?.title,
						inheritance = member?.inheritance ?? [],
						value = member?.value;

					if(member == null) {
						return;
					}

					if(inheritance.length > 0 && inheritance.every(v => Number.isInteger(v))) {
						let address = value*1;

						return this.getComposite(address);
					} else {
						return member;
					}
				},
				ownKeys: (t) => {
					let members = t.members ?? [],
						keys = members.map(v => v.title);

					keys.push('metaSelf');

					return keys;
				},
				getOwnPropertyDescriptor: (t, k) => {
					if(k === 'metaSelf') {
						return {
							enumerable: true,
							configurable: true,
							value: t
						}
					}

					let members = t.members ?? [],
						member = members.find(v => v.title === k),
						inheritance = member?.inheritance ?? [],
						value = member?.value;

					if(member == null) {
						return;
					}

					if(inheritance.length > 0 && inheritance.every(v => Number.isInteger(v))) {
						let address = value*1;

						member = this.getComposite(address);
					}

					return {
						enumerable: true,
						configurable: true,
						value: member
					}
				}
			});
		}

		static createMainContext() {
		//  this.memory.push();

			if(this.contexts.length === 0) {
				this.contexts.push(this.getComposite(0));
			}
		}
	}

	let lexerResult = Lexer.tokenize(code),
		parserResult = Parser.parse(lexerResult),
		tokens = lexerResult.rawTokens,
		reports = [...lexerResult.reports, ...parserResult.reports]
					.sort((a, b) => a.location.line-b.location.line || a.location.column-b.location.column);

	for(let k = 0; k < tokens.length; k++) {
		let textbox = document.getElementById('output_lint'),
			position = tokens[k].position,
			type = tokens[k].type,
			value = tokens[k].value,
			length = value.length,
			elements = []

		if(type === 'delimiter') {
			let element;

			for(let i = 0; i < value.length; i++) {
				if(value[i] !== '\n') {
					element ??= document.createElement('span');
					element.innerHTML += value[i]

					if(value[i+1] === '\n' || i === value.length-1) {
						elements.push(element);
						element = undefined;
					}
				}
				if(value[i] === '\n') {
					elements.push(document.createElement('br'));
				}
			}
		} else {
			elements.push(document.createElement('span'));

			elements[0].innerHTML = value;

			if(type.startsWith('comment')) {
				elements[0].style.color = 'rgb(95 179 63 / 1)';
			}
			if(type.startsWith('string')) {
				if(type === 'string') {
					elements[0].innerHTML = '\''+value+'\'';
				}
				if(type === 'stringSegmentFirst') {
					elements[0].innerHTML = '\''+value;
				}
				if(type === 'stringSegmentLast') {
					elements[0].innerHTML = value+'\'';
				}
				if(!type.startsWith('stringExpression')) {
					elements[0].style.color = 'rgb(191 127 95 / 1)';
				}
			}
			if(type.startsWith('operator')) {
				elements[0].style.color = 'rgb(255 191 0 / 1)';

				if(type.endsWith('Prefix')) {
					elements[0].style.color = 'rgb(255 63 0 / 1)';
				}
				if(type.endsWith('Infix')) {
					elements[0].style.color = 'rgb(255 95 0 / 1)';
				}
				if(type.endsWith('Postfix')) {
					elements[0].style.color = 'rgb(255 127 0 / 1)';
				}
			}
			if(type.startsWith('keyword')) {
				elements[0].style.color = 'cornflowerblue';

				if([
					'nil',
					'true',
					'false'
				].includes(value)) {
					elements[0].style.color = 'rgb(223 127 223 / 1)';
				}
			}
			if(type.startsWith('number')) {
				elements[0].style.color = 'rgb(223 127 223 / 1)';
			}
		}

		for(let element of elements) {
			textbox.appendChild(element);
		}
	}
	for(let report of reports) {
		let level = report.level.toString()
						.replace('0', 'Info')
						.replace('1', 'Warning')
						.replace('2', 'Error'),
			line = report.location.line+1,
			column = report.location.column+1,
			string = report.string;

		console.log(line+':'+column+': '+level+': '+string);
	}
	console.log(lexerResult.tokens);
	console.log(parserResult.tree);
</script>
</body>
</html>
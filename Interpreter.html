<html>
<body>
<style>
#input {
	width: 768px;
	height: 512px;
	overflow: auto;

	border: none;
	border-radius: 2px;
	background: white;
	box-shadow: 0 2px 4px gray;

	color: black;
	font: 12px monospace;
	white-space: pre;
}
</style>
<div id="input" contenteditable="true"><!--
-->class A: B, C, D {}

// Foundation Source

struct Boolean {
	const value

	init(value: bool) {
		self.value = value
	}

	func ==(rhs: bool & Boolean) -> Boolean {
		return rhs !is Boolean ? value == rhs : value == rhs.value
	}
}

struct Number {
	static const Pi = 3.14

	const value

	init(value: int & decimal) {
		self.value = value
	}

	func ==(rhs: int & decimal & Number) -> Boolean {
		return rhs !is Number ? value == rhs : value == rhs.value
	}
}

struct Decimal: Number {
	init(value: int & decimal) {
		if var v = value%2 && (v == 0 || v == 1) {
			throw 'Value can\'t be integer'
		}

		self.value = value
	}
}

struct Integer: Number {
	init(value: int & decimal) {
		if var v = value%2 && v > 0 && v < 1 {
			throw 'Value can\'t be decimal'
		}

		self.value = value
	}
}

struct String {
	const value

	init(value: string) {
		self.value = value
	}

	func ==(rhs: string & String) -> Boolean {
		return rhs !is String ? value == rhs : value == rhs.value
	}
}

// ---- ---- ---- ----

/* Comment
Block */

// Comment Line

import Foundation

alias Boolean = Foundation.Boolean,
	  Number = Foundation.Number,
	  Decimal = Foundation.Decimal,
	  Integer = Foundation.Integer,
	  String = Foundation.String

const constant = Number.Pi

var variable

if constant > 0 {
	variable = 1
}

class Class {
	const private constant: Number = 0.5

	var protected variable: Integer = 1

	var variable_01a = 'String'

	var private anotherVariableStorage

	var anotherVariable {
		willSet {}
		set {
			anotherVariableStorage = newValue
		}
		didSet {}
		willGet {}
		get {
			return anotherVariableStorage
		}
		didGet {}
	}

	chain {
		get {
			return metaObject.properties[key]?.value
		}
		set {
			metaObject.properties[key]?.value = value
		}
	}

	subscript(a: Integer, b: Integer) {
		get {
			return a+b
		}
		set {
			print(a, b)
		}
	}

	init(with parameter: Integer = 0, and parameter_: String) {
		print('Intitializing with \(parameter) and \(parameter_)')

		variable = parameter
		variable_01a = parameter_
	}

	deinit {
		print('Deinitializing!')
	}
}

var instance = Class(with: 12, and: '2')

print('Testing nested template string: printing some \(identifier+'abc\(1+2+3)def'+0.125) and \(instance.variable)')

instance = nil
</div>
<script>
	let code = document.getElementById('input').innerText;

	class Lexer {
		static code;
		static position;
		static location;
		static tokens;
		static levels;
		static reports;
		static rules = [
			['/*', (v) => {
				if(this.levels.comment > 0 || this.levels.string > this.levels.stringExpression) {
					this.lastToken.value += v;
				} else {
					this.createToken('commentBlock', '');
				}
				if(this.lastToken.type === 'commentBlock') {
					this.levels.comment++;
				}
			}],
			['*/', (v) => {
				if(this.levels.comment > 0 && this.lastToken.type === 'commentLine' || this.levels.comment > 1 || this.levels.string > this.levels.stringExpression) {
					this.lastToken.value += v;
				}
				if(this.lastToken.type === 'commentBlock') {
					this.levels.comment--;
				}
			}],
			['//', (v) => {
				if(this.levels.comment > 0 || this.levels.string > this.levels.stringExpression) {
					this.lastToken.value += v;
				} else {
					this.createToken('commentLine', '');
					this.levels.comment++;
				}
			}],
			[['\\\\', '\\\'', '\\(', '\\b', '\\f', '\\n', '\\r', '\\t', '\\v', '\\'], (v) => {
				if(this.levels.comment > 0) {
					this.lastToken.value += v;
				} else
				if(this.levels.string > this.levels.stringExpression) {
					switch(v) {
						case '\\\\':	v = '\\';		break;
						case '\\\'':	v = '\'';		break;
						case '\\(':		return true;	break;
						case '\\b':		v = '\b';		break;
						case '\\f':		v = '\f';		break;
						case '\\n':		v = '\n';		break;
						case '\\r':		v = '\r';		break;
						case '\\t':		v = '\t';		break;
						case '\\v':		v = '\v';		break;
						case '\\':		v = '';			break;
					}

					this.lastToken.value += v;
				}
			}],
			[['\\(', ')'], (v) => {
				if(this.levels.comment > 0) {
					this.lastToken.value += v;
				} else {
					switch(v) {
						case '\\(':
							if(this.levels.string > this.levels.stringExpression) {
								this.lastToken.type = 'stringPart';
								this.createToken('stringExpressionOpen', v);
								this.levels.stringExpression++;
							}
						break;
						case ')':
							if(this.levels.string > this.levels.stringExpression || this.levels.stringExpression === 0 || this.levels.stringExpressionParenthesis > 0) {
								return true;
							}
							this.createToken('stringExpressionClosed', v);
							this.levels.stringExpression--;
							this.createToken('stringPart', '');
						break;
					}
				}
			}],
			[['!=', '!', '%', '&&', '&', '??=', '??', '?', '||', '==', '=', '<=', '<', '>=', '>', '--', '-=', '->', '-', '++', '+=', '+', '/=', '/', '*=', '*', ':', '.', ','], (v) => {
				if(this.levels.comment > 0 || this.levels.string > this.levels.stringExpression) {
					this.lastToken.value += v;
				} else {
					let title;

					switch(v) {
						case '!=':	title = 'NotEquals';			break;
						case '!':	title = 'Exclamation';			break;
						case '%':	title = 'Remainder';			break;
						case '&&':	title = 'And';					break;
						case '&':	title = 'Ampersand';			break;
						case '??=':	title = 'NullCoalescingAssign';	break;
						case '??':	title = 'NullCoalescing';		break;
						case '?':	title = 'Question';				break;
						case '||':	title = 'Or';					break;
						case '==':	title = 'Equals';				break;
						case '=':	title = 'Assign';				break;
						case '<=':	title = 'SmallerEquals';		break;
						case '<':	title = 'Smaller';				break;
						case '>=':	title = 'BiggerEquals';			break;
						case '>':	title = 'Bigger';				break;
						case '--':	title = 'Decrement';			break;
						case '-=':	title = 'MinusAssign';			break;
						case '->':	title = 'Returns';				break;
						case '-':	title = 'Minus';				break;
						case '++':	title = 'Increment';			break;
						case '+=':	title = 'PlusAssign';			break;
						case '+':	title = 'Plus';					break;
						case '/=':	title = 'DivideAssign';			break;
						case '/':	title = 'Divide';				break;
						case '*=':	title = 'MultiplyAssign';		break;
						case '*':	title = 'Multiply';				break;
						case ':':	title = 'Colon';				break;
						case '.':
							if(this.lastToken.type === 'numberInteger') {
								return true;
							} else {
								title = 'Chain';
							}
						break;
						case ',':	title = 'Also';				break;
					}

					this.createToken('operator'+title, v);
				}
			}],
			[['(', ')', '{', '}', '[', ']'], (v) => {
				if(this.levels.comment > 0 || this.levels.string > this.levels.stringExpression) {
					this.lastToken.value += v;
				} else {
					let title;

					switch(v) {
						case '(':
							if(this.levels.stringExpression > 0) {
								this.levels.stringExpressionParenthesis++;
							}
							title = 'parenthesisOpen';
						break;
						case ')':
							if(this.levels.stringExpression > 0) {
								this.levels.stringExpressionParenthesis--;
							}
							title = 'parenthesisClosed';
						break;
						case '{':	title = 'braceOpen';		break;
						case '}':	title = 'braceClosed';		break;
						case '[':	title = 'bracketOpen';		break;
						case ']':	title = 'bracketClosed';	break;
					}

					this.createToken(title, v);
				}
			}],
			['\'', () => {
				if(this.levels.comment > 0) {
					return true;
				}
				if(this.levels.string === this.levels.stringExpression) {
					this.createToken('string', '');
					this.levels.string++;
				} else
				if(this.levels.string > this.levels.stringExpression) {
					this.levels.string--;
				}
			}],
			[/\s|;/, (v) => {
				if(this.levels.comment > 0 || this.levels.string > this.levels.stringExpression) {
					if(v === '\n' && this.lastToken.type === 'commentLine') {
						this.createToken('delimiter');
						this.levels.comment--;
					} else {
						this.lastToken.value += v;
					}
				} else
				if(this.lastToken.type === 'delimiter') {
					this.lastToken.value += v;
				} else {
					this.createToken('delimiter');
				}
			}],
			[/[0-9\.]/, (v) => {
				if(this.levels.comment > 0 || this.levels.string > this.levels.stringExpression || this.lastToken.type.startsWith('number') || this.lastToken.type === 'identifier' && v !== '.') {
					if(this.lastToken.type === 'numberInteger' && v === '.') {
						this.lastToken.type = 'numberFloat';
					}
					this.lastToken.value += v;
				} else
				if(v !== '.') {
					this.createToken('numberInteger');
				}
			}],
			[/[a-z_]/i, (v) => {
				if(this.levels.comment > 0 || this.levels.string > this.levels.stringExpression) {
					return true;
				}
				if(this.lastToken.type !== 'identifier' && !this.lastToken.type.startsWith('keyword')) {
					this.createToken('identifier', '');
				}
				this.lastToken.value += v;
				if([
					'alias',
					'break',
					'case', 'catch', 'chain', 'class', 'const', 'continue',
					'default',
					'else', 'enum', 'extension',
					'false', 'for', 'func',
					'if', 'import', 'is',
					'namespace', 'nil',
					'private', 'protected', 'protocol', 'public',
					'return',
					'self', 'struct', 'subscript', 'super', 'switch',
					'throw', 'true', 'try',
					'var',
					'while'
				].includes(this.lastToken.value)) {
					this.lastToken.type = 'keyword'+this.lastToken.value[0].toUpperCase()+this.lastToken.value.slice(1);
				} else {
					this.lastToken.type = 'identifier';
				}
			}],
			[/.|\n/i, (v) => {
				if(this.lastToken.type === 'commentBlock' || this.lastToken.type === 'commentLine' && v !== '\n' || this.levels.string > this.levels.stringExpression) {
					this.lastToken.value += v;
				} else {
					this.report(0, 'No token of appropriate type was created before to accept this character and it doesn\'t represent any possible type independently: "'+v+'", skipping...');
				}
			}]
		]

		static get lastToken() {
			return this.tokens.at(-1) ?? {
				position: undefined,
				location: undefined,
				type: '',
				value: ''
			}
		}

		static createToken(type, value) {
			this.tokens.push({
				position: this.position,
				location: {...this.location},
				type: type,
				value: value != null ? value : this.code[this.position]
			});
		}

		static report(level, string) {
			this.reports.push({
				level: level,
				location: {...this.location},
				string: string
			});
		}

		static reset() {
			this.code = undefined;
			this.position = undefined;
			this.location = {
				line: 0,
				column: 0
			}
			this.tokens = []
			this.levels = {
				comment: 0,
				string: 0,
				stringExpression: 0,
				stringExpressionParenthesis: 0
			}
			this.reports = []
		}

		static atPosition(substring) {
			return this.code.indexOf(substring, this.position) === this.position;
		}

		static tokenize(code, cleanupLevel) {
			this.reset();

			this.code = code;

			for(this.position = 0; this.position < this.code.length; this.position++) {
				for(let rule of this.rules) {
					let triggers = rule[0],
						actions = rule[1],
						plain = typeof triggers === 'string',
						array = Array.isArray(triggers),
						regex = triggers instanceof RegExp,
						trigger;

					if(plain && this.atPosition(triggers)) {
						trigger = triggers;
					}
					if(array) {
						trigger = triggers.find(v => this.atPosition(v));
					}
					if(regex && triggers.test(this.code[this.position])) {
						trigger = this.code[this.position]
					}

					if(trigger != null && !actions(trigger)) {
						this.position += trigger.length-1;

						for(let character of trigger) {
							if(character === '\n') {
								this.location.line++;
								this.location.column = 0;
							} else {
								this.location.column++;
							}
						}

						break;
					}
				}
			}

			let result = {}

			if(cleanupLevel === 1) {
				result.tokens = this.tokens.filter(v => !(v.type === 'delimiter' && !v.value.includes('\n') && !v.value.includes(';')))
			}
			if(cleanupLevel === 2) {
				result.tokens = this.tokens.filter(v => !v.type.startsWith('comment') && v.type !== 'delimiter');
			}

			result.reports = this.reports;

			this.reset();

			return result;
		}
	}

	class Parser {
		static tokens;
		static position;
		static reports;
		static rules = {
			aliasDeclaration: () => {},
			callExpression: () => {
				let node = {
					type: 'chainExpression',
					range: {},
					callee: undefined,
					arguments: undefined
				}
			},
			chainExpression: () => {
				let node = {
					type: 'chainExpression',
					range: {},
					object: undefined,
					property: undefined
				}
			},
			classBody: () => {
				return this.rules.specificBody('class');
			},
			classDeclaration: () => {
				let node = {
					type: 'classDeclaration',
					range: {},
					id: undefined,
					inheritance: undefined,
					body: undefined
				}

				if(this.currentToken.type === 'keywordClass') {
					node.range.start = this.position++;
				} else {
					return;
				}

				node.id = this.rules.identifier();
				node.inheritance = this.rules.typeInheritanceClause();
				node.body = this.rules.classBody();

				if(node.id == null) {
					this.report(2, node.range.start, 'No identifier set for class.');
				}
				if(node.body != null) {
					node.range.end = node.body.range.end;
				} else {
					this.report(1, node.range.start, 'Class doesn\'t have body.');
				}

				return node;
			},
			classMembers: () => {
				return this.rules.specificMembers([
					'aliasDeclaration',
					'classDeclaration',
					'functionDeclaration',
					'structureDeclaration',
					'variableDeclaration'
				]);
			},
			floatLiteralExpression: () => {
				let node = {
					type: 'floatLiteralExpression',
					range: {},
					value: undefined
				}

				if(this.currentToken.type === 'numberFloat') {
					node.value = this.currentToken.value;
					node.range.start =
					node.range.end = this.position++;
				} else {
					return;
				}

				return node;
			},
			functionBody: () => {
				return this.rules.specificBody('function');
			},
			functionCallExpression: () => {},
			functionDeclaration: () => {
				let node = {
					type: 'functionDeclaration',
					range: {},
					id: undefined,
					signature: undefined,
					body: undefined
				}

				if(this.currentToken.type === 'keywordFunc') {
					node.range.start = this.position++;
				} else {
					return;
				}

				node.id = this.rules.identifier() ?? this.rules.operator();
				node.signature = this.rules.functionSignature();
				node.body = this.rules.functionBody();

				if(node.id == null) {
					this.report(2, node.range.start, 'No identifier set for function.');
				}
				if(node.signature == null) {
					this.report(2, node.range.start, 'Function lacks of signature.');
				}
				if(node.body != null) {
					node.range.end = node.body.range.end;
				} else {
					this.report(1, node.range.start, 'Function doesn\'t have body.');
				}

				return node;
			},
			functionMembers: () => {
				return this.rules.specificMembers([
					'aliasDeclaration',
					'callExpression',
					'chainExpression',
					'classDeclaration',
					'functionCallExpression',
					'functionDeclaration',
					'ifStatement',
					'importDeclaration',
					'structureDeclaration',
					'subscriptExpression',
					'variableAssignment',
					'variableDeclaration'
				]);
			},
			functionParameter: () => {},
			functionSignature: () => {
				let node = {
					type: 'functionSignature',
					range: {},
					parameters: undefined
				}

				if(this.currentToken.type === 'parenthesisOpen') {
					node.range.start = this.position++;
				} else {
					return;
				}

				while(true) {
					let node_ = this.rules.functionParameter();

					if(node_ != null) {
						node.parameters.push(node_);
					} else {
						break;
					}
					if(this.currentToken.type === 'operatorAlso') {
						this.position++;
					} else {
						break;
					}
				}

				if(this.currentToken.type === 'parenthesisClosed') {
					node.range.end = this.position++;
				} else {
					this.position = node.range.start;

					return;
				}

				return node;
			},
			identifier: () => {
				let node = {
					type: 'identifier',
					range: {},
					value: undefined
				}

				if(this.currentToken.type === 'identifier') {
					node.value = this.currentToken.value;
					node.range.start =
					node.range.end = this.position++;
				} else {
					return;
				}

				return node;
			},
			ifStatement: () => {},
			importDeclaration: () => {},
			initializerClause: () => {
				let node = {
					type: 'initializerClause',
					range: {},
					id: undefined
				}

				if(this.currentToken.type === 'operatorAssign') {
					node.value = this.currentToken.value;
					node.range.start =
					node.range.end = this.position++;
				} else {
					return;
				}

				node.id = this.rules.identifier();

				if(node.id != null) {
					node.range.end = node.id.range.end;
				} else {
					this.position = node.range.start;

					return;
				}

				return node;
			},
			integerLiteralExpression: () => {
				let node = {
					type: 'integerLiteralExpression',
					range: {},
					value: undefined
				}

				if(this.currentToken.type === 'numberInteger') {
					node.value = this.currentToken.value;
					node.range.start =
					node.range.end = this.position++;
				} else {
					return;
				}

				return node;
			},
			logicalExpression: () => {},
			module: () => {
				let node = {
					type: 'module',
					range: {
						start: 0,
						end: 0
					},
					members: this.rules.functionMembers()
				}

				if(node.members.length > 0) {
					node.range.start = node.members[0].range.start;
					node.range.end = node.members.at(-1).range.end;
				}

				return node;
			},
			operator: () => {
				let node = {
					type: 'operator',
					range: {},
					value: undefined
				}

				if(this.currentToken.type.startsWith('operator')) {
					node.value = this.currentToken.value;
					node.range.start =
					node.range.end = this.position++;
				} else {
					return;
				}

				return node;
			},
			specificBody: (type) => {
				let node = {
					type: type+'Body',
					range: {},
					members: []
				}

				if(this.currentToken.type === 'braceOpen') {
					node.range.start = this.position++;
				} else {
					return;
				}

				node.members = this.rules[type+'Members']();

				if(this.currentToken.type === 'braceClosed') {
					node.range.end = this.position++;
				} else {
					this.position = node.range.start;

					return;
				}

				return node;
			},
			specificMembers: (types) => {
				let list = []

				while(true) {
					let node

					for(let type of types) {
						node = this.rules[type]();

						if(node != null) {
							list.push(node);

							break;
						}
					}
					if(node != null) {
						continue;
					}

					node = list.findLast(v => v.type === 'unawaredMember');

					if(node == null || node !== list.at(-1)) {
						node = {
							type: 'unawaredMember',
							range: {
								start: this.position,
								end: this.position
							},
							scopeLevel: 1
						}

						list.push(node);
					} else {
						node.range.end = this.position;
					}

					switch(this.currentToken.type) {
						case 'braceOpen':	node.scopeLevel++; break;
						case 'braceClosed':	node.scopeLevel--; break;
					}

					if(node.scopeLevel === 0 || this.position === this.tokens.length) {
						node.range.end--;

						if(node.range.start > node.range.end) {
							list = list.filter(v => v !== node);
						}

						break;
					}

					this.position++;
				}

				for(let node of list.filter(v => v.type === 'unawaredMember')) {
					delete node.scopeLevel;

					this.report(1, node.range.start, 'Unawared member type at range of tokens ['+node.range.start+':'+node.range.end+'].');
				}

				return list;
			},
			structureBody: () => {
				return this.rules.specificBody('structure');
			},
			structureDeclaration: () => {
				let node = {
					type: 'structureDeclaration',
					range: {},
					id: undefined,
					inheritance: undefined,
					body: undefined
				}

				if(this.currentToken.type === 'keywordStruct') {
					node.range.start = this.position++;
				} else {
					return;
				}

				node.id = this.rules.identifier();
				node.inheritance = this.rules.typeInheritanceClause();
				node.body = this.rules.structureBody();

				if(node.id == null) {
					this.report(2, node.range.start, 'No identifier set for structure.');
				}
				if(node.body != null) {
					node.range.end = node.body.range.end;
				} else {
					this.report(1, node.range.start, 'Structure doesn\'t have body.');
				}

				return node;
			},
			structureMembers: () => {
				return this.rules.specificMembers([
					'aliasDeclaration',
					'classDeclaration',
					'functionDeclaration',
					'structureDeclaration',
					'variableDeclaration'
				]);
			},
			subscriptExpression: () => {},
			typeInheritanceClause: () => {
				let node = {
					type: 'typeInheritanceClause',
					range: {},
					identifiers: []
				}

				if(this.currentToken.type === 'operatorColon') {
					node.range.start = this.position++;
				} else {
					return;
				}

				while(true) {
					let node_ = this.rules.identifier();

					if(node_ != null) {
						node.identifiers.push(node_);
					} else {
						break;
					}
					if(this.currentToken.type === 'operatorAlso') {
						this.position++;
					} else {
						break;
					}
				}

				if(node.identifiers.length > 0) {
					node.range.end = node.identifiers.at(-1).range.end;
				} else {
					this.position = node.range.start;

					return;
				}

				return node;
			},
			variableAssignment: () => {
				let node = {
					type: 'variableAssignment',
					range: {},
					identifier: undefined,
					operator: undefined,
					value: undefined
				}
			},
			variableDeclaration: () => {
				let node = {
					type: 'variableDeclaration',
					range: {},
					kind: undefined,
					list: []
				}
			}
		}

		static get currentToken() {
			return this.getToken();
		}

		static getToken(offset = 0) {
			return this.tokens[this.position+offset] ?? {
				position: undefined,
				location: undefined,
				type: '',
				value: ''
			}
		}

		static report(level, position, string) {
			let location = this.tokens[position].location;

			this.reports.push({
				level: level,
				location: location,
				string: string
			});
		}

		static reset() {
			this.tokens = []
			this.position = 0;
			this.reports = []
		}

		static parse(lexerResult) {
			this.reset();

			this.tokens = lexerResult.tokens;

			let result = {
				tree: this.rules.module(),
				reports: this.reports
			}

			this.reset();

			return result;
		}
	}

	let lexerResult = Lexer.tokenize(code, 2),
		parserResult = Parser.parse(lexerResult),
		tokens = lexerResult.tokens,
		tree = parserResult.tree,
		reports = [...lexerResult.reports, ...parserResult.reports]
					.sort((a, b) => a.location.line-b.location.line || a.location.column-b.location.column);

	/*
	for(let k = tokens.length-1; k >= 0; k--) {
		let textbox = document.getElementById('input'),
			position = tokens[k].position,
			type = tokens[k].type,
			value = tokens[k].value,
			length = value.length,
			color;

		if(token.type.startsWith('operator')) {
			color = 'red';
		}
	}
	*/
	for(let report of reports) {
		let level = report.level.toString()
						.replace('0', 'Info')
						.replace('1', 'Warning')
						.replace('2', 'Error'),
			line = report.location.line+1,
			column = report.location.column+1,
			string = report.string;

		console.log(line+':'+column+': '+level+': '+string);
	}
	console.log(tokens);
	console.log(tree);
</script>
</body>
</html>
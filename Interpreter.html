<html>
<body>
<style>
body {
	display: grid;
	grid-template-columns: 5fr 4fr;
	grid-template-rows: 2fr 1fr;
	grid-template-areas:
		'code abstract'
		'console console';

	margin: 0;
}

#input,
#output_lint,
#output_ast,
#output_console {
	overflow: auto;

	font: 12px monospace;
	tab-size: 4;
	white-space: pre;
}

#input,
#output_lint {
	grid-area: code;

	box-sizing: border-box;

	padding: 2px;

	border: none;
	background: rgb(63 63 63 / 1);

	color: rgba(255 255 255 / 0.25);
	caret-color: white;
}

#output_lint {
	background: none;

	color: rgb(191 191 191 / 1);

	pointer-events: none;
}

#output_ast,
#output_console {
	grid-area: abstract;

	background: rgb(223 223 223 / 1);;

	font-size: 10px;
}

#output_console {
	grid-area: console;

	background: none;
}
</style>
<textarea id="input">
class A<B>: C<D>, E<F>, G<H> {}

func a<A: B<C>>() {}

g<a, b>(c)

var c = a is B ? b !is A : d.e

class Type/*<A: B & C, D>*/: A<B & C, D>, E, F {}

// Foundation Source

postfix operator ++
postfix operator --

prefix operator ++
prefix operator --

/* private */ infix operator == {
	associativity: left
	precedence: 64
}

struct Boolean {
	private final var value

	init(value: bool) {
		self.value = value  // .value = value
	}

	static func ==(lhs: bool & Boolean, rhs: bool & Boolean) -> Boolean {
		var leftValue = lhs !is Boolean ? lhs : lhs.value,
			rightValue = rhs !is Boolean ? rhs : rhs.value

		return leftValue == rightValue
	}
}

struct Number {
	static final var Pi = 3.141592653589793

	protected final var value

	init(value: int & float) {
		.value = value
	}

	static func ==(lhs: int & float & Number, rhs: int & float & Number) -> Boolean {
		var leftValue = lhs !is Number ? lhs : lhs.value,
			rightValue = rhs !is Number ? rhs : rhs.value

		return leftValue == rightValue
	}
}

struct Float: Number {
	init(value: int & float) {
		if var v = value%2 && (v == 0 || v == 1) {
			throw 'Value can\'t be integer'
		}

		.value = value
	}
}

struct Integer: Number {
	init(value: int & float) {
		if var v = value%2 && v > 0 && v < 1 {
			throw 'Value can\'t be float'
		}

		.value = value
	}
}

struct String {
	private final var value

	init(value: string) {
		.value = value
	}

	static func ==(lhs: string & String, rhs: string & String) -> Boolean {
		var leftValue = lhs !is String ? lhs : lhs.value,
			rightValue = rhs !is String ? rhs : rhs.value

		return leftValue == rightValue
	}
}

class Array {}

class Dictionary {}

// ---- ---- ---- ----

/* Multiblock
	/* Comment */
		Block */

// Comment Line

import Foundation

final var Boolean = Foundation.Boolean,
	  	  Number = Foundation.Number,
	  	  Decimal = Foundation.Decimal,
	  	  Integer = Foundation.Integer,
	  	  String = Foundation.String,
	  	  Array = Foundation.Array,
	  	  Dictionary = Foundation.Dictionary

final var constant = Number.Pi

var variable

if constant > 0 {
	variable = 1
}

class A {
	private final var constant: Number = 0.5

	protected var variable: Integer = 1

	var variable_01a = 'String'

	private var anotherVariableStorage

	var anotherVariable {
		get {
			return anotherVariableStorage
		}
		set {
			anotherVariableStorage = newValue
		}

		willGet {}
		didGet {}
		willSet {}
		didSet {}
	}

	chain {
		get {
			return metaSelf.properties[key]?.value
		}
		set {
			metaSelf.properties[key] = value
		}
	}

	subscript(a: Integer, b: Integer) -> Integer {
		get {
			return a+b
		}
		set {
			print(a, b)
		}
	}

	init(with number: Integer = 0, and string: String) {
		print('Intitializing with \(number) and \(string)')

		variable = number
		variable_01a = string
	}

	deinit {
		print('Deinitializing!')
	}
}

var instance = A(with: 12, and: '2')

/*
var self.A: self.Class = class { ... }

var self.instance = A(with: 12, and: '2')
*/

print('Testing nested template string: printing some \(identifier+'abc\(1+2+3)def'+0.125) and \(instance.variable)')

var instance_2 = struct {
	init(test: Integer) {
		print('Initialized anonymous struct with testing variable: '+test)
	}
}(12)

instance =
instance_2 = nil

enum B {
	case first
	case second
	case third
	case fourth
}

var enum_value: B = .first

var function

/*
function = { x in x > 0 } - 1

function = (x) in x > 0
function = (x) { x > 0 }
function = (x) { return x > 0 } - 2

function = func (x) in x > 0
function = func (x) { x > 0 }
function = func (x) { return x > 0 } - 3

func getMnemonic(color: Color) =
    when color {
        .RED -> "кот"
        .ORANGE -> "охотник"
        .YELLOW -> "желает"
        .GREEN -> "знать"
        .BLUE -> "где"
        .INDIGO -> "сидят"
        .VIOLET -> "фазаны"
	}

func getWarmth(color: Int) = when(color) {
    RED, YELLOW -> "warm"
    GREEN -> "neutral"
    BLUE -> "cold"
    else -> "unknown"
}

when catImageView.visibility {
    View.VISIBLE -> println('visible')
    View.INVISIBLE -> println('invisible')
    else -> println('gone')
}
*/

var A = 1

print(A)		// 1

if true {		// If statements have local scopes
	print(A)	// class (Declarations execute first)

	class A {}
}

print(A)		// 1

A = class {}

print(A)		// class
</textarea>
<div id="output_lint"></div>
<div id="output_ast"></div>
<div id="output_console"></div>
<script>
	class Lexer {
		static code;
		static position;
		static location;
		static tokens;
		static levels;
		static reports;

		static rules = [
			[['/*', '*/'], (v) => {
				if(this.atCommentLevel || this.atStringLevel) {
					this.ruleHelpers.continueString();
					this.token.value += v;
				} else
				if(v === '/*') {
					this.addToken('commentBlock', v);
				}
				if(this.token.type === 'commentBlock') {
					if(v === '/*') {
						this.levels.comment++;
					} else {
						this.levels.comment--;
					}
				}
			}],
			['//', (v) => {
				if(this.atCommentLevel || this.atStringLevel) {
					this.ruleHelpers.continueString();
					this.token.value += v;
				} else {
					this.addToken('commentLine', v);
					this.levels.comment++;
				}
			}],
			[['\\\\', '\\\'', '\\(', '\\b', '\\f', '\\n', '\\r', '\\t', '\\v', '\\'], (v) => {
				if(this.atCommentLevel) {
					this.token.value += v;

					return;
				}
				if(!this.atStringLevel) {
					this.ruleHelpers.reportSkip(v);

					return;
				}
				if(v === '\\(') {
					return true;
				}

				this.ruleHelpers.continueString();
				this.token.value += ({
					'\\\\': '\\',
					'\\\'': '\'',
					'\\b': '\b',
					'\\f': '\f',
					'\\n': '\n',
					'\\r': '\r',
					'\\t': '\t',
					'\\v': '\v',
					'\\': ''
				})[v]
			}],
			[['\\(', ')'], (v) => {
				if(this.atCommentLevel) {
					this.token.value += v;

					return;
				}

				switch(v) {
					case '\\(':
						if(this.atStringLevel) {
							this.addToken('stringExpressionOpen', v);
							this.levels.stringExpression++;
						}
					break;
					case ')':
						if(this.atStringExpressionLevel && this.levels.parenthesis === 0) {
							this.addToken('stringExpressionClosed');
							this.levels.stringExpression--;
						} else {
							return true;
						}
					break;
				}
			}],
			[['(', ')', '<', '>', '[', ']', '{', '}'], (v) => {
				if(this.atCommentLevel || this.atStringLevel) {
					this.ruleHelpers.continueString();
					this.token.value += v;

					return;
				}

				let type = ({
					'(': 'parenthesisOpen',
					')': 'parenthesisClosed',
					'<': 'angleOpen',
					'>': 'angleClosed',
					'[': 'bracketOpen',
					']': 'bracketClosed',
					'{': 'braceOpen',
					'}': 'braceClosed'
				})[v]

				if(v === '<') {
					let compositeDeclarationPattern = [
							{ type: /^keyword/ },
							{ type: /^delimiter$/, optional: true },
							{ type: /^identifier$/ },
							{ type: /^delimiter$/, optional: true }
						],
						inheritancePattern = [
							{ type: /^operator/, value: /^[:&|,]$/ },
							{ type: /^delimiter$/, optional: true },
							{ type: /^identifier$/ },
							{ type: /^delimiter$/, optional: true }
						]

					if(!this.atPattern(compositeDeclarationPattern) && !this.atPattern(inheritancePattern)) {
						return true;
					}

					this.levels.angle++;
				}
				if(v === '>') {
					if(this.levels.angle === 0) {
						return true;
					}

					this.levels.angle--;
				}
				if(this.atStringExpressionLevel) {
					this.levels.parenthesis += v === '(';
					this.levels.parenthesis -= v === ')';
				}
				if(type.endsWith('Open')) {
					this.ruleHelpers.specifyOperatorType();
				}

				this.addToken(type);
			}],
			[['!', '%', '&', '*', '+', ',', '-', '.', '/', ':', '<', '=', '>', '?', '^', '|', '~'], (v) => {
				let initializers = [',', '.', ':'],	// Create new token if value exists in the list and current (operator) token doesn't initialized with it
					singletons = ['!', '?']			// Create new token if current (postfix operator) token matches any value in the list

				let initialize = initializers.includes(v) && !this.token.value.startsWith(v),
					singleton = this.token.type === 'operatorPostfix' && singletons.includes(this.token.value);

				if(this.atCommentLevel || this.atStringLevel || this.token.type.startsWith('operator') && !initialize && !singleton) {
					this.ruleHelpers.continueString();
					this.token.value += v;

					return;
				}
				if(singleton) {
					this.addToken(this.token.type);

					return;
				}

				let type = 'operator';

				if(
					['string', 'identifier'].includes(this.token.type) ||
					this.token.type.endsWith('Closed') ||
					this.token.type.startsWith('number') ||
					this.token.type.startsWith('keyword')
				) {
					type += 'Postfix';
				}

				this.ruleHelpers.specifyOperatorType();
				this.addToken(type);
			}],
			['\'', (v) => {
				if(this.atCommentLevel) {
					this.token.value += v;

					return;
				}

				if(!this.atStringLevel) {
					this.ruleHelpers.specifyOperatorType();
					this.addToken('stringOpen');
					this.levels.string++;
				} else {
					this.addToken('stringClosed');
					this.levels.string--;
				}
			}],
			[/\s|;/, (v) => {
				if(this.atCommentLevel || this.atStringLevel) {
					if(v === '\n' && this.token.type === 'commentLine') {
						this.addToken('delimiter');
						this.levels.comment--;
					} else {
						this.ruleHelpers.continueString();
						this.token.value += v;
					}

					return;
				}

				if(this.token.type !== 'delimiter') {
					this.addToken('delimiter');
				} else {
					this.token.value += v;
				}
			}],
			[/[0-9]/, (v) => {
				if(this.atCommentLevel || this.atStringLevel || this.token.type.startsWith('number') || this.token.type === 'identifier') {
					this.ruleHelpers.continueString();
					this.token.value += v;

					return;
				}
				if(this.token.type === 'operatorPostfix' && this.token.value === '.' && this.getToken(-1).type === 'numberInteger') {
					this.removeToken();
					this.token.type = 'numberFloat';
					this.token.value += '.'+v;

					return;
				}

				this.ruleHelpers.specifyOperatorType();
				this.addToken('numberInteger');
			}],
			[/[a-z_]/i, (v) => {
				if(this.atCommentLevel || this.atStringLevel) {
					this.ruleHelpers.continueString();
					this.token.value += v;

					return;
				}

				if(this.token.type !== 'identifier' && !this.token.type.startsWith('keyword')) {
					this.ruleHelpers.specifyOperatorType();
					this.addToken('identifier', '');
				}
				this.token.value += v;

				let keywords = [
					// Flow-related words (async, class, for, return...)
					// Literals (false, nil, true...)
					// Types (Any, bool, _, ...)

					// Words as Self, arguments, metaSelf or self are not allowed because they all
					// have dynamic values and it's logical to distinguish them at the interpretation stage

					'Any',
					'Class',
					'Enumeration',
					'Function',
					'Namespace',
					'Object',
					'Protocol',
					'Structure',
					'any', 'async', 'await',
					'bool', 'break',
					'case', 'catch', 'class', 'continue',
					'default', 'do',
					'else', 'enum', 'extension',
					'false', 'final', 'float', 'for', 'func',
					'if', 'import', 'in', 'infix', 'int', 'is',
					'lazy',
					'namespace', 'nil',
					'operator',
					'postfix', 'prefix', 'private', 'protected', 'protocol', 'public',
					'return',
					'static', 'string', 'struct', 'switch',
					'throw', 'true', 'try',
					'var',
					'while',
					'_'
				]

				if(keywords.includes(this.token.value)) {
					this.token.type = 'keyword';

					if(this.token.value === '_') {
						this.token.type += 'Underscore';

						return;
					}

					let value = this.token.value[0].toUpperCase()+this.token.value.slice(1);

					this.token.type += this.token.value[0] === value[0] ? 'Capital'+value : value;
				} else {
					this.token.type = 'identifier';
				}
			}],
			[/.|\n/i, (v) => {
				if(this.token.type === 'commentBlock' || this.token.type === 'commentLine' && v !== '\n' || this.atStringLevel) {
					this.ruleHelpers.continueString();
					this.token.value += v;

					return;
				}

				this.ruleHelpers.reportSkip(v);
			}]
		]

		static ruleHelpers = {
			continueString: () => {
				if(['stringOpen', 'stringExpressionClosed'].includes(this.token.type)) {
					this.addToken('stringSegment', '');
				}
			},
			specifyOperatorType: () => {
				switch(this.token.type) {
					case 'operator':		this.token.type = 'operatorPrefix';	break;
					case 'operatorPostfix':	this.token.type = 'operatorInfix';	break;
				}
			},
			reportSkip: (v) => {
				this.report(0, 'No token of an appropriate type was created before to accept this character and it doesn\'t represent any possible type independently: "'+v+'", skipping...');
			}
		}

		static get token() {
			return this.getToken();
		}

		static get atCommentLevel() {
			return this.levels.comment > 0;
		}

		static get atStringLevel() {
			return this.levels.string > this.levels.stringExpression;
		}

		static get atStringExpressionLevel() {
			return this.levels.string > 0 && this.levels.string === this.levels.stringExpression;
		}

		static atPattern(pattern, offset = 0) {
			for(let i = pattern.length-1; i >= 0; i--) {
				let condition = pattern[i]

				if(
					condition.type != null && !condition.type.test(this.getToken(offset).type) ||
					condition.value != null && !condition.value.test(this.getToken(offset).value)
				) {
					if(!condition.optional) {
						return false;
					} else {
						continue;
					}
				}

				offset--;
			}

			return true;
		}

		static getToken(offset = 0) {
			return this.tokens[this.tokens.length-1+offset] ?? {
				position: undefined,
				location: undefined,
				type: '',
				value: ''
			}
		}

		static addToken(type, value) {
			this.tokens.push({
				position: this.position,
				location: {...this.location},
				type: type,
				value: value ?? this.code[this.position]
			});
		}

		static removeToken(offset = 0) {
			this.tokens = this.tokens.filter((v, k) => k !== this.tokens.length-1+offset);
		}

		static report(level, string) {
			this.reports.push({
				level: level,
				location: {...this.location},
				string: string
			});
		}

		static reset() {
			this.code = undefined;
			this.position = undefined;
			this.location = {
				line: 0,
				column: 0
			}
			this.tokens = []
			this.levels = {
				comment: 0,
				string: 0,
				stringExpression: 0,
				parenthesis: 0,  // Could be mixed with stringExpression but cannot for readability reasons
				angle: 0
			}
			this.reports = []
		}

		static atPosition(substring) {
			return this.code.indexOf(substring, this.position) === this.position;
		}

		static tokenize(code) {
			this.reset();

			this.code = code;

			for(this.position = 0; this.position < this.code.length; this.position++) {
				for(let rule of this.rules) {
					let triggers = rule[0],
						actions = rule[1],
						plain = typeof triggers === 'string',
						array = Array.isArray(triggers),
						regex = triggers instanceof RegExp,
						trigger;

					if(plain && this.atPosition(triggers)) {
						trigger = triggers;
					}
					if(array) {
						trigger = triggers.find(v => this.atPosition(v));
					}
					if(regex && triggers.test(this.code[this.position])) {
						trigger = this.code[this.position]
					}

					if(trigger != null && !actions(trigger)) {
						this.position += trigger.length-1;

						for(let character of trigger) {
							if(character === '\n') {
								this.location.line++;
								this.location.column = 0;
							} else {
								this.location.column++;
							}
						}

						break;
					}
				}
			}

			let result = {
				rawTokens: this.tokens,
				tokens: this.tokens.filter(v => !v.type.startsWith('comment') && v.type !== 'delimiter'),
				reports: this.reports
			}

			this.reset();

			return result;
		}
	}

	class Parser {
		static tokens;
		static position;
		static reports;

		static rules = {
			anyType: () => {
				let node = {
					type: 'anyType',
					range: {},
					value: undefined
				}

				if(this.token.type !== 'keywordUnderscore') {
					return;
				}

				node.value = this.token.value;
				node.range.start =
				node.range.end = this.position++;

				return node;
			},
			argument: () => {
				let node = {
					type: 'argument',
					range: {
						start: this.position
					},
					label: this.rules.identifier(),
					value: undefined
				}

				if(node.label != null && this.token.type.startsWith('operator') && this.token.value === ':') {
					this.position++;
				} else {
					this.position = node.range.start;
					node.label = undefined;
				}

				node.value = this.rules.expressionsSequence();
				if(node.label == null && node.value == null) {
					return;
				}

				node.range.end = this.position-1;

				return node;
			},
			arrayLiteral: () => {
				let node = {
					type: 'arrayLiteral',
					range: {},
					values: []
				}

				if(this.token.type !== 'bracketOpen') {
					return;
				}

				node.range.start = this.position++;
				node.values = this.ruleHelpers.sequentialNodes(
					['expressionsSequence'],
					() => this.token.type.startsWith('operator') && this.token.value === ','
				);

				if(this.token.type !== 'bracketClosed') {
					this.position = node.range.start;

					return;
				}

				node.range.end = this.position++;

				return node;
			},
			arrayType: () => {
				let node = {
					type: 'arrayType',
					range: {},
					value: undefined
				}

				if(this.token.type !== 'bracketOpen') {
					return;
				}

				node.range.start = this.position++;
				node.value = this.rules.type();

				if(this.token.type !== 'bracketClosed') {
					this.position--;

					return;
				}

				node.range.end = this.position++;

				return node;
			},
			awaitExpression: () => {
				let node = {
					type: 'awaitExpression',
					range: {},
					value: undefined
				}

				if(this.token.type !== 'keywordAwait') {
					return;
				}

				node.range.start = this.position++;
				node.value = this.rules.expression();

				if(node.value == null) {
					this.position--;

					return;
				}

				node.range.end = node.value.range.end;

				return node;
			},
			body: (type) => {
				let node = {
					type: type+'Body',
					range: {},
					statements: []
				}

				if(this.token.type !== 'braceOpen') {
					return;
				}

				node.range.start = this.position++;
				node.statements = this.rules[type+'Statements']?.();

				if(node.statements.length === 0) {
					this.report(0, node.range.start, 'Body is empty.');
				}

				if(!this.tokensEnd) {
					node.range.end = this.position++;
				} else {
					node.range.end = this.position-1;

					this.report(1, node.range.start, 'Body doesn\'t have the closing brace and was decided to be autoclosed at the end of stream.');
				}

				return node;
			},
			booleanLiteral: () => {
				let node = {
					type: 'booleanLiteral',
					range: {},
					value: undefined
				}

				if(!['keywordFalse', 'keywordTrue'].includes(this.token.type)) {
					return;
				}

				node.value = this.token.value;
				node.range.start =
				node.range.end = this.position++;

				return node;
			},
			callExpression: (node_) => {
				let node = {
					type: 'callExpression',
					range: {
						start: node_.range.start
					},
					callee: node_,
					genericArguments: [],
					arguments: []
				}

				if(this.token.type.startsWith('operator') && this.token.value === '<') {
					this.position++;
					node.genericArguments = this.ruleHelpers.sequentialNodes(
						['type'],
						() => this.token.type.startsWith('operator') && this.token.value === ','
					);

					if(this.token.type.startsWith('operator') && this.token.value === '>') {
						this.position++;
					} else {
						this.position = node_.range.end+1;
					}
				}

				if(this.token.type !== 'parenthesisOpen') {
					this.position = node_.range.end+1;

					return;
				}

				this.position++;
				node.arguments = this.ruleHelpers.skippableNodes(
					['argument'],
					() => this.token.type === 'parenthesisOpen',
					() => this.token.type === 'parenthesisClosed',
					() => this.token.type.startsWith('operator') && this.token.value === ','
				);

				if(this.token.type === 'parenthesisClosed') {
					node.range.end = this.position++;
				} else {
					node.range.end = this.position-1;

					this.report(1, node.range.start, 'Call expression doesn\'t have the closing parenthesis and was decided to be autoclosed at the end of stream.');
				}

				return node;
			},
			caseDeclaration: () => {},
			chainExpression: (node_) => {
				let node = {
					type: 'chainExpression',
					range: {
						start: node_.range.start
					},
					composite: node_,
					member: undefined
				}

				if(!['operatorPrefix', 'operatorInfix'].includes(this.token.type) || this.token.value !== '.') {
					return;
				}

				this.position++;
				node.member =
					this.rules.identifier() ??
					this.rules.stringLiteral();

				if(node.member == null) {
					this.position = node_.range.end+1;

					return;
				}

				node.range.end = node.member.range.end;

				return node;
			},
			chainIdentifier: (node_) => {
				let node = {
					type: 'chainIdentifier',
					range: {
						start: node_.range.start
					},
					supervalue: node_,
					value: undefined
				}

				if(!['operatorPrefix', 'operatorInfix'].includes(this.token.type) || this.token.value !== '.') {
					return;
				}

				this.position++;
				node.value = this.rules.identifier();

				if(node.value == null) {
					this.position = node_.range.end+1;

					return;
				}

				node.range.end = node.value.range.end;

				return node;
			},
			classBody: () => {
				return this.rules.body('class');
			},
			classDeclaration: (anonymous) => {
				let node = {
					type: 'class'+(!anonymous ? 'Declaration' : 'Expression'),
					range: {
						start: this.position
					},
					modifiers: this.rules.modifiers(),
					identifier: undefined,
					inheritance: undefined,
					body: undefined
				}

				if(this.token.type !== 'keywordClass') {
					this.position = node.range.start;

					return;
				}

				node.range.end = this.position++;
				node.identifier = this.rules.identifier();

				if(anonymous) {
					if(node.modifiers != null || node.identifier != null) {
						this.position = node.range.start;

						return;
					}

					delete node.modifiers;
					delete node.identifier;
				} else
				if(node.identifier == null) {
					this.report(2, node.range.start, 'No identifier set for class declaration.');
				}
				if(node.modifiers?.values.some(v => !['private', 'protected', 'public', 'static', 'final'].includes(v))) {
					this.report(1, node.range.start, 'Wrong modifier(s) set for class.');
				}

				node.inheritance = this.rules.inheritance();
				node.body = this.rules.classBody();

				if(node.body == null) {
					this.report(0, node.range.start, 'Class doesn\'t have body.');
				}

				node.range.end = this.position-1;

				return node;
			},
			classExpression: () => {
				return this.rules.classDeclaration(true);
			},
			classStatements: () => {
				return this.rules.statements([
					'classDeclaration',
					'enumerationDeclaration',
					'functionDeclaration',
					'namespaceDeclaration',
					'protocolDeclaration',
					'structureDeclaration',
					'variableDeclaration'
				]);
			},
			compositeType: () => {
				let node = {
					type: 'compositeType',
					range: {},
					value: undefined
				}

				if(![
					'keywordCapitalAny',
					'keywordCapitalClass',
					'keywordCapitalEnumeration',
					'keywordCapitalFunction',
					'keywordCapitalNamespace',
					'keywordCapitalObject',
					'keywordCapitalProtocol',
					'keywordCapitalStructure'
				].includes(this.token.type)) {
					return;
				}

				node.value = this.token.value;
				node.range.start =
				node.range.end = this.position++;

				return node;
			},
			conditionalOperator: () => {
				let node = {
					type: 'conditionalOperator',
					range: {},
					expression: undefined
				}

				if(!this.token.type.startsWith('operator') || this.token.value !== '?') {
					return;
				}

				node.range.start = this.position++;
				node.expression = this.rules.expressionsSequence();

				if(!this.token.type.startsWith('operator') || this.token.value !== ':') {
					this.position = node.range.start;

					return;
				}

				node.range.end = this.position++;

				return node;
			},
			controlTransferStatement: () => {
				let node =
				//	this.rules.breakStatement() ??
				//	this.rules.continueStatement() ??
				//	this.rules.fallthroughStatement() ??
					this.rules.returnStatement() ??
					this.rules.throwStatement();

				return node;
			},
			declaration: () => {
				let node =
					this.rules.classDeclaration() ??
					this.rules.enumerationDeclaration() ??
					this.rules.functionDeclaration() ??
					this.rules.importDeclaration() ??
					this.rules.namespaceDeclaration() ??
					this.rules.operatorDeclaration() ??
					this.rules.protocolDeclaration() ??
					this.rules.structureDeclaration() ??
					this.rules.variableDeclaration();

				return node;
			},
			declarator: () => {
				let node = {
					type: 'declarator',
					range: {
						start: this.position
					},
					identifier: this.rules.identifier(),
					type_: undefined,
					value: undefined
				}

				if(node.identifier == null) {
					return;
				}

				if(this.token.type.startsWith('operator') && this.token.value === ':') {
					this.position++;
					node.type_ = this.rules.type();
				}

				if(this.token.type.startsWith('operator') && this.token.value === '=') {
					this.position++;
					node.value = this.rules.expressionsSequence();
				}

				node.range.end = this.position-1;

				return node;
			},
			defaultExpression: (node_) => {
				let node = {
					type: 'defaultExpression',
					range: {
						start: node_.range.start
					},
					value: node_
				}

				if(this.token.type !== 'operatorPostfix' || this.token.value !== '!') {
					return;
				}

				node.range.end = this.position++;

				return node;
			},
			defaultType: (node_) => {
				let node = {
					type: 'defaultType',
					range: {
						start: node_.range.start
					},
					value: node_
				}

				if(this.token.type !== 'operatorPostfix' || this.token.value !== '!') {
					return;
				}

				node.range.end = this.position++;

				return node;
			},
			dictionaryLiteral: () => {
				let node = {
					type: 'dictionaryLiteral',
					range: {},
					entries: []
				}

				if(this.token.type !== 'bracketOpen') {
					return;
				}

				node.range.start = this.position++;
				node.entries = this.ruleHelpers.sequentialNodes(
					['entry'],
					() => this.token.type.startsWith('operator') && this.token.value === ','
				);

				if(node.entries.length === 0 && this.token.type.startsWith('operator') && this.token.value === ':') {
					this.position++;
				}

				if(this.token.type === 'bracketClosed') {
					node.range.end = this.position++;
				} else {
					this.position = node.range.start;

					return;
				}

				return node;
			},
			dictionaryType: () => {
				let node = {
					type: 'dictionaryType',
					range: {},
					key: undefined,
					value: undefined
				}

				if(this.token.type !== 'bracketOpen') {
					return;
				}

				node.range.start = this.position++;
				node.key = this.rules.type();

				if(!this.token.type.startsWith('operator') || this.token.value !== ':') {
					this.position--;

					return;
				}

				this.position++;
				node.value = this.rules.type();

				if(this.token.type !== 'bracketClosed') {
					this.position = node.range.start;

					return;
				}

				node.range.end = this.position++;

				return node;
			},
			entry: () => {
				let node = {
					type: 'entry',
					range: {
						start: this.position
					},
					key: this.rules.expressionsSequence(),
					value: undefined
				}
				if(node.key == null || !this.token.type.startsWith('operator') || this.token.value !== ':') {
					this.position = node.range.start;

					return;
				}

				this.position++;
				node.value = this.rules.expressionsSequence();

				if(node.value == null) {
					this.position = node.range.start;

					return;
				}

				node.range.end = node.value.range.end;

				return node;
			},
			enumerationBody: () => {
				return this.rules.body('enumeration');
			},
			enumerationDeclaration: (anonymous) => {
				let node = {
					type: 'enumeration'+(!anonymous ? 'Declaration' : 'Expression'),
					range: {
						start: this.position
					},
					modifiers: this.rules.modifiers(),
					identifier: undefined,
					inheritance: undefined,
					body: undefined
				}

				if(this.token.type !== 'keywordEnum') {
					this.position = node.range.start;

					return;
				}

				node.range.end = this.position++;
				node.identifier = this.rules.identifier();

				if(anonymous) {
					if(node.identifier != null) {
						this.position = node.range.start;

						return;
					} else {
						delete node.identifier;
					}
				} else
				if(node.identifier == null) {
					this.report(2, node.range.start, 'No identifier set for enumeration declaration.');
				}
				if(node.modifiers?.values.some(v => !['private', 'protected', 'public', 'static', 'final'].includes(v))) {
					this.report(1, node.range.start, 'Wrong modifier(s) set for enumeration.');
				}

				node.inheritance = this.rules.inheritance();
				node.body = this.rules.enumerationBody();

				if(node.body == null) {
					this.report(0, node.range.start, 'Enumeration doesn\'t have body.');
				}

				node.range.end = this.position-1;

				return node;
			},
			enumerationExpression: () => {
				return this.rules.enumerationDeclaration(true);
			},
			enumerationStatements: () => {
				return this.rules.statements(['caseDeclaration']);
			},
			expression: () => {
				let node =
					this.rules.awaitExpression() ??
					this.rules.tryExpression() ??
					this.rules.prefixExpression();

				return node;
			},
			expressionsSequence: () => {
				let node = {
					type: 'expressionsSequence',
					range: {
						start: this.position
					},
					values: []
				}

				let subsequentialTypes = ['inOperator', 'isOperator']

				node.values = this.ruleHelpers.sequentialNodes(['expression', 'infixExpression'], undefined, subsequentialTypes);

				if(node.values.length === 0) {
					return;
				}
				if(node.values.filter(v => !subsequentialTypes.includes(v.type)).length%2 === 0) {
					this.position = node.values.at(-1).range.start;

					node.values.pop();
				}
				if(node.values.length === 1) {
					return node.values[0]
				}

				node.range.end = node.values.at(-1).range.end;

				return node;
			},
			floatLiteral: () => {
				let node = {
					type: 'floatLiteral',
					range: {},
					value: undefined
				}

				if(this.token.type !== 'numberFloat') {
					return;
				}

				node.value = this.token.value;
				node.range.start =
				node.range.end = this.position++;

				return node;
			},
			forStatement: () => {},
			functionBody: () => {
				return this.rules.body('function');
			},
			functionDeclaration: (anonymous) => {
				let node = {
					type: 'function'+(!anonymous ? 'Declaration' : 'Expression'),
					range: {
						start: this.position
					},
					modifiers: this.rules.modifiers(),
					identifier: undefined,
					signature: undefined,
					body: undefined
				}

				if(this.token.type !== 'keywordFunc') {
					this.position = node.range.start;

					return;
				}

				node.range.end = this.position++;
				node.identifier =
					this.rules.identifier() ??
					this.rules.operator();

				if(anonymous) {
					if(node.modifiers != null || node.identifier != null) {
						this.position = node.range.start;

						return;
					}

					delete node.modifiers;
					delete node.identifier;
				} else
				if(node.identifier == null) {
					this.report(2, node.range.start, 'No identifier set for function declaration.');
				}

				node.signature = this.rules.functionSignature();
				node.body = this.rules.functionBody();

				if(node.signature == null) {
					this.report(2, node.range.start, 'Function lacks of signature.');
				}
				if(node.body == null) {
					this.report(0, node.range.start, 'Function doesn\'t have body.');
				}

				node.range.end = this.position-1;

				return node;
			},
			functionExpression: () => {
				return this.rules.functionDeclaration(true);
			},
			functionSignature: () => {
				let node = {
					type: 'functionSignature',
					range: {
						start: this.position
					},
					genericParameters: [],
					parameters: [],
					asynchronous: false,
					throws: false,
					return: undefined
				}

				if(this.token.type.startsWith('operator') && this.token.value === '<') {
					this.position++;
					node.genericParameters = this.ruleHelpers.skippableNodes(
						['genericParameter'],
						() => this.token.type.startsWith('operator') && this.token.value === '<',
						() => this.token.type.startsWith('operator') && this.token.value === '>',
						() => this.token.type.startsWith('operator') && this.token.value === ','
					);

					if(this.token.type.startsWith('operator') && this.token.value === '>') {
						this.position++;
					} else {
						node.range.end = this.position-1;

						this.report(1, node.range.start, 'Function signature\'s generic parameters doesn\'t have the closing angle and decided to be autoclosed at the end of stream.');

						return node;
					}
				}
				if(this.token.type === 'parenthesisOpen') {
					this.position++;
					node.parameters = this.ruleHelpers.skippableNodes(
						['parameter'],
						() => this.token.type === 'parenthesisOpen',
						() => this.token.type === 'parenthesisClosed',
						() => this.token.type.startsWith('operator') && this.token.value === ','
					);

					if(this.token.type === 'parenthesisClosed') {
						this.position++;
					} else {
						node.range.end = this.position-1;

						this.report(1, node.range.start, 'Function signature\'s parameters don\'t have the closing parenthesis and were decided to be autoclosed at the end of stream.');

						return node;
					}
				}

				while(['keywordAsync', 'keywordThrows'].includes(this.token.type)) {
					if(this.token.type === 'keywordAsync') {
						this.position++;
						node.asynchronous = true;

						if(this.token.type === 'operatorPostfix' && this.token.value === '?') {
							this.position++;
							node.asynchronous = undefined;
						}
					}
					if(this.token.type === 'keywordThrows') {
						this.position++;
						node.throws = true;

						if(this.token.type === 'operatorPostfix' && this.token.value === '?') {
							this.position++;
							node.throws = undefined;
						}
					}
				}

				if(this.token.type.startsWith('operator') && this.token.value === '->') {
					this.position++;
					node.return = this.rules.type();
				}

				node.range.end = this.position-1;

				return node;
			},
			functionStatements: () => {
				return this.rules.statements([
					'expressionsSequence',  // Expressions must be parsed first as they may include (anonymous) declarations
					'declaration',
					'controlTransferStatement',
					'forStatement',
					'ifStatement',
					'whileStatement'
				]);
			},
			genericParameter: () => {
				let node = {
					type: 'genericParameter',
					range: {
						start: this.position
					},
					identifier: this.rules.identifier(),
					type_: undefined
				}

				if(node.identifier == null) {
					return;
				}

				node.range.end = node.identifier.range.end;

				if(!this.token.type.startsWith('operator') || this.token.value !== ':') {
					return node;
				}

				this.position++;
				node.type_ = this.rules.type();

				if(node.type_ == null) {
					this.position--;

					return node;
				}

				node.range.end = node.type_.range.end;

				return node;
			},
			identifier: () => {
				let node = {
					type: 'identifier',
					range: {},
					value: undefined
				}

				if(this.token.type !== 'identifier') {
					return;
				}

				node.value = this.token.value;
				node.range.start =
				node.range.end = this.position++;

				return node;
			},
			ifStatement: () => {},
			implicitChainExpression: () => {
				let node = {
					type: 'implicitChainExpression',
					range: {},
					member: undefined
				}

				if(this.token.type !== 'operatorPrefix' || this.token.value !== '.') {
					return;
				}

				node.range.start = this.position++;
				node.member =
					this.rules.identifier() ??
					this.rules.stringLiteral();

				if(node.member == null) {
					this.position--;

					return;
				}

				node.range.end = node.member.range.end;

				return node;
			},
			implicitChainIdentifier: () => {
				let node = {
					type: 'implicitChainIdentifier',
					range: {},
					value: undefined
				}

				if(this.token.type !== 'operatorPrefix' || this.token.value !== '.') {
					return;
				}

				node.range.start = this.position++;
				node.value = this.rules.identifier();

				if(node.value == null) {
					this.position--;

					return;
				}

				node.range.end = node.value.range.end;

				return node;
			},
			importDeclaration: () => {
				let node = {
					type: 'importDeclaration',
					range: {},
					value: undefined
				}

				if(this.token.type !== 'keywordImport') {
					return;
				}

				node.range.start =
				node.range.end = this.position++;
				node.value = this.rules.identifier();

				while(!this.tokensEnd) {
					let node_ = this.rules.chainIdentifier(node.value);

					if(node_ == null) {
						break;
					}

					node.value = node_;
				}

				if(node.value == null) {
					this.report(1, node.range.start, 'Import declaration doesn\'t have value.');
				}

				node.range.end =
					node.value?.range.end ??
					node.range.end;

				return node;
			},
			infixExpression: () => {
				let node =
					this.rules.conditionalOperator() ??
					this.rules.inOperator() ??
					this.rules.isOperator() ??
					this.rules.infixOperator();

				return node;
			},
			infixOperator: () => {
				let node = {
					type: 'infixOperator',
					range: {},
					value: undefined
				}

				let exceptions = [',', ':']  // Enclosing nodes can use operators from the list as delimiters

				if(!['operator', 'operatorInfix'].includes(this.token.type) || exceptions.includes(this.token.value)) {
					return;
				}

				node.value = this.token.value;
				node.range.start =
				node.range.end = this.position++;

				return node;
			},
			inheritance: () => {
				let node = {
					type: 'inheritance',
					range: {},
					types: []
				}

				if(!this.token.type.startsWith('operator') || this.token.value !== ':') {
					return;
				}

				node.range.start = this.position++;
				node.types = this.ruleHelpers.sequentialNodes(
					['typeReference'],
					() => this.token.type.startsWith('operator') && this.token.value === ','
				);

				if(node.types.length === 0) {
					this.position--;

					return;
				}

				node.range.end = node.types.at(-1).range.end;

				return node;
			},
			inOperator: () => {
				let node = {
					type: 'inOperator',
					range: {
						start: this.position
					},
					negatiated: false,
					composite: undefined
				}

				if(this.token.type === 'operatorPrefix' && this.token.value === '!') {
					this.position++;
					node.negatiated = true;
				}

				if(this.token.type !== 'keywordIn') {
					this.position = node.range.start;

					return;
				}

				this.position++;
				node.composite = this.rules.expressionsSequence();

				if(node.composite == null) {
					this.position = node.range.start;

					return;
				}

				node.range.end = this.position-1;

				return node;
			},
			inoutExpression: () => {
				let node = {
					type: 'inoutExpression',
					range: {},
					identifier: undefined
				}

				if(this.token.type !== 'operatorPrefix' || this.token.value !== '&') {
					return;
				}

				node.range.start = this.position++;
				node.identifier = this.rules.identifier();

				if(node.identifier == null) {
					this.position--;

					return;
				}

				node.range.end = node.identifier.range.end;

				return node;
			},
			integerLiteral: () => {
				let node = {
					type: 'integerLiteral',
					range: {},
					value: undefined
				}

				if(this.token.type !== 'numberInteger') {
					return;
				}

				node.value = this.token.value;
				node.range.start =
				node.range.end = this.position++;

				return node;
			},
			intersectionType: () => {
				let node = {
					type: 'intersectionType',
					range: {
						start: this.position
					},
					subtypes: this.ruleHelpers.sequentialNodes(
						['postfixType'],
						() => this.token.type.startsWith('operator') && this.token.value === '&'
					)
				}

				if(node.subtypes.length === 0) {
					return;
				}
				if(node.subtypes.length === 1) {
				//	this.position = node.subtypes[0].range.end+1;  // Allow trailing separator (enabled)

					return node.subtypes[0]
				}

				node.range.end = node.subtypes.at(-1).range.end;

				return node;
			},
			isOperator: () => {
				let node = {
					type: 'isOperator',
					range: {
						start: this.position
					},
					type_: undefined,
					negatiated: false
				}

				if(this.token.type === 'operatorPrefix' && this.token.value === '!') {
					this.position++;
					node.negatiated = true;
				}

				if(this.token.type !== 'keywordIs') {
					this.position = node.range.start;

					return;
				}

				this.position++;
				node.type_ = this.rules.type();

				if(node.type_ == null) {
					this.position = node.range.start;

					return;
				}

				node.range.end = this.position-1;

				return node;
			},
			literalExpression: () => {
				let node =
					this.rules.arrayLiteral() ??
					this.rules.booleanLiteral() ??
					this.rules.dictionaryLiteral() ??
					this.rules.floatLiteral() ??
					this.rules.integerLiteral() ??
					this.rules.nilLiteral() ??
					this.rules.stringLiteral();

				return node;
			},
			modifiers: () => {
				let node = {
					type: 'modifiers',
					range: {
						start: this.position
					},
					values: []
				}

				while([
					'keywordInfix',
					'keywordPostfix',
					'keywordPrefix',
					'keywordPrivate',
					'keywordProtected',
					'keywordPublic',
					'keywordStatic',
					'keywordLazy',
					'keywordFinal'
				].includes(this.token.type)) {
					node.values.push(this.token.value);
					node.range.end = this.position++;
				}

				if(node.values.length === 0) {
					return;
				}

				return node;
			},
			module: () => {
				let node = {
					type: 'module',
					range: {
						start: 0,
						end: 0
					},
					statements: this.rules.functionStatements()
				}

				if(node.statements.length > 0) {
					node.range.start = node.statements[0].range.start;
					node.range.end = node.statements.at(-1).range.end;
				}

				return node;
			},
			namespaceBody: () => {
				return this.rules.body('namespace');
			},
			namespaceDeclaration: (anonymous) => {
				let node = {
					type: 'namespace'+(!anonymous ? 'Declaration' : 'Expression'),
					range: {
						start: this.position
					},
					modifiers: this.rules.modifiers(),
					identifier: undefined,
					body: undefined
				}

				if(this.token.type !== 'keywordNamespace') {
					this.position = node.range.start;

					return;
				}

				node.range.end = this.position++;
				node.identifier = this.rules.identifier();

				if(anonymous) {
					if(node.modifiers != null || node.identifier != null) {
						this.position = node.range.start;

						return;
					}

					delete node.modifiers;
					delete node.identifier;
				} else
				if(node.identifier == null) {
					this.report(2, node.range.start, 'No identifier set for namespace declaration.');
				}
				if(node.modifiers?.values.some(v => !['private', 'protected', 'public', 'static', 'final'].includes(v))) {
					this.report(1, node.range.start, 'Wrong modifier(s) set for namespace.');
				}

				node.body = this.rules.namespaceBody();

				if(node.body == null) {
					this.report(0, node.range.start, 'Namespace doesn\'t have body.');
				}

				node.range.end = this.position-1;

				return node;
			},
			namespaceExpression: () => {
				return this.rules.namespaceDeclaration(true);
			},
			namespaceStatements: () => {
				return this.rules.statements(['declaration']);
			},
			nillableExpression: (node_) => {
				let node = {
					type: 'nillableExpression',
					range: {
						start: node_.range.start
					},
					value: node_
				}

				if(this.token.type !== 'operatorPostfix' || this.token.value !== '?') {
					return;
				}

				node.range.end = this.position++;

				return node;
			},
			nillableType: (node_) => {
				let node = {
					type: 'nillableType',
					range: {
						start: node_.range.start
					},
					value: node_
				}

				if(this.token.type !== 'operatorPostfix' || this.token.value !== '?') {
					return;
				}

				node.range.end = this.position++;

				return node;
			},
			nilLiteral: () => {
				let node = {
					type: 'nilLiteral',
					range: {}
				}

				if(this.token.type !== 'keywordNil') {
					return;
				}

				node.range.start =
				node.range.end = this.position++;

				return node;
			},
			operator: () => {
				let node = {
					type: 'operator',
					range: {},
					value: undefined
				}

				if(!this.token.type.startsWith('operator')) {
					return;
				}

				node.value = this.token.value;
				node.range.start =
				node.range.end = this.position++;

				return node;
			},
			operatorBody: () => {
				return this.rules.body('operator');
			},
			operatorDeclaration: () => {
				let node = {
					type: 'operatorDeclaration',
					range: {
						start: this.position
					},
					modifiers: this.rules.modifiers(),
					operator: undefined,
					body: undefined
				}

				if(this.token.type !== 'keywordOperator') {
					this.position = node.range.start;

					return;
				}

				node.range.end = this.position++;
				node.operator = this.rules.operator();
				node.body = this.rules.operatorBody();

				if(node.operator == null) {
					this.report(2, node.range.start, 'No operator set for operator declaration.');
				}
				if(!node.modifiers?.values.some(v => ['infix', 'postfix', 'prefix'].includes(v))) {
					this.report(2, node.range.start, 'Operator declaration should have specific modifier (infix, postfix, prefix).');
				}
				if(node.body == null) {
					this.report(0, node.range.start, 'Operator doesn\'t have body.');
				} else {
					for(let entry of node.body.statements.filter(v => v.type === 'entry')) {
						if(entry.key.type !== 'identifier' || !['associativity', 'precedence'].includes(entry.key.value)) {
							this.report(1, entry.range.start, 'Operator body should have only identifiers as keys (associativity, precedence).');
						} else {
							if(entry.key.value === 'associativity') {
								if(entry.value.type !== 'identifier') {
									this.report(2, entry.range.start, 'Operator associativity value should be identifier.');
								}
								if(!['left', 'right', 'none'].includes(entry.value.value)) {
									this.report(2, entry.range.start, 'Operator associativity accepts only one of following values: left, right, none.');
								}
							}
							if(entry.key.value === 'precedence' && entry.value.type !== 'integerLiteral') {
								this.report(2, entry.range.start, 'Operator precedence value should be integer.');
							}
						}
					}
				}

				node.range.end = this.position-1;

				return node;
			},
			operatorStatements: () => {
				return this.rules.statements(['entry']);
			},
			parameter: () => {},
			parenthesizedExpression: () => {
				let node = {
					type: 'parenthesizedExpression',
					range: {},
					value: undefined
				}

				if(this.token.type !== 'parenthesisOpen') {
					return;
				}

				node.range.start = this.position++;
				node.value = this.ruleHelpers.skippableNode(
					'expressionsSequence',
					() => this.token.type === 'parenthesisOpen',
					() => this.token.type === 'parenthesisClosed'
				);

				if(this.token.type === 'parenthesisClosed') {
					node.range.end = this.position++;
				} else
				if(this.tokensEnd) {
					node.range.end = this.position-1;

					this.report(1, node.range.start, 'Parenthesized expression doesn\'t have the closing parenthesis and was decided to be autoclosed at the end of stream.');
				} else {
					this.position = node.range.start;

					return;
				}

				return node;
			},
			parenthesizedType: () => {
				let node = {
					type: 'parenthesizedType',
					range: {},
					value: undefined
				}

				if(this.token.type !== 'parenthesisOpen') {
					return;
				}

				node.range.start = this.position++;
				node.value = this.rules.type();

				if(this.token.type !== 'parenthesisClosed') {
					this.position = node.range.start;

					return;
				}

				node.range.end = this.position++;

				return node;
			},
			postfixExpression: () => {
				let node = {
					type: 'postfixExpression',
					range: {
						start: this.position
					},
					value: this.rules.primaryExpression(),
					operator: undefined
				}

				if(node.value == null) {
					return;
				}

				while(!this.tokensEnd) {
					let node_ =
						this.rules.callExpression(node.value) ??
						this.rules.chainExpression(node.value) ??
						this.rules.defaultExpression(node.value) ??
						this.rules.nillableExpression(node.value) ??
						this.rules.subscriptExpression(node.value);

					if(node_ == null) {
						break;
					}

					node.value = node_;
				}

				node.operator = this.rules.postfixOperator();

				if(node.operator == null) {
					return node.value;
				}

				node.range.end = node.operator.range.end;

				return node;
			},
			postfixOperator: () => {
				let node = {
					type: 'postfixOperator',
					range: {},
					value: undefined
				}

				let exceptions = [',', ':']  // Enclosing nodes can use trailing operators from the list

				if(this.token.type !== 'operatorPostfix' || exceptions.includes(this.token.value)) {
					return;
				}

				node.value = this.token.value;
				node.range.start =
				node.range.end = this.position++;

				return node;
			},
			postfixType: () => {
				let node = this.rules.primaryType();

				if(node == null) {
					return;
				}

				while(!this.tokensEnd) {
					let node_ =
						this.rules.defaultType(node) ??
						this.rules.nillableType(node);

					if(node_ == null) {
						break;
					}

					node = node_;
				}

				return node;
			},
			prefixExpression: () => {
				let node = {
					type: 'prefixExpression',
					range: {
						start: this.position
					},
					operator: this.rules.prefixOperator(),
					value: undefined
				}

				node.value = this.rules.postfixExpression();

				if(node.value == null) {
					this.position = node.range.start;

					return;
				}
				if(node.operator == null) {
					return node.value;
				}

				node.range.end = node.value.range.end;

				return node;
			},
			prefixOperator: () => {
				let node = {
					type: 'prefixOperator',
					range: {},
					value: undefined
				}

				let exceptions = ['&', '.']  // primaryExpressions can start with operators from the list

				if(this.token.type !== 'operatorPrefix' || exceptions.includes(this.token.value)) {
					return;
				}

				node.value = this.token.value;
				node.range.start =
				node.range.end = this.position++;

				return node;
			},
			primaryExpression: () => {
				let node =
					this.rules.classExpression() ??
					this.rules.enumerationExpression() ??
					this.rules.functionExpression() ??
					this.rules.identifier() ??
					this.rules.implicitChainExpression() ??
					this.rules.inoutExpression() ??
					this.rules.literalExpression() ??
					this.rules.namespaceExpression() ??
					this.rules.parenthesizedExpression() ??
					this.rules.protocolExpression() ??
					this.rules.structureExpression();

				return node;
			},
			primaryType: () => {
				let node =
					this.rules.anyType() ??
					this.rules.arrayType() ??
					this.rules.compositeType() ??
					this.rules.dictionaryType() ??
				//	this.rules.functionType() ??
					this.rules.parenthesizedType() ??
					this.rules.primitiveType() ??
					this.rules.typeReference();

				return node;
			},
			primitiveType: () => {
				let node = {
					type: 'primitiveType',
					range: {},
					value: undefined
				}

				if(![
					'keywordAny',
					'keywordBool',
					'keywordFloat',
					'keywordInt',
					'keywordString'
				].includes(this.token.type)) {
					return;
				}

				node.value = this.token.value;
				node.range.start =
				node.range.end = this.position++;

				return node;
			},
			protocolBody: () => {
				return this.rules.body('protocol');
			},
			protocolDeclaration: (anonymous) => {
				let node = {
					type: 'protocol'+(!anonymous ? 'Declaration' : 'Expression'),
					range: {
						start: this.position
					},
					modifiers: this.rules.modifiers(),
					identifier: undefined,
					inheritance: undefined,
					body: undefined
				}

				if(this.token.type !== 'keywordProtocol') {
					this.position = node.range.start;

					return;
				}

				node.range.end = this.position++;
				node.identifier = this.rules.identifier();

				if(anonymous) {
					if(node.modifiers != null || node.identifier != null) {
						this.position = node.range.start;

						return;
					}

					delete node.modifiers;
					delete node.identifier;
				} else
				if(node.identifier == null) {
					this.report(2, node.range.start, 'No identifier set for protocol declaration.');
				}
				if(node.modifiers?.values.some(v => !['private', 'protected', 'public', 'static', 'final'].includes(v))) {
					this.report(1, node.range.start, 'Wrong modifier(s) set for protocol.');
				}

				node.inheritance = this.rules.inheritance();
				node.body = this.rules.protocolBody();

				if(node.body == null) {
					this.report(0, node.range.start, 'Protocol doesn\'t have body.');
				}

				node.range.end = this.position-1;

				return node;
			},
			protocolExpression: () => {
				return this.rules.protocolDeclaration(true);
			},
			protocolStatements: () => {
				return this.rules.statements([
					'classDeclaration',
					'enumerationDeclaration',
					'functionDeclaration',
					'namespaceDeclaration',
					'protocolDeclaration',
					'structureDeclaration',
					'variableDeclaration'
				]);
			},
			returnStatement: () => {
				let node = {
					type: 'returnStatement',
					range: {},
					value: undefined
				}

				if(this.token.type !== 'keywordReturn') {
					return;
				}

				node.range.start = this.position++;
				node.value = this.rules.expressionsSequence();
				node.range.end = this.position-1;

				return node;
			},
			statements: (types) => {
				return this.ruleHelpers.skippableNodes(
					types,
					() => this.token.type === 'braceOpen',
					() => this.token.type === 'braceClosed'
				);
			},
			stringExpression: () => {
				let node = {
					type: 'stringExpression',
					range: {},
					value: undefined
				}

				if(this.token.type !== 'stringExpressionOpen') {
					return;
				}

				node.range.start = this.position++;
				node.value = this.ruleHelpers.skippableNode(
					'expressionsSequence',
					() => this.token.type === 'stringExpressionOpen',
					() => this.token.type === 'stringExpressionClosed'
				);

				if(this.token.type === 'stringExpressionClosed') {
					node.range.end = this.position++;
				} else
				if(this.tokensEnd) {
					node.range.end = this.position-1;

					this.report(1, node.range.start, 'String expression doesn\'t have the closing parenthesis and was decided to be autoclosed at the end of stream.');
				} else {
					this.position = node.range.start;

					return;
				}

				return node;
			},
			stringLiteral: () => {
				let node = {
					type: 'stringLiteral',
					range: {},
					segments: []
				}

				if(this.token.type !== 'stringOpen') {
					return;
				}

				node.range.start = this.position++;
				node.segments = this.ruleHelpers.skippableNodes(
					['stringSegment', 'stringExpression'],
					() => this.token.type === 'stringOpen',
					() => this.token.type === 'stringClosed'
				);

				if(this.token.type === 'stringClosed') {
					node.range.end = this.position++;
				} else {
					node.range.end = this.position-1;

					this.report(1, node.range.start, 'String doesn\'t have the closing apostrophe and decided to be autoclosed at the end of stream.');
				}

				return node;
			},
			stringSegment: () => {
				let node = {
					type: 'stringSegment',
					range: {},
					value: undefined
				}

				if(this.token.type !== 'stringSegment') {
					return;
				}

				node.value = this.token.value;
				node.range.start =
				node.range.end = this.position++;

				return node;
			},
			structureBody: () => {
				return this.rules.body('structure');
			},
			structureDeclaration: (anonymous) => {
				let node = {
					type: 'structure'+(!anonymous ? 'Declaration' : 'Expression'),
					range: {
						start: this.position
					},
					modifiers: this.rules.modifiers(),
					identifier: undefined,
					inheritance: undefined,
					body: undefined
				}

				if(this.token.type !== 'keywordStruct') {
					this.position = node.range.start;

					return;
				}

				node.range.end = this.position++;
				node.identifier = this.rules.identifier();

				if(anonymous) {
					if(node.modifiers != null || node.identifier != null) {
						this.position = node.range.start;

						return;
					}

					delete node.modifiers;
					delete node.identifier;
				} else
				if(node.identifier == null) {
					this.report(2, node.range.start, 'No identifier set for structure declaration.');
				}
				if(node.modifiers?.values.some(v => !['private', 'protected', 'public', 'static', 'final'].includes(v))) {
					this.report(1, node.range.start, 'Wrong modifier(s) set for structure.');
				}

				node.inheritance = this.rules.inheritance();
				node.body = this.rules.structureBody();

				if(node.body == null) {
					this.report(0, node.range.start, 'Structure doesn\'t have body.');
				}

				node.range.end = this.position-1;

				return node;
			},
			structureExpression: () => {
				return this.rules.structureDeclaration(true);
			},
			structureStatements: () => {
				return this.rules.statements([
					'classDeclaration',
					'enumerationDeclaration',
					'functionDeclaration',
					'namespaceDeclaration',
					'protocolDeclaration',
					'structureDeclaration',
					'variableDeclaration'
				]);
			},
			subscriptExpression: (node_) => {
				let node = {
					type: 'subscriptExpression',
					range: {
						start: node_.range.start
					},
					composite: node_,
					arguments: undefined
				}

				if(this.token.type !== 'bracketOpen') {
					return;
				}

				this.position++;
				node.arguments = this.ruleHelpers.skippableNodes(
					['argument'],
					() => this.token.type === 'bracketOpen',
					() => this.token.type === 'bracketClosed',
					() => this.token.type.startsWith('operator') && this.token.value === ','
				);

				if(this.token.type === 'bracketClosed') {
					node.range.end = this.position++;
				} else {
					node.range.end = this.position-1;

					this.report(1, node.range.start, 'Subscript expression doesn\'t have the closing bracket and decided to be autoclosed at the end of stream.');
				}

				return node;
			},
			throwStatement: () => {
				let node = {
					type: 'throwStatement',
					range: {},
					value: undefined
				}

				if(this.token.type !== 'keywordThrow') {
					return;
				}

				node.range.start = this.position++;
				node.value = this.rules.expressionsSequence();
				node.range.end = this.position-1;

				return node;
			},
			tryExpression: () => {
				let node = {
					type: 'tryExpression',
					range: {},
					nillable: false,
					value: undefined
				}

				if(this.token.type !== 'keywordTry') {
					return;
				}

				node.range.start = this.position++;

				if(this.token.type === 'operatorPostfix' && this.token.value === '?') {
					node.nillable = true;
					node.range.end = this.position++;
				}

				node.value = this.rules.expression();

				if(node.value == null) {
					this.position = node.range.start;

					return;
				}

				node.range.end = node.value.range.end;

				return node;
			},
			type: () => {
				return this.rules.unionType();
			},
			typeReference: () => {
				let node = {
					type: 'typeReference',
					range: {
						start: this.position
					},
					identifier:
						this.rules.identifier() ??
						this.rules.implicitChainIdentifier(),
					genericArguments: []
				}

				if(node.identifier == null) {
					return;
				}

				while(!this.tokensEnd) {
					let node_ = this.rules.chainIdentifier(node.identifier);

					if(node_ == null) {
						break;
					}

					node.identifier = node_;
				}

				node.range.end = this.position-1;

				if(!this.token.type.startsWith('operator') || this.token.value !== '<') {
					return node;
				}

				this.position++;
				node.genericArguments = this.ruleHelpers.sequentialNodes(
					['type'],
					() => this.token.type.startsWith('operator') && this.token.value === ','
				);

				if(!this.token.type.startsWith('operator') || this.token.value !== '>') {
					this.position = node.range.end+1;
					node.genericArguments = []
				} else {
					node.range.end = this.position++;
				}

				return node;
			},
			unionType: () => {
				let node = {
					type: 'unionType',
					range: {
						start: this.position
					},
					subtypes: this.ruleHelpers.sequentialNodes(
						['intersectionType'],
						() => this.token.type.startsWith('operator') && this.token.value === '|'
					)
				}

				if(node.subtypes.length === 0) {
					return;
				}
				if(node.subtypes.length === 1) {
				//	this.position = node.subtypes[0].range.end+1;  // Allow trailing separator (enabled)

					return node.subtypes[0]
				}

				node.range.end = node.subtypes.at(-1).range.end;

				return node;
			},
			variableDeclaration: () => {
				let node = {
					type: 'variableDeclaration',
					range: {
						start: this.position
					},
					modifiers: this.rules.modifiers(),
					declarators: []
				}

				if(this.token.type !== 'keywordVar') {
					this.position = node.range.start;

					return;
				}

				node.range.end = this.position++;
				node.declarators = this.ruleHelpers.sequentialNodes(
					['declarator'],
					() => this.token.type.startsWith('operator') && this.token.value === ','
				);

				if(node.modifiers?.values.some(v => !['private', 'protected', 'public', 'static', 'lazy', 'final'].includes(v))) {
					this.report(1, node.range.start, 'Wrong modifier(s) set for variable(s).');
				}
				if(node.declarators.length === 0) {
					this.report(0, node.range.start, 'Variable(s) declaration doesn\'t have initializer(s).');
				}

				node.range.end = this.position-1;

				return node;
			},
			whileStatement: () => {}
		}

		static ruleHelpers = {
			/*
			 * Returns a list of nodes of the types in sequential order like [1, 2, 3, 1...].
			 *
			 * Additionally a separator between the nodes can be set.
			 * Also types can be marked subsequential and therefore have no impact on offset in iterations.
			 *
			 * Stops when an unsupported type occurs.
			 *
			 * Useful for precise sequences lookup.
			 */
			sequentialNodes: (types, separating, subsequentialTypes) => {
				let nodes = [],
					offset = 0;

				while(!this.tokensEnd) {
					if(separating != null && offset > 0) {
						if(separating()) {
							this.position++;
						} else {
							break;
						}
					}

					let type = types[offset%types.length],
						node = this.rules[type]?.();

					if(node == null) {
						break;
					}

					nodes.push(node);

					if(!subsequentialTypes?.includes(node.type)) {
						offset++;
					}
				}

				return nodes;
			},
			/*
			 * Returns a node of the type or the "unsupported" node if not closed immediately.
			 *
			 * Stops if node found, at 0 (relatively to 1 at start) scope level or at the .tokensEnd.
			 *
			 * Warns about "unsupported" nodes.
			 *
			 * Useful for imprecise single enclosed(ing) nodes lookup.
			 */
			skippableNode: (type, opening, closing) => {
				let node,
					start = this.position,
					scopeLevel = 1;

				node = this.rules[type]?.();

				if(node != null || closing() || this.tokensEnd) {
					return node;
				}

				node = {
					type: 'unsupported',
					range: {
						start: this.position,
						end: this.position
					},
					tokens: []
				}

				while(!this.tokensEnd) {
					scopeLevel += opening();
					scopeLevel -= closing();

					if(scopeLevel === 0) {
						break;
					}

					node.tokens.push(this.token);
					node.range.end = this.position++;
				}

				let range = node.range.start !== node.range.end,
					message = range ? 'range of tokens ['+node.range.start+':'+node.range.end+']' : 'token ['+node.range.start+']';

				this.report(1, node.range.start, 'Unsupported type at '+message+'.');

				return node;
			},
			/*
			 * Returns a list of nodes of the types, including the "unsupported" nodes if any occur.
			 *
			 * Additionally a separator between the nodes can be set.
			 *
			 * Stops at 0 (relatively to 1 at start) scope level or at the .tokensEnd.
			 *
			 * Warns about invalid separators and "unsupported" nodes.
			 *
			 * Useful for imprecise multiple enclosed(ing) nodes lookup.
			 */
			skippableNodes: (types, opening, closing, separating) => {
				let nodes = [],
					scopeLevel = 1;

				while(!this.tokensEnd) {
					let node;

					if(separating == null || nodes.length === 0 || nodes.at(-1)?.type === 'separator') {
						for(let type of types) {
							node = this.rules[type]?.();

							if(node != null) {
								nodes.push(node);

								break;
							}
						}
					}

					if(closing() && scopeLevel === 1 || this.tokensEnd) {
						break;
					}
					if(node != null) {
						continue;
					}

					node = nodes.at(-1);

					if(separating?.()) {
						if(node?.type !== 'separator') {
							node = {
								type: 'separator',
								range: {
									start: this.position,
									end: this.position
								}
							}

							nodes.push(node);
						} else {
							node.range.end = this.position;
						}

						this.position++;

						continue;
					}

					if(node?.type !== 'unsupported') {
						node = {
							type: 'unsupported',
							range: {
								start: this.position,
								end: this.position
							},
							tokens: []
						}
					}

					scopeLevel += opening();
					scopeLevel -= closing();

					if(scopeLevel === 0) {
						break;
					}

					node.tokens.push(this.token);
					node.range.end = this.position++;

					if(node !== nodes.at(-1)) {
						nodes.push(node);
					}
				}

				for(let key in nodes) {
					let node = nodes[key],
						range = node.range.start !== node.range.end;

					if(node.type === 'separator') {
						if(key == 0) {
							this.report(0, node.range.start, 'Separator met before any supported type at token ['+node.range.start+'].');
						}
						if(range) {
							this.report(0, node.range.start, 'Separator sequence at range of tokens ['+node.range.start+':'+node.range.end+'].');
						}
						if(key == nodes.length-1) {
							this.report(0, node.range.start, 'Excess separator at token ['+node.range.start+'].');
						}
					}
					if(node.type === 'unsupported') {
						let message = range ? 'range of tokens ['+node.range.start+':'+node.range.end+']' : 'token ['+node.range.start+']';

						this.report(1, node.range.start, 'Unsupported type at '+message+'.');
					}
				}

				nodes = nodes.filter(v => v.type !== 'separator');

				return nodes;
			}
		}

		static get token() {
			return this.getToken();
		}

		static get tokensEnd() {
			return this.position === this.tokens.length;
		}

		static getToken(offset = 0) {
			return this.tokens[this.position+offset] ?? {
				position: undefined,
				location: undefined,
				type: '',
				value: ''
			}
		}

		static report(level, position, string) {
			let location = this.tokens[position].location;

			if(this.reports.find(v =>
				v.location.line === location.line &&
				v.location.column === location.column &&
				v.string === string) != null
			) {
				return;
			}

			this.reports.push({
				level: level,
				location: location,
				string: string
			});
		}

		static reset() {
			this.tokens = []
			this.position = 0;
			this.reports = []
		}

		static parse(lexerResult) {
			this.reset();

			this.tokens = lexerResult.tokens;

			let result = {
				tree: this.rules.module(),
				reports: this.reports
			}

			this.reset();

			return result;
		}
	}

	class Interpreter {
		static memory = [
			{
				address: 0,
				inheritance: ['Namespace'],
				imports: [
					/*
					{
						identifier: 'Foundation',
						value: 0
					}
					*/
				],
				operators: [
					{
						modifiers: ['postfix'],
						identifier: '++',
						associativity: null,
						precedence: null
					},
					{
						modifiers: ['postfix'],
						identifier: '--',
						associativity: null,
						precedence: null
					},
					{
						modifiers: ['prefix'],
						identifier: '++',
						associativity: null,
						precedence: null
					},
					{
						modifiers: ['prefix'],
						identifier: '--',
						associativity: null,
						precedence: null
					},
					{
						modifiers: [/* 'private', */ 'infix'],
						identifier: '+',
						associativity: 'left',
						precedence: 64
					}
				],
				members: [
					{
						modifiers: ['public', 'static'],
						identifier: 'TestClass',
						typed: true,
						inheritance: [1],
						nillable: true,
						value: '1',
						observers: []
					},
					{
						modifiers: ['public', 'static', 'final'],
						identifier: 'testPi',
						typed: true,
						inheritance: ['float'],
						nillable: true,
						value: '3.14',
						observers: []
					},
					{
						modifiers: ['public', 'static'],
						identifier: 'testClassInstance',
						typed: true,
						inheritance: [2],
						nillable: true,
						value: '3',
						observers: []
					},
					{
						modifiers: ['public'],
						identifier: 'computedInstanceProperty',
						typed: false,
						inheritance: [],
						nillable: true,
						value: null,
						observers: [
							{
								identifier: 'willGet',  // 'get', 'didGet', 'willSet', 'set', 'didSet', 'willDelete', 'delete', 'didDelete'
								value: null  // Function address
							}
						]
					}
				],
				observers: {
					chain: [
						{
							identifier: 'willGet',  // ...
							value: null  // Function address
						}
					],
					subscript: []
				},
				scope: null,
				retains: 1
			},
			{
				address: 1,
				inheritance: ['Class'],
				generics: [],
				members: [
					{
						modifiers: ['public', 'static', 'final'],
						identifier: 'init',
						typed: true,
						inheritance: [
							/*
							{
								type: 'Function',
								generics: [],  // [null] - Unspecified list, [] - Empty list
								parameters: [
									{
										typed: false,
										inheritance: [],
										nillable: true,
										variadic: true
									},
									{
										typed: false,
										inheritance: [],
										nillable: true,
										variadic: true
									}
								],
								asynchronous: 0,  // -1 - Unspecified, 0 - False, 1 - True
								throws: 0,
								return: {
									typed: true,
									inheritance: ['bool'],
									nillable: false
								}
							}
							*/
							'Function'
						],
						nillable: false,
						value: '2',
						observers: []
					},
					{
						modifiers: ['public'],
						identifier: 'testVariable',
						typed: true,
						inheritance: ['int'],
						nillable: true,
						value: null,
						observers: []
					}
				],
				observers: {
					chain: [],
					subscript: []
				},
				scope: 0,
				retains: 1
			},
			{
				address: 2,
				inheritance: ['Function'],
				generics: [
					/*
					{
						identifier: 'A',
						typed: false,
						inheritance: [],
						nillable: true
					},
					*/
				],
				parameters: [
					{
						label: null,
						identifier: 'firstArgument',
						inout: false,
						typed: true,
						inheritance: ['float'],
						nillable: false,
						variadic: false
					},
					{
						label: null,
						identifier: 'secondArgument',
						inout: false,
						typed: true,
						inheritance: ['bool'],
						nillable: true,
						variadic: false
					}
				],
				asynchronous: 0,
				throws: 0,
				return: {
					typed: true,
					inheritance: ['bool'],
					nillable: true
				},
				body: '\ttestVariable = 2 print(\'Test: \'+firstArgument)\n\n\treturn secondArgument', // Function body from Parser result
				members: [
					{
						identifier: 'parametersCount',
						inheritance: ['int'],
						value: '2'
					}
				],
				scope: 1,
				retains: 1
			},
			{
				address: 3,
				inheritance: ['Object', 1],
				members: [
					{
						identifier: 'testVariable',
						value: '2'
					}
				],
				scope: 0,
				retains: 1
			}
		]
		static contexts = []

		static rules = {
			module: (node) => {
				let namespace = this.rules.namespace(node);

				if(node.statements.length > 0) {
					this.rules.statements(namespace, node.statements);
				}
			},
			namespace: (node) => {

			},
			statements: (context, statements) => {

			}
		}

		static createInheritance(primary, ...secondary) {
			if(![
				'argument',
				'class',
				'enumeration',
				'function',
				'instance',
				'namespace',
				'protocol',
				'structure',
				'variable'
			].includes(primary)) {
				throw new RangeError();
			}
			if(['argument', 'variable'].includes(primary)) {
				if(
					![
						'_',
						'Any',
						'any',
						'bool',
						'float',
						'int',
						'string'
					].includes(secondary[0]) ||
					secondary?.some(v => typeof v !== 'string' && !Number.isInteger(v))
				) {
					throw new TypeError();
				}
			}

			return [primary, ...secondary]
		}

		static createModifiers(...values) {
			for(value of values) {
				if(![
					'infix',
					'postfix',
					'prefix',
					'private',
					'protected',
					'public',
					'static'
				].includes(value)) {
					return;
				}
			}

			return values;
		}

		static createMember(inheritance, parameters) {
			let member;

			if(inheritance[0] === 'variable') {
				member = {
					/*
					modifiers: modifiers,
					identifier: identifier,
					typed: typed,
					inheritance: inheritance,
					nillable: nillable,
					value: value
					*/
				}
			}
			return member;
		}

		static getComposite(address) {
			let composite = this.memory.find(v => v.address === address);

			if(composite == null) {
				return;
			}

			return new Proxy(composite, {
				get: (t, k) => {
					if(k === 'metaSelf') {
						return t;
					}

					let members = t.members ?? [],
						member = members.find(v => v.identifier === k),
						identifier = member?.identifier,
						inheritance = member?.inheritance ?? [],
						value = member?.value;

					if(member == null) {
						return;
					}

					if(inheritance.length > 0 && inheritance.every(v => Number.isInteger(v))) {
						let address = value*1;

						return this.getComposite(address);
					} else {
						return member;
					}
				},
				ownKeys: (t) => {
					let members = t.members ?? [],
						keys = members.map(v => v.identifier);

					keys.push('metaSelf');

					return keys;
				},
				getOwnPropertyDescriptor: (t, k) => {
					if(k === 'metaSelf') {
						return {
							enumerable: true,
							configurable: true,
							value: t
						}
					}

					let members = t.members ?? [],
						member = members.find(v => v.identifier === k),
						inheritance = member?.inheritance ?? [],
						value = member?.value;

					if(member == null) {
						return;
					}

					if(inheritance.length > 0 && inheritance.every(v => Number.isInteger(v))) {
						let address = value*1;

						member = this.getComposite(address);
					}

					return {
						enumerable: true,
						configurable: true,
						value: member
					}
				}
			});
		}

		static createMainContext() {
		//  this.memory.push();

			if(this.contexts.length === 0) {
				this.contexts.push(this.getComposite(0));
			}
		}
	}

	let input = document.getElementById('input'),
		output_lint = document.getElementById('output_lint'),
		output_ast = document.getElementById('output_ast'),
		output_console = document.getElementById('output_console');

	function parse() {
		let lexerResult = Lexer.tokenize(input.value),
			parserResult = Parser.parse(lexerResult),
			tokens = lexerResult.rawTokens,
			reports = [...lexerResult.reports, ...parserResult.reports]
					  .sort((a, b) => a.location.line-b.location.line || a.location.column-b.location.column);

		let lintHTML = '';

		for(let k = 0; k < tokens.length; k++) {
			let position = tokens[k].position,
				type = tokens[k].type,
				value = tokens[k].value,
				length = value.length,
				element;

			if(type === 'delimiter') {
				for(let i = 0; i < value.length; i++) {
					if(value[i] !== '\n') {
						element ??= document.createElement('span');
						element.innerText += value[i]

						if(value[i+1] === '\n' || i === value.length-1) {
							lintHTML += element.outerHTML;
							element = undefined;
						}
					}
					if(value[i] === '\n') {
						lintHTML += document.createElement('br').outerHTML;
					}
				}
			} else {
				element = document.createElement('span');
				element.innerText = value;

				if(type.startsWith('comment')) {
					element.style.color = 'rgb(95 179 63 / 1)';
				}
				if(type.startsWith('string') && !type.startsWith('stringExpression')) {
					element.style.color = 'rgb(191 127 95 / 1)';
				}
				if(type.startsWith('operator')) {
					element.style.color = 'rgb(255 191 0 / 1)';

					if(type.endsWith('Prefix')) {
						element.style.color = 'rgb(255 63 0 / 1)';
					}
					if(type.endsWith('Infix')) {
						element.style.color = 'rgb(255 95 0 / 1)';
					}
					if(type.endsWith('Postfix')) {
						element.style.color = 'rgb(255 127 0 / 1)';
					}
				}
				if(
					type.startsWith('parenthesis') ||
					type.startsWith('brace') ||
					type.startsWith('bracket') ||
					type.startsWith('angle')
				) {
					element.style.color = 'rgb(255 255 255 / 1)';
				}
				if(type.startsWith('keyword')) {
					element.style.color = 'cornflowerblue';

					if([
						'nil',
						'true',
						'false'
					].includes(value)) {
						element.style.color = 'rgb(223 127 223 / 1)';
					}
				}
				if(type.startsWith('number')) {
					element.style.color = 'rgb(223 127 223 / 1)';
				}

				lintHTML += element.outerHTML;
			}
		}

		let consoleHTML = '';

		console.clear();
		for(let report of reports) {
			let level = report.level.toString()
									.replace('0', 'Info')
									.replace('1', 'Warning')
									.replace('2', 'Error'),
				line = report.location.line+1,
				column = report.location.column+1,
				string = report.string,
				message = line+':'+column+': '+level+': '+string;

			consoleHTML += message+'\n';
			console.log(message);
		}
		console.log(lexerResult.tokens);
		console.log(parserResult.tree);

		output_lint.innerHTML = lintHTML;
		output_ast.innerText = JSON.stringify(parserResult.tree, null, 4);
		output_console.innerText = consoleHTML;
	}

	input.oninput = parse;
	input.onscroll = () => output_lint.scrollTop = input.scrollTop;
	input.value = input.value.trim();

	parse();
</script>
</body>
</html>
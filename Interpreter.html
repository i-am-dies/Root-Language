<html>
<body>
<style>
	#input {
		width: 768px;
		height: 512px;

		border: none;
		border-radius: 2px;
		background: white;
		box-shadow: 0 2px 4px gray;

		color: black;
	}
</style>
<textarea id="input">
class A {}
class B: A {
	a
	struct C {}
	b
}

// Foundation Source

struct Boolean {
	const value

	func initialize(value: bool) {
		self.value = value
	}

	func ==(rhs: bool & Boolean) -> Boolean {
		return rhs !is Boolean ? value == rhs : value == rhs.value
	}
}

struct Number {
	static const Pi = 3.14

	const value

	func initialize(value: int & decimal) {
		self.value = value
	}

	func ==(rhs: int & decimal & Number) -> Boolean {
		return rhs !is Number ? value == rhs : value == rhs.value
	}
}

struct Decimal: Number {
	func initialize(value: int & decimal) {
		if var v = value%2 && (v == 0 || v == 1) {
			throw 'Value can\'t be integer'
		}

		self.value = value
	}
}

struct Integer: Number {
	func initialize(value: int & decimal) {
		if var v = value%2 && v > 0 && v < 1 {
			throw 'Value can\'t be decimal'
		}

		self.value = value
	}
}

struct String {
	const value

	func initialize(value: string) {
		self.value = value
	}

	func ==(rhs: string & String) -> Boolean {
		return rhs !is String ? value == rhs : value == rhs.value
	}
}

// ---- ---- ---- ----

/* Comment
Block */

// Comment Line

import Foundation

alias Boolean = Foundation.Boolean,
	  Number = Foundation.Number,
	  Decimal = Foundation.Decimal,
	  Integer = Foundation.Integer,
	  String = Foundation.String

const constant = Number.Pi

var variable

if constant > 0 {
	variable = 1
}

class Class {
	const private constant: Number = 0.5

	var protected variable: Integer = 1

	var variable_01a = 'String'

	var private anotherVariableStorage

	var anotherVariable {
		willSet {}
		set {
			anotherVariableStorage = newValue
		}
		didSet {}
		willGet {}
		get {
			return anotherVariableStorage
		}
		didGet {}
	}

	var {
		get {
			return self[key+1].n
		}
		set {
			print(key)

			return newValue
		}
	}

	subscript(index: Integer) {
		get {
			return object.properties[index].value
		}
		set {}
	}

	func initialize(with parameter: Integer = 0, and parameter_: String) {
		print('Intitializing with \(parameter) and \(parameter_)')

		variable = parameter
		variable_01a = parameter_
	}

	func deinitialize {
		print('Deinitializing!')
	}
}

var instance = Class(with: 12, and: '2')

print('Testing nested template string: printing some \(identifier+'abc\(1+2+3)def'+0.125) and \(instance.variable)')

instance = nil
</textarea>
<script>
	let code = document.getElementById('input').value;

	class Lexer {
		static code;
		static position;
		static location;
		static tokens;
		static levels;
		static rules = [
			['/*', (v) => {
				if(this.levels.comment > 0 || this.levels.string > this.levels.stringExpression) {
					this.lastToken.value += v;
				} else {
					this.createToken('commentBlock', '');
				}
				if(this.lastToken.type === 'commentBlock') {
					this.levels.comment++;
				}
			}],
			['*/', (v) => {
				if(this.levels.comment > 0 && this.lastToken.type === 'commentLine' || this.levels.comment > 1 || this.levels.string > this.levels.stringExpression) {
					this.lastToken.value += v;
				}
				if(this.lastToken.type === 'commentBlock') {
					this.levels.comment--;
				}
			}],
			['//', (v) => {
				if(this.levels.comment > 0 || this.levels.string > this.levels.stringExpression) {
					this.lastToken.value += v;
				} else {
					this.createToken('commentLine', '');
					this.levels.comment++;
				}
			}],
			[['\\\\', '\\\'', '\\(', '\\b', '\\f', '\\n', '\\r', '\\t', '\\v', '\\'], (v) => {
				if(this.levels.comment > 0) {
					this.lastToken.value += v;
				} else
				if(this.levels.string > this.levels.stringExpression) {
					switch(v) {
						case '\\\\':	v = '\\';		break;
						case '\\\'':	v = '\'';		break;
						case '\\(':		return true;	break;
						case '\\b':		v = '\b';		break;
						case '\\f':		v = '\f';		break;
						case '\\n':		v = '\n';		break;
						case '\\r':		v = '\r';		break;
						case '\\t':		v = '\t';		break;
						case '\\v':		v = '\v';		break;
						case '\\':		v = '';			break;
					}

					this.lastToken.value += v;
				}
			}],
			[['\\(', ')'], (v) => {
				if(this.levels.comment > 0) {
					this.lastToken.value += v;
				} else {
					switch(v) {
						case '\\(':
							if(this.levels.string > this.levels.stringExpression) {
								this.lastToken.type = 'stringPart';
								this.createToken('stringExpressionOpen', v);
								this.levels.stringExpression++;
							}
						break;
						case ')':
							if(this.levels.string > this.levels.stringExpression || this.levels.stringExpression === 0 || this.levels.stringExpressionParenthesis > 0) {
								return true;
							}
							this.createToken('stringExpressionClosed', v);
							this.levels.stringExpression--;
							this.createToken('stringPart', '');
						break;
					}
				}
			}],
			[['!=', '!', '%', '&&', '&', '??=', '??', '?', '||', '==', '=', '<=', '<', '>=', '>', '--', '-=', '->', '-', '++', '+=', '+', '/=', '/', '*=', '*', ':', '.', ','], (v) => {
				if(this.levels.comment > 0 || this.levels.string > this.levels.stringExpression) {
					this.lastToken.value += v;
				} else {
					let title;

					switch(v) {
						case '!=':	title = 'NotEquals';			break;
						case '!':	title = 'Exclamation';			break;
						case '%':	title = 'Remainder';			break;
						case '&&':	title = 'And';					break;
						case '&':	title = 'Ampersand';			break;
						case '??=':	title = 'NullCoalescingAssign';	break;
						case '??':	title = 'NullCoalescing';		break;
						case '?':	title = 'Question';				break;
						case '||':	title = 'Or';					break;
						case '==':	title = 'Equals';				break;
						case '=':	title = 'Assign';				break;
						case '<=':	title = 'SmallerEquals';		break;
						case '<':	title = 'Smaller';				break;
						case '>=':	title = 'BiggerEquals';			break;
						case '>':	title = 'Bigger';				break;
						case '--':	title = 'Decrement';			break;
						case '-=':	title = 'MinusAssign';			break;
						case '->':	title = 'Returns';				break;
						case '-':	title = 'Minus';				break;
						case '++':	title = 'Increment';			break;
						case '+=':	title = 'PlusAssign';			break;
						case '+':	title = 'Plus';					break;
						case '/=':	title = 'DivideAssign';			break;
						case '/':	title = 'Divide';				break;
						case '*=':	title = 'MultiplyAssign';		break;
						case '*':	title = 'Multiply';				break;
						case ':':	title = 'Colon';				break;
						case '.':
							if(this.lastToken.type === 'numberInteger') {
								return true;
							} else {
								title = 'Chain';
							}
						break;
						case ',':	title = 'Also';				break;
					}

					this.createToken('operator'+title, v);
				}
			}],
			[['(', ')', '{', '}', '[', ']'], (v) => {
				if(this.levels.comment > 0 || this.levels.string > this.levels.stringExpression) {
					this.lastToken.value += v;
				} else {
					let title;

					switch(v) {
						case '(':
							if(this.levels.stringExpression > 0) {
								this.levels.stringExpressionParenthesis++;
							}
							title = 'parenthesisOpen';
						break;
						case ')':
							if(this.levels.stringExpression > 0) {
								this.levels.stringExpressionParenthesis--;
							}
							title = 'parenthesisClosed';
						break;
						case '{':	title = 'braceOpen';		break;
						case '}':	title = 'braceClosed';		break;
						case '[':	title = 'bracketOpen';		break;
						case ']':	title = 'bracketClosed';	break;
					}

					this.createToken(title, v);
				}
			}],
			['\'', () => {
				if(this.levels.comment > 0) {
					return true;
				}
				if(this.levels.string === this.levels.stringExpression) {
					this.createToken('string', '');
					this.levels.string++;
				} else
				if(this.levels.string > this.levels.stringExpression) {
					this.levels.string--;
				}
			}],
			[/\s|;/, (v) => {
				if(this.levels.comment > 0 || this.levels.string > this.levels.stringExpression) {
					if(v === '\n' && this.lastToken.type === 'commentLine') {
						this.createToken('delimiter');
						this.levels.comment--;
					} else {
						this.lastToken.value += v;
					}
				} else
				if(this.lastToken.type === 'delimiter') {
					this.lastToken.value += v;
				} else {
					this.createToken('delimiter');
				}
			}],
			[/[0-9\.]/, (v) => {
				if(this.levels.comment > 0 || this.levels.string > this.levels.stringExpression || this.lastToken.type.startsWith('number') || this.lastToken.type === 'identifier' && v !== '.') {
					if(this.lastToken.type === 'numberInteger' && v === '.') {
						this.lastToken.type = 'numberFloat';
					}
					this.lastToken.value += v;
				} else
				if(v !== '.') {
					this.createToken('numberInteger');
				}
			}],
			[/[a-z_]/i, (v) => {
				if(this.levels.comment > 0 || this.levels.string > this.levels.stringExpression) {
					return true;
				}
				if(this.lastToken.type !== 'identifier' && !this.lastToken.type.startsWith('keyword')) {
					this.createToken('identifier', '');
				}
				this.lastToken.value += v;
				if([
					'alias',
					'break',
					'case', 'catch', 'class', 'const', 'continue',
					'default',
					'else', 'enum', 'extension',
					'false', 'for', 'func',
					'if', 'import', 'is',
					'namespace', 'nil',
					'private', 'protected', 'protocol', 'public',
					'return',
					'self', 'struct', 'subscript', 'super', 'switch',
					'throw', 'true', 'try',
					'var',
					'while'
				].includes(this.lastToken.value)) {
					this.lastToken.type = 'keyword'+this.lastToken.value[0].toUpperCase()+this.lastToken.value.slice(1);
				} else {
					this.lastToken.type = 'identifier';
				}
			}],
			[/.|\n/i, (v) => {
				if(this.lastToken.type === 'commentBlock' || this.lastToken.type === 'commentLine' && v !== '\n' || this.levels.string > this.levels.stringExpression) {
					this.lastToken.value += v;
				} else {
					this.report('Warning: No token of appropriate type was created before to accept this character and it doesn\'t represent any possible type independently: "'+v+'", skipping...');
				}
			}]
		]

		static get lastToken() {
			return this.tokens.at(-1) ?? {
				position: undefined,
				location: undefined,
				type: '',
				value: ''
			}
		}

		static createToken(type, value) {
			this.tokens.push({
				position: this.position,
				location: {...this.location},
				type: type,
				value: value != null ? value : this.code[this.position]
			});
		}

		static report(string) {
			console.log((this.location.y+1)+':'+(this.location.x+1)+': '+string);
		}

		static reset() {
			this.code = undefined;
			this.position = undefined;
			this.location = {
				x: 0,
				y: 0
			}
			this.tokens = []
			this.levels = {
				comment: 0,
				string: 0,
				stringExpression: 0,
				stringExpressionParenthesis: 0
			}
		}

		static atPosition(substring) {
			return this.code.indexOf(substring, this.position) === this.position;
		}

		static tokenize(code, cleanupLevel) {
			this.reset();

			this.code = code;

			for(this.position = 0; this.position < this.code.length; this.position++) {
				for(let rule of this.rules) {
					let triggers = rule[0],
						actions = rule[1],
						plain = typeof triggers === 'string',
						array = Array.isArray(triggers),
						regex = triggers instanceof RegExp,
						trigger;

					if(plain && this.atPosition(triggers)) {
						trigger = triggers;
					}
					if(array) {
						trigger = triggers.find(v => this.atPosition(v));
					}
					if(regex && triggers.test(this.code[this.position])) {
						trigger = this.code[this.position]
					}

					if(trigger != null && !actions(trigger)) {
						this.position += trigger.length-1;

						for(let character of trigger) {
							if(character === '\n') {
								this.location.x = 0;
								this.location.y++;
							} else {
								this.location.x++;
							}
						}

						break;
					}
				}
			}

			let tokens = this.tokens;

			if(cleanupLevel === 1) {
				tokens = tokens.filter(v => !(v.type === 'delimiter' && !v.value.includes('\n') && !v.value.includes(';')))
			}
			if(cleanupLevel === 2) {
				tokens = tokens.filter(v => !v.type.startsWith('comment') && v.type !== 'delimiter');
			}

			this.reset();

			return tokens;
		}
	}

	class Parser {
		static tokens;
		static position;
		static rules = {
			aliasDeclaration: () => {},
			classBody: () => {
				return this.rules.specificBody('class');
			},
			classDeclaration: () => {
				let node = {
					type: 'classDeclaration',
					range: {},
					id: undefined,
					inheritance: undefined,
					body: undefined
				}

				if(this.currentToken.type === 'keywordClass') {
					node.range.start = this.position++;
				} else {
					return;
				}

				node.id = this.rules.identifier();
				node.inheritance = this.rules.typeInheritanceClause();
				node.body = this.rules.classBody();

				if(node.id == null) {
					this.report(node.range.start, 'Warning: No identifier set for class.');
				}
				if(node.body != null) {
					node.range.end = node.body.range.end;
				} else {
					this.report(node.range.start, 'Warning: Class doesn\'t have body.');
				}

				return node;
			},
			classMembers: () => {
				return this.rules.specificMembers('class', [
					'aliasDeclaration',
					'classDeclaration',
					'functionDeclaration',
					'structureDeclaration',
					'variableDeclaration'
				]);
			},
			functionBody: () => {
				return this.rules.specificBody('function');
			},
			functionCallExpression: () => {},
			functionDeclaration: () => {},
			functionMembers: () => {
				return this.rules.specificMembers('function', [
					'aliasDeclaration',
					'classDeclaration',
					'functionCallExpression',
					'functionDeclaration',
					'ifStatement',
					'importDeclaration',
					'structureDeclaration',
					'variableAssignment',
					'variableDeclaration'
				]);
			},
			identifier: () => {
				let node = {
					type: 'identifier',
					range: {},
					value: ''
				}

				if(this.currentToken.type === 'identifier') {
					node.value = this.currentToken.value;
					node.range.start =
					node.range.end = this.position++;
				} else {
					return;
				}

				return node;
			},
			ifStatement: () => {},
			importDeclaration: () => {},
			logicalExpression: () => {},
			module: () => {
				let node = {
					type: 'module',
					range: {
						start: 0,
						end: 0
					},
					children: this.rules.functionMembers()
				}

				if(node.children.length > 0) {
					node.range.start = node.children[0].range.start;
					node.range.end = node.children.at(-1).range.end;
				}

				return node;
			},
			specificBody: (type) => {
				let node = {
					type: type+'Body',
					range: {},
					children: []
				}

				if(this.currentToken.type === 'braceOpen') {
					node.range.start = this.position++;
				} else {
					return;
				}

				node.children = this.rules[type+'Members']();

				if(this.currentToken.type === 'braceClosed') {
					node.range.end = this.position++;
				} else {
					this.position = node.range.start;

					return;
				}

				return node;
			},
			specificMembers: (type, memberTypes) => {
				let list = []

				while(true) {
					let node

					for(let memberType of memberTypes) {
						node = this.rules[memberType]();

						if(node != null) {
							list.push(node);

							break;
						}
					}
					if(node != null) {
						continue;
					}

					node = list.findLast(v => v.type === 'unawaredMember');

					if(node == null || node !== list.at(-1)) {
						node = {
							type: 'unawaredMember',
							range: {
								start: this.position,
								end: this.position
							},
							scopeLevel: 1
						}

						list.push(node);
					} else {
						node.range.end = this.position;
					}

					switch(this.currentToken.type) {
						case 'braceOpen':	node.scopeLevel++; break;
						case 'braceClosed':	node.scopeLevel--; break;
					}

					if(node.scopeLevel === 0 || this.position === this.tokens.length) {
						node.range.end--;

						if(node.range.start > node.range.end) {
							list = list.filter(v => v !== node);
						}

						break;
					}

					this.position++;
				}

				for(let node of list.filter(v => v.type === 'unawaredMember')) {
					delete node.scopeLevel;

					this.report(node.range.start, 'Warning: Unawared member type at range of tokens ['+node.range.start+':'+node.range.end+'].');
				}

				return list;
			},
			structureBody: () => {
				return this.rules.specificBody('structure');
			},
			structureDeclaration: () => {
				let node = {
					type: 'structureDeclaration',
					range: {},
					id: undefined,
					inheritance: undefined,
					body: undefined
				}

				if(this.currentToken.type === 'keywordStruct') {
					node.range.start = this.position++;
				} else {
					return;
				}

				node.id = this.rules.identifier();
				node.inheritance = this.rules.typeInheritanceClause();
				node.body = this.rules.structureBody();

				if(node.id == null) {
					this.report(node.range.start, 'Warning: No identifier set for structure.');
				}
				if(node.body != null) {
					node.range.end = node.body.range.end;
				} else {
					this.report(node.range.start, 'Error: Structure doesn\'t have body.');
				}

				return node;
			},
			structureMembers: () => {
				return this.rules.specificMembers('structure', [
					'aliasDeclaration',
					'classDeclaration',
					'functionDeclaration',
					'structureDeclaration',
					'variableDeclaration'
				]);
			},
			typeInheritanceClause: () => {
				let node = {
					type: 'typeInheritanceClause',
					range: {},
					children: []
				}

				if(this.currentToken.type === 'operatorColon') {
					node.range.start = this.position++;
				} else {
					return;
				}

				node.children = [
					this.rules.identifier()
				].filter(v => v);

				if(node.children.length > 0) {
					node.range.end = node.children.at(-1).range.end;
				} else {
					this.position = node.range.start;

					return;
				}

				return node;
			},
			variableAssignment: () => {},
			variableDeclaration: () => {}
		}

		static get currentToken() {
			return this.getToken();
		}

		static getToken(offset = 0) {
			return this.tokens[this.position+offset] ?? {
				position: undefined,
				location: undefined,
				type: '',
				value: ''
			}
		}

		static report(position, string) {
			let location = this.tokens[position].location;

			console.log((location.y+1)+':'+(location.x+1)+': '+string);
		}

		static reset() {
			this.tokens = []
			this.position = 0;
		}

		static parse(tokens) {
			this.reset();

			this.tokens = tokens;

			let tree = this.rules.module();

			this.reset();

			return tree;
		}
	}

	let tokens = Lexer.tokenize(code, 2),
		tree = Parser.parse(tokens);

	console.log(tokens);
	console.log(tree);
</script>
</body>
</html>
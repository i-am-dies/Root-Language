<html>
<body>
<style>
#input {
	width: 768px;
	height: 512px;
	overflow: auto;

	border: none;
	border-radius: 2px;
	background: white;
	box-shadow: 0 2px 4px gray;

	color: black;
	font: 12px monospace;
	white-space: pre;
}
</style>
<div id="input" contenteditable="true"><!--
-->long.identifiers?.chain_.with_().call.to[].subscript_

'one\(two)three\(four)five\(six)seven'

// Foundation Source

struct Boolean {
	private const value

	init(value: bool) {
		self.value = value
	}

	static func ==(lhs: bool & Boolean, rhs: bool & Boolean) -> Boolean {
		var leftValue = lhs !is Boolean ? lhs : lhs.value,
			rightValue = rhs !is Boolean ? rhs : rhs.value

		return leftValue == rightValue
	}
}

struct Number {
	static const Pi = 3.141592653589793

	protected const value

	init(value: int & float) {
		self.value = value
	}

	static func ==(lhs: int & float & Number, rhs: int & float & Number) -> Boolean {
		var leftValue = lhs !is Number ? lhs : lhs.value,
			rightValue = rhs !is Number ? rhs : rhs.value

		return leftValue == rightValue
	}
}

struct Float: Number {
	init(value: int & float) {
		if var v = value%2 && (v == 0 || v == 1) {
			throw 'Value can\'t be integer'
		}

		self.value = value
	}
}

struct Integer: Number {
	init(value: int & float) {
		if var v = value%2 && v > 0 && v < 1 {
			throw 'Value can\'t be float'
		}

		self.value = value
	}
}

struct String {
	private const value

	init(value: string) {
		self.value = value
	}

	static func ==(lhs: string & String, rhs: string & String) -> Boolean {
		var leftValue = lhs !is String ? lhs : lhs.value,
			rightValue = rhs !is String ? rhs : rhs.value

		return leftValue == rightValue
	}
}

class Array {}

class Dictionary {}

// ---- ---- ---- ----

/* Comment
Block */

// Comment Line

import Foundation

const Boolean = Foundation.Boolean,
	  Number = Foundation.Number,
	  Decimal = Foundation.Decimal,
	  Integer = Foundation.Integer,
	  String = Foundation.String,
	  Array = Foundation.Array,
	  Dictionary = Foundation.Dictionary

const constant = Number.Pi

var variable

if constant > 0 {
	variable = 1
}

class A {
	private const constant: Number = 0.5

	protected var variable: Integer = 1

	var variable_01a = 'String'

	private var anotherVariableStorage

	var anotherVariable {
		get {
			return anotherVariableStorage
		}
		set {
			anotherVariableStorage = newValue
		}

		willGet {}
		didGet {}
		willSet {}
		didSet {}
	}

	chain {
		get {
			return metaSelf.properties[key]?.value
		}
		set {
			metaSelf.properties[key] = value
		}
	}

	subscript(a: Integer, b: Integer) -> Integer {
		get {
			return a+b
		}
		set {
			print(a, b)
		}
	}

	init(with number: Integer = 0, and string: String) {
		print('Intitializing with \(number) and \(string)')

		variable = number
		variable_01a = string
	}

	deinit {
		print('Deinitializing!')
	}
}

var instance = A(with: 12, and: '2')

/*
var self.A: self.Class = class { ... }

var self.instance = A(with: 12, and: '2')
*/

print('Testing nested template string: printing some \(identifier+'abc\(1+2+3)def'+0.125) and \(instance.variable)')

var instance_2 = struct {
	init(test: Integer) {
		print('Initialized anonymous struct with testing variable: '+test)
	}
}(12)

instance =
instance_2 = nil

enum B {
	case first
	case second
	case third
	case fourth
}

var enum_value: B = .first

var function

/*
function = { x in x > 0 } - 1

function = (x) in x > 0
function = (x) { x > 0 }
function = (x) { return x > 0 } - 2

function = func (x) in x > 0
function = func (x) { x > 0 }
function = func (x) { return x > 0 } - 3
*/
</div>
<script>
	let code = document.getElementById('input').innerText;

	class Lexer {
		static code;
		static position;
		static location;
		static tokens;
		static levels;
		static reports;
		static rules = [
			['/*', (v) => {
				if(this.levels.comment > 0 || this.levels.string > this.levels.stringExpression) {
					this.token.value += v;
				} else {
					this.addToken('commentBlock', '');
				}
				if(this.token.type === 'commentBlock') {
					this.levels.comment++;
				}
			}],
			['*/', (v) => {
				if(this.levels.comment > 0 && this.token.type === 'commentLine' || this.levels.comment > 1 || this.levels.string > this.levels.stringExpression) {
					this.token.value += v;
				}
				if(this.token.type === 'commentBlock') {
					this.levels.comment--;
				}
			}],
			['//', (v) => {
				if(this.levels.comment > 0 || this.levels.string > this.levels.stringExpression) {
					this.token.value += v;
				} else {
					this.addToken('commentLine', '');
					this.levels.comment++;
				}
			}],
			[['\\\\', '\\\'', '\\(', '\\b', '\\f', '\\n', '\\r', '\\t', '\\v', '\\'], (v) => {
				if(this.levels.comment > 0) {
					this.token.value += v;
				} else
				if(this.levels.string > this.levels.stringExpression) {
					switch(v) {
						case '\\\\':	v = '\\';		break;
						case '\\\'':	v = '\'';		break;
						case '\\(':		return true;	break;
						case '\\b':		v = '\b';		break;
						case '\\f':		v = '\f';		break;
						case '\\n':		v = '\n';		break;
						case '\\r':		v = '\r';		break;
						case '\\t':		v = '\t';		break;
						case '\\v':		v = '\v';		break;
						case '\\':		v = '';			break;
					}

					this.token.value += v;
				}
			}],
			[['\\(', ')'], (v) => {
				if(this.levels.comment > 0) {
					this.token.value += v;
				} else {
					switch(v) {
						case '\\(':
							if(this.levels.string > this.levels.stringExpression) {
								this.token.type = 'stringSegment'+(this.token.type.endsWith('Last') ? '' : 'First');
								this.addToken('stringExpressionOpen', v);
								this.levels.stringExpression++;
							}
						break;
						case ')':
							if(this.levels.string > this.levels.stringExpression || this.levels.stringExpression === 0 || this.levels.stringExpressionParenthesis > 0) {
								return true;
							}
							this.addToken('stringExpressionClosed', v);
							this.levels.stringExpression--;
							this.addToken('stringSegmentLast', '');
						break;
					}
				}
			}],
			[['!', '%', '&', '*', '+', ',', '-', '.', '/', ':', '<', '=', '>', '?', '^', '|', '~'], (v) => {
				if(this.levels.comment > 0 || this.levels.string > this.levels.stringExpression || this.token.type === 'operator') {
					this.token.value += v;
				} else {
					this.addToken('operator', v);
				}
			}],
			[['(', ')', '{', '}', '[', ']'], (v) => {
				if(this.levels.comment > 0 || this.levels.string > this.levels.stringExpression) {
					this.token.value += v;
				} else {
					let title;

					switch(v) {
						case '(':
							if(this.levels.stringExpression > 0) {
								this.levels.stringExpressionParenthesis++;
							}
							title = 'parenthesisOpen';
						break;
						case ')':
							if(this.levels.stringExpression > 0) {
								this.levels.stringExpressionParenthesis--;
							}
							title = 'parenthesisClosed';
						break;
						case '{':	title = 'braceOpen';		break;
						case '}':	title = 'braceClosed';		break;
						case '[':	title = 'bracketOpen';		break;
						case ']':	title = 'bracketClosed';	break;
					}

					this.addToken(title, v);
				}
			}],
			['\'', () => {
				if(this.levels.comment > 0) {
					return true;
				}
				if(this.levels.string === this.levels.stringExpression) {
					this.addToken('string', '');
					this.levels.string++;
				} else
				if(this.levels.string > this.levels.stringExpression) {
					this.levels.string--;
				}
			}],
			[/\s|;/, (v) => {
				if(this.levels.comment > 0 || this.levels.string > this.levels.stringExpression) {
					if(v === '\n' && this.token.type === 'commentLine') {
						this.addToken('delimiter');
						this.levels.comment--;
					} else {
						this.token.value += v;
					}
				} else
				if(this.token.type === 'delimiter') {
					this.token.value += v;
				} else {
					this.addToken('delimiter');
				}
			}],
			[/[0-9]/, (v) => {
				if(this.levels.comment > 0 || this.levels.string > this.levels.stringExpression || this.token.type.startsWith('number') || this.token.type === 'identifier') {
					this.token.value += v;
				} else
				if(this.token.type === 'operator' && this.token.value === '.' && this.getToken(-1).type === 'numberInteger') {
					this.removeToken();
					this.token.type = 'numberFloat';
					this.token.value += '.'+v;
				} else {
					this.addToken('numberInteger');
				}
			}],
			[/[a-z_]/i, (v) => {
				if(this.levels.comment > 0 || this.levels.string > this.levels.stringExpression) {
					return true;
				}
				if(this.token.type !== 'identifier' && !this.token.type.startsWith('keyword')) {
					this.addToken('identifier', '');
				}
				this.token.value += v;
				if([
					'Any',
					'Class',
					'Enumeration',
					'Function',
					'Namespace',
					'Object',
					'Protocol',
					'Self', 'Structure',
					'any', /*'arguments',*/
					'bool', 'break',
					'case', 'catch', 'chain', 'class', 'const', 'continue',
					'default',
					'else', 'enum', 'extension',
					'false', 'float', 'for', 'func',
					'if', 'import', 'in', 'int', 'is',
					'namespace', 'nil',
					'private', 'protected', 'protocol', 'public',
					'return',
					'self', 'string', 'struct', 'subscript', 'super', 'switch',
					'throw', 'true', 'try',
					'var',
					'while'
				].includes(this.token.value)) {
					this.token.type = 'keyword'+this.token.value[0].toUpperCase()+this.token.value.slice(1);
				} else {
					this.token.type = 'identifier';
				}
			}],
			[/.|\n/i, (v) => {
				if(this.token.type === 'commentBlock' || this.token.type === 'commentLine' && v !== '\n' || this.levels.string > this.levels.stringExpression) {
					this.token.value += v;
				} else {
					this.report(0, 'No token of appropriate type was created before to accept this character and it doesn\'t represent any possible type independently: "'+v+'", skipping...');
				}
			}]
		]

		static get token() {
			return this.getToken();
		}

		static getToken(offset = 0) {
			return this.tokens[this.tokens.length-1+offset] ?? {
				position: undefined,
				location: undefined,
				type: '',
				value: ''
			}
		}

		static addToken(type, value) {
			this.tokens.push({
				position: this.position,
				location: {...this.location},
				type: type,
				value: value != null ? value : this.code[this.position]
			});
		}

		static removeToken(offset = 0) {
			this.tokens = this.tokens.filter((v, k) => k !== this.tokens.length-1+offset);
		}

		static report(level, string) {
			this.reports.push({
				level: level,
				location: {...this.location},
				string: string
			});
		}

		static reset() {
			this.code = undefined;
			this.position = undefined;
			this.location = {
				line: 0,
				column: 0
			}
			this.tokens = []
			this.levels = {
				comment: 0,
				string: 0,
				stringExpression: 0,
				stringExpressionParenthesis: 0
			}
			this.reports = []
		}

		static atPosition(substring) {
			return this.code.indexOf(substring, this.position) === this.position;
		}

		static tokenize(code, cleanupLevel) {
			this.reset();

			this.code = code;

			for(this.position = 0; this.position < this.code.length; this.position++) {
				for(let rule of this.rules) {
					let triggers = rule[0],
						actions = rule[1],
						plain = typeof triggers === 'string',
						array = Array.isArray(triggers),
						regex = triggers instanceof RegExp,
						trigger;

					if(plain && this.atPosition(triggers)) {
						trigger = triggers;
					}
					if(array) {
						trigger = triggers.find(v => this.atPosition(v));
					}
					if(regex && triggers.test(this.code[this.position])) {
						trigger = this.code[this.position]
					}

					if(trigger != null && !actions(trigger)) {
						this.position += trigger.length-1;

						for(let character of trigger) {
							if(character === '\n') {
								this.location.line++;
								this.location.column = 0;
							} else {
								this.location.column++;
							}
						}

						break;
					}
				}
			}

			let result = {}

			if(cleanupLevel === 1) {
				result.tokens = this.tokens.filter(v => !(v.type === 'delimiter' && !v.value.includes('\n') && !v.value.includes(';')))
			}
			if(cleanupLevel === 2) {
				result.tokens = this.tokens.filter(v => !v.type.startsWith('comment') && v.type !== 'delimiter');
			}

			result.reports = this.reports;

			this.reset();

			return result;
		}
	}

	class Parser {
		static tokens;
		static position;
		static reports;
		static rules = {
			callExpression: (node_) => {
				let node = {
					type: 'callExpression',
					range: {
						start: node_.range.start
					},
					callee: node_,
					arguments: undefined
				}

				if(this.token.type !== 'parenthesisOpen') {
					return;
				}

				this.position++;
			//	node.arguments = this.rules.functionArguments();

				if(this.token.type !== 'parenthesisClosed') {
					this.position = node_.range.end+1;

					return;
				}

				node.range.end = this.position++;

				return node;
			},
			caseDeclaration: () => {},
			chainExpression: (node_) => {
				let node = {
					type: 'chainExpression',
					range: {
						start: node_.range.start
					},
					optional: undefined,
					composite: node_,
					member: undefined
				}

				if(this.token.type !== 'operator' || !['.', '?.'].includes(this.token.value)) {
					return;
				}

				node.optional = this.token.value === '?.';
				this.position++;
				node.member = this.rules.identifier();

				if(node.member == null) {
					this.position = node_.range.end+1;

					return;
				}

				node.range.end = node.member.range.end;

				return node;
			},
			classBody: () => {
				return this.rules.compositeBody('class');
			},
			classDeclaration: (anonymous) => {
				let node = {
					type: 'class'+(!anonymous ? 'Declaration' : 'Expression'),
					range: {},
					id: undefined,
					inheritance: undefined,
					body: undefined
				}

				if(this.token.type !== 'keywordClass') {
					return;
				}

				node.range.start = this.position++;
				node.id = this.rules.identifier();
				node.inheritance = this.rules.typeInheritanceClause();
				node.body = this.rules.classBody();

				if(anonymous) {
					delete node.id;
				} else
				if(node.id == null) {
					this.report(2, node.range.start, 'No identifier set for class.');
				}
				if(node.body == null) {
					this.report(1, node.range.start, 'Class doesn\'t have body.');
				}

				node.range.end =
					node.body?.range.end ??
					node.inheritance?.range.end ??
					node.id?.range.end ??
					node.range.start;

				return node;
			},
			classExpression: () => {
				return this.rules.classDeclaration(true);
			},
			classMembers: () => {
				return this.rules.compositeMembers([
					'classDeclaration',
					'enumerationDeclaration',
					'functionDeclaration',
					'namespaceDeclaration',
					'protocolDeclaration',
					'structureDeclaration',
					'variableDeclaration'
				]);
			},
			compositeBody: (type) => {
				let node = {
					type: type+'Body',
					range: {},
					members: []
				}

				if(this.token.type !== 'braceOpen') {
					return;
				}

				node.range.start = this.position++;
				node.members = this.rules[type+'Members']?.() ?? []

				if(this.token.type !== 'braceClosed') {
					this.position = node.range.start;

					return;
				}

				node.range.end = this.position++;

				return node;
			},
			compositeMembers: (types) => {
				let nodes = []

				while(true) {
					let node;

					for(let type of types) {
						node = this.rules[type]?.();

						if(node != null) {
							nodes.push(node);

							break;
						}
					}
					if(node != null) {
						continue;
					}

					node = nodes.findLast(v => v.type === 'unawaredMember');

					if(node == null || node !== nodes.at(-1)) {
						node = {
							type: 'unawaredMember',
							range: {
								start: this.position,
								end: this.position
							},
							scopeLevel: 1
						}

						nodes.push(node);
					} else {
						node.range.end = this.position;
					}

					switch(this.token.type) {
						case 'braceOpen':	node.scopeLevel++; break;
						case 'braceClosed':	node.scopeLevel--; break;
					}

					if(node.scopeLevel === 0 || this.position === this.tokens.length) {
						node.range.end--;

						if(node.range.start > node.range.end) {
							nodes = nodes.filter(v => v !== node);
						}

						break;
					}

					this.position++;
				}

				for(let node of nodes.filter(v => v.type === 'unawaredMember')) {
					delete node.scopeLevel;

					this.report(1, node.range.start, 'Unawared member type at range of tokens ['+node.range.start+':'+node.range.end+'].');
				}

				return nodes;
			},
			enumerationBody: () => {
				return this.rules.compositeBody('enumeration');
			},
			enumerationDeclaration: (anonymous) => {
				let node = {
					type: 'enumeration'+(!anonymous ? 'Declaration' : 'Expression'),
					range: {},
					id: undefined,
					inheritance: undefined,
					body: undefined
				}

				if(this.token.type !== 'keywordEnum') {
					return;
				}

				node.range.start = this.position++;
				node.id = this.rules.identifier();
				node.inheritance = this.rules.typeInheritanceClause();
				node.body = this.rules.enumerationBody();

				if(anonymous) {
					delete node.id;
				} else
				if(node.id == null) {
					this.report(2, node.range.start, 'No identifier set for enumeration.');
				}
				if(node.body == null) {
					this.report(1, node.range.start, 'Enumeration doesn\'t have body.');
				}

				node.range.end =
					node.body?.range.end ??
					node.inheritance?.range.end ??
					node.id?.range.end ??
					node.range.start;

				return node;
			},
			enumerationExpression: () => {
				return this.rules.enumerationDeclaration(true);
			},
			enumerationMembers: () => {
				return this.rules.compositeMembers(['caseDeclaration']);
			},
			floatLiteral: () => {
				let node = {
					type: 'floatLiteral',
					range: {},
					value: undefined
				}

				if(this.token.type !== 'numberFloat') {
					return;
				}

				node.value = this.token.value;
				node.range.start =
				node.range.end = this.position++;

				return node;
			},
			forStatement: () => {},
			functionBody: () => {
				return this.rules.compositeBody('function');
			},
			functionDeclaration: (anonymous) => {
				let node = {
					type: 'function'+(!anonymous ? 'Declaration' : 'Expression'),
					range: {},
					id: undefined,
					signature: undefined,
					body: undefined
				}

				if(this.token.type !== 'keywordFunc') {
					return;
				}

				node.range.start = this.position++;
				node.id = this.rules.identifier() ?? this.rules.operator();
				node.signature = this.rules.functionSignature();
				node.body = this.rules.functionBody();

				if(anonymous) {
					delete node.id;
				} else
				if(node.id == null) {
					this.report(2, node.range.start, 'No identifier set for function.');
				}
				if(node.signature == null) {
					this.report(2, node.range.start, 'Function lacks of signature.');
				}
				if(node.body == null) {
					this.report(1, node.range.start, 'Function doesn\'t have body.');
				}

				node.range.end =
					node.body?.range.end ??
					node.signature?.range.end ??
					node.id?.range.end ??
					node.range.start;

				return node;
			},
			functionExpression: () => {
				return this.rules.functionDeclaration(true);
			},
			functionMembers: () => {
				return this.rules.compositeMembers([
					'postfixExpression',  // Postfixes must be parsed before nodes that they can begin with
					'classDeclaration',
					'enumerationDeclaration',
					'forStatement',
					'functionDeclaration',
					'ifStatement',
					'importDeclaration',
					'namespaceDeclaration',
					'protocolDeclaration',
					'structureDeclaration',
					'variableAssignment',
					'variableDeclaration',
					'whileStatement'
				]);
			},
			functionParameter: () => {},
			functionSignature: () => {
				let node = {
					type: 'functionSignature',
					range: {},
					parameters: undefined
				}

				if(this.token.type !== 'parenthesisOpen') {
					return;
				}

				node.range.start = this.position++;

				while(true) {
					let node_ = this.rules.functionParameter();

					if(node_ == null) {
						break;
					}

					node.parameters.push(node_);

					if(this.token.type !== 'operator' || this.token.value !== ',') {
						break;
					}

					this.position++;
				}

				if(this.token.type !== 'parenthesisClosed') {
					this.position = node.range.start;

					return;
				}

				node.range.end = this.position++;

				return node;
			},
			identifier: () => {
				let node = {
					type: 'identifier',
					range: {},
					value: undefined
				}

				if(this.token.type !== 'identifier') {
					return;
				}

				node.value = this.token.value;
				node.range.start =
				node.range.end = this.position++;

				return node;
			},
			ifStatement: () => {},
			implicitChainExpression: () => {
				let node = {
					type: 'implicitChainExpression',
					range: {},
					member: undefined
				}

				if(this.token.type !== 'operator' || this.token.value !== '.') {
					return;
				}

				node.range.start = this.position++;
				node.member = this.rules.identifier();

				if(node.member == null) {
					this.position = node.range.start;

					return;
				}

				node.range.end = node.member.range.end;

				return node;
			},
			importDeclaration: () => {},
			initializerClause: () => {
				let node = {
					type: 'initializerClause',
					range: {},
					id: undefined
				}

				if(this.token.type !== 'operator' || this.token.value !== '=') {
					return;
				}

				node.value = this.token.value;
				node.range.start =
				node.range.end = this.position++;
				node.id = this.rules.identifier();

				if(node.id == null) {
					this.position = node.range.start;

					return;
				}

				node.range.end = node.id.range.end;

				return node;
			},
			integerLiteral: () => {
				let node = {
					type: 'integerLiteral',
					range: {},
					value: undefined
				}

				if(this.token.type !== 'numberInteger') {
					return;
				}

				node.value = this.token.value;
				node.range.start =
				node.range.end = this.position++;

				return node;
			},
			logicalExpression: () => {},
			module: () => {
				let node = {
					type: 'module',
					range: {
						start: 0,
						end: 0
					},
					members: this.rules.functionMembers()
				}

				if(node.members.length > 0) {
					node.range.start = node.members[0].range.start;
					node.range.end = node.members.at(-1).range.end;
				}

				return node;
			},
			namespaceBody: () => {
				return this.rules.compositeBody('namespace');
			},
			namespaceDeclaration: (anonymous) => {},
			namespaceExpression: () => {
				return this.rules.namespaceDeclaration(true);
			},
			namespaceMembers: () => {
				return this.rules.compositeMembers([
					'classDeclaration',
					'enumerationDeclaration',
					'functionDeclaration',
					'namespaceDeclaration',
					'protocolDeclaration',
					'structureDeclaration',
					'variableDeclaration'
				]);
			},
			operator: () => {
				let node = {
					type: 'operator',
					range: {},
					value: undefined
				}

				if(this.token.type !== 'operator') {
					return;
				}

				node.value = this.token.value;
				node.range.start =
				node.range.end = this.position++;

				return node;
			},
			postfixExpression: () => {
				let node =
					this.rules.classExpression() ??
					this.rules.enumerationExpression() ??
					this.rules.floatLiteral() ??
					this.rules.functionExpression() ??
					this.rules.identifier() ??
					this.rules.implicitChainExpression() ??
					this.rules.integerLiteral() ??
					this.rules.namespaceExpression() ??
					this.rules.protocolExpression() ??
					this.rules.stringLiteral() ??
					this.rules.structureExpression();

				if(node == null) {
					return;
				}

				for(let i = 0; i < Infinity; i++) {
					let node_ =
						this.rules.chainExpression(node) ??
						this.rules.callExpression(node) ??
						this.rules.subscriptExpression(node);

					if(node_ == null) {
						if(i === 0) {
							this.position = node.range.start;

							return;
						}

						break;
					}

					node = node_;
				}

				return node;
			},
			protocolBody: () => {
				return this.rules.compositeBody('protocol');
			},
			protocolDeclaration: (anonymous) => {
				let node = {
					type: 'protocol'+(!anonymous ? 'Declaration' : 'Expression'),
					range: {},
					id: undefined,
					inheritance: undefined,
					body: undefined
				}

				if(this.token.type !== 'keywordProtocol') {
					return;
				}

				node.range.start = this.position++;
				node.id = this.rules.identifier();
				node.inheritance = this.rules.typeInheritanceClause();
				node.body = this.rules.protocolBody();

				if(anonymous) {
					delete node.id;
				} else
				if(node.id == null) {
					this.report(2, node.range.start, 'No identifier set for protocol.');
				}
				if(node.body == null) {
					this.report(1, node.range.start, 'Protocol doesn\'t have body.');
				}

				node.range.end =
					node.body?.range.end ??
					node.inheritance?.range.end ??
					node.id?.range.end ??
					node.range.start;

				return node;
			},
			protocolExpression: () => {
				return this.rules.protocolDeclaration(true);
			},
			protocolMembers: () => {
				return this.rules.compositeMembers([
					'classDeclaration',
					'enumerationDeclaration',
					'functionDeclaration',
					'namespaceDeclaration',
					'protocolDeclaration',
					'structureDeclaration',
					'variableDeclaration'
				]);
			},
			stringLiteral: () => {
				let node = {
					type: 'stringLiteral',
					segments: [],
					expressions: []
				}

				if(!this.token.type.startsWith('string')) {
					return;
				}

			//	return node;
			},
			structureBody: () => {
				return this.rules.compositeBody('structure');
			},
			structureDeclaration: (anonymous) => {
				let node = {
					type: 'structure'+(!anonymous ? 'Declaration' : 'Expression'),
					range: {},
					id: undefined,
					inheritance: undefined,
					body: undefined
				}

				if(this.token.type !== 'keywordStruct') {
					return;
				}

				node.range.start = this.position++;
				node.id = this.rules.identifier();
				node.inheritance = this.rules.typeInheritanceClause();
				node.body = this.rules.structureBody();

				if(anonymous) {
					delete node.id;
				} else
				if(node.id == null) {
					this.report(2, node.range.start, 'No identifier set for structure.');
				}
				if(node.body == null) {
					this.report(1, node.range.start, 'Structure doesn\'t have body.');
				}

				node.range.end =
					node.body?.range.end ??
					node.inheritance?.range.end ??
					node.id?.range.end ??
					node.range.start;

				return node;
			},
			structureExpression: () => {
				return this.rules.structureDeclaration(true);
			},
			structureMembers: () => {
				return this.rules.compositeMembers([
					'classDeclaration',
					'enumerationDeclaration',
					'functionDeclaration',
					'namespaceDeclaration',
					'protocolDeclaration',
					'structureDeclaration',
					'variableDeclaration'
				]);
			},
			subscriptExpression: (node_) => {
				let node = {
					type: 'subscriptExpression',
					range: {
						start: node_.range.start
					},
					composite: node_,
					arguments: undefined
				}

				if(this.token.type !== 'bracketOpen') {
					return;
				}

				this.position++;
			//	node.arguments = this.rules.functionArguments();

				if(this.token.type !== 'bracketClosed') {
					this.position = node_.range.end+1;

					return;
				}

				node.range.end = this.position++;

				return node;
			},
			typeInheritanceClause: () => {
				let node = {
					type: 'typeInheritanceClause',
					range: {},
					identifiers: []
				}

				if(this.token.type !== 'operator' || this.token.value !== ':') {
					return;
				}

				node.range.start = this.position++;

				while(true) {
					let node_ = this.rules.identifier();

					if(node_ == null) {
						break;
					}

					node.identifiers.push(node_);

					if(this.token.type !== 'operator' || this.token.value !== ',') {
						break;
					}

					this.position++;
				}

				if(node.identifiers.length === 0) {
					this.position = node.range.start;

					return;
				}

				node.range.end = node.identifiers.at(-1).range.end;

				return node;
			},
			variableAssignment: () => {
				let node = {
					type: 'variableAssignment',
					range: {},
					identifier: undefined,
					operator: undefined,
					value: undefined
				}
			},
			variableDeclaration: () => {
				let node = {
					type: 'variableDeclaration',
					range: {},
					kind: undefined,
					initializers: []
				}
			},
			whileStatement: () => {}
		}

		static get token() {
			return this.getToken();
		}

		static getToken(offset = 0) {
			return this.tokens[this.position+offset] ?? {
				position: undefined,
				location: undefined,
				type: '',
				value: ''
			}
		}

		static report(level, position, string) {
			let location = this.tokens[position].location;

			this.reports.push({
				level: level,
				location: location,
				string: string
			});
		}

		static reset() {
			this.tokens = []
			this.position = 0;
			this.reports = []
		}

		static parse(lexerResult) {
			this.reset();

			this.tokens = lexerResult.tokens;

			let result = {
				tree: this.rules.module(),
				reports: this.reports
			}

			this.reset();

			return result;
		}
	}

	class Interpreter {
		static memory = [
			{
				address: 0,
				inheritance: ['Namespace'],
				members: [
					{
						accessibility: ['public', 'static'],
						constant: false,
						title: 'TestClass',
						typed: true,
						inheritance: [1],
						nillable: true,
						value: '1',
						observers: {}
					},
					{
						accessibility: ['public', 'static'],
						constant: true,
						title: 'testPi',
						typed: true,
						inheritance: ['float'],
						nillable: true,
						value: '3.14',
						observers: {}
					},
					{
						accessibility: ['public', 'static'],
						constant: false,
						title: 'testClassInstance',
						typed: true,
						inheritance: [2],
						nillable: true,
						value: '3',
						observers: {}
					},
					{
						accessibility: ['public'],
						constant: false,
						title: 'computedInstanceProperty',
						typed: false,
						inheritance: [],
						nillable: true,
						value: null,
						observers: {
							willGet: null, // Function address,
							get: null,
							didGet: null,
							willSet: null,
							set: null,
							didSet: null,
							willDelete: null,
							delete: null,
							didDelete: null
						}
					}
				],
				observers: [
					{
						type: 'chain', // 'subscript'
						willGet: null, // Function address,
						get: null,
						didGet: null,
						willSet: null,
						set: null,
						didSet: null,
						willDelete: null,
						delete: null,
						didDelete: null
					}
				],
				scope: null,
				retains: 1
			},
			{
				address: 1,
				inheritance: ['Class'],
				members: [
					{
						accessibility: ['public', 'static'],
						constant: true,
						title: 'init',
						typed: true,
						inheritance: [
							/*
							{
								type: 'Signature',
								parameters: [
									{
										generic: true,
										typed: false,
										inheritance: [],
										nillable: true,
										variadic: true
									},
									{
										generic: false,
										typed: false,
										inheritance: [],
										nillable: true,
										variadic: true
									}
								],
								return: {
									typed: true,
									inheritance: ['bool'],
									nillable: false
								},
								throw: {
									typed: false,
									inheritance: [],
									nillable: true
								}
							}
							*/
							'Function'
						],
						nillable: false,
						value: '2',
						observers: {}
					},
					{
						accessibility: ['public'],
						constant: false,
						title: 'testVariable',
						typed: true,
						inheritance: ['int'],
						nillable: true,
						value: null,
						observers: {}
					}
				],
				observers: [],
				scope: 0,
				retains: 1
			},
			{
				address: 2,
				inheritance: ['Function'],
				signature: {
					parameters: [
						/*
						{
							generic: true,
							label: null,
							title: 'A',
							inout: false,
							typed: false,
							inheritance: [],
							nillable: true,
							variadic: false
						},
						*/
						{
							generic: false,
							label: null,
							title: 'firstArgument',
							inout: false,
							typed: true,
							inheritance: ['float'],
							nillable: false,
							variadic: false
						},
						{
							generic: false,
							label: null,
							title: 'secondArgument',
							inout: false,
							typed: true,
							inheritance: ['bool'],
							nillable: true,
							variadic: false
						}
					],
					return: {
						typed: true,
						inheritance: ['bool'],
						nillable: true
					},
					throw: {}
				},
				body: '\ttestVariable = 2 print(\'Test: \'+firstArgument)\n\n\treturn secondArgument', // Function body from Parser result
				members: [
					{
						title: 'parametersCount',
						inheritance: ['int'],
						value: '2'
					}
				],
				scope: 1,
				retains: 1
			},
			{
				address: 3,
				inheritance: ['Object', 1],
				members: [
					{
						title: 'testVariable',
						value: '2'
					}
				],
				scope: 0,
				retains: 1
			}
		]
		static contexts = []

		static rules = {
			module: (node) => {
				let namespace = this.rules.namespace(node);

				if(node.members.length > 0) {
					this.rules.members(namespace, node.members);
				}
			},
			namespace: (node) => {

			},
			members: (context, members) => {

			}
		}

		static createInheritance(primary, ...secondary) {
			if(![
				'argument',
				'class',
				'enumeration',
				'function',
				'instance',
				'namespace',
				'protocol',
				'structure',
				'variable'
			].includes(primary)) {
				throw new RangeError();
			}
			if(['argument', 'variable'].includes(primary)) {
				if(
					![
						'_',
						'Any',
						'any',
						'bool',
						'float',
						'int',
						'string'
					].includes(secondary[0]) ||
					secondary?.some(v => typeof v !== 'string' && !Number.isInteger(v))
				) {
					throw new TypeError();
				}
			}

			return [primary, ...secondary]
		}

		static createAccessibility(...values) {
			for(value of values) {
				if(![
					'private',
					'protected',
					'public',
					'static'
				].includes(value)) {
					return;
				}
			}

			return values;
		}

		static createMember(inheritance, parameters) {
			let member;

			if(inheritance[0] === 'variable') {
				member = {
					/*
					accessibility: accessibility,
					constant: constant,
					title: title,
					typed: typed,
					inheritance: inheritance,
					nillable: nillable,
					value: value
					*/
				}
			}
			return member;
		}

		static getComposite(address) {
			let composite = this.memory.find(v => v.address === address);

			if(composite == null) {
				return;
			}

			return new Proxy(composite, {
				get: (t, k) => {
					if(k === 'metaSelf') {
						return t;
					}

					let members = t.members ?? [],
						member = members.find(v => v.title === k),
						title = member?.title,
						inheritance = member?.inheritance ?? [],
						value = member?.value;

					if(member == null) {
						return;
					}

					if(inheritance.length > 0 && inheritance.every(v => Number.isInteger(v))) {
						let address = value*1;

						return this.getComposite(address);
					} else {
						return member;
					}
				},
				ownKeys: (t) => {
					let members = t.members ?? [],
						keys = members.map(v => v.title);

					keys.push('metaSelf');

					return keys;
				},
				getOwnPropertyDescriptor: (t, k) => {
					if(k === 'metaSelf') {
						return {
							enumerable: true,
							configurable: true,
							value: t
						}
					}

				    let members = t.members ?? [],
				    	member = members.find(v => v.title === k),
				    	inheritance = member?.inheritance ?? [],
				    	value = member?.value;

			    	if(member == null) {
			    		return;
			    	}

			    	if(inheritance.length > 0 && inheritance.every(v => Number.isInteger(v))) {
			    		let address = value*1;

			    		member = this.getComposite(address);
			    	}

				    return {
				    	enumerable: true,
				    	configurable: true,
				    	value: member
				    }
				}
			});
		}

		static createMainContext() {
		//	this.memory.push();

			if(this.contexts.length === 0) {
				this.contexts.push(this.getComposite(0));
			}
		}
	}

	let lexerResult = Lexer.tokenize(code, 2),
		parserResult = Parser.parse(lexerResult),
		tokens = lexerResult.tokens,
		tree = parserResult.tree,
		reports = [...lexerResult.reports, ...parserResult.reports]
					.sort((a, b) => a.location.line-b.location.line || a.location.column-b.location.column);

	/*
	for(let k = tokens.length-1; k >= 0; k--) {
		let textbox = document.getElementById('input'),
			position = tokens[k].position,
			type = tokens[k].type,
			value = tokens[k].value,
			length = value.length,
			color;

		if(token.type === 'operator') {
			color = 'red';
		}
	}
	*/
	for(let report of reports) {
		let level = report.level.toString()
						.replace('0', 'Info')
						.replace('1', 'Warning')
						.replace('2', 'Error'),
			line = report.location.line+1,
			column = report.location.column+1,
			string = report.string;

		console.log(line+':'+column+': '+level+': '+string);
	}
	console.log(tokens);
	console.log(tree);
</script>
</body>
</html>
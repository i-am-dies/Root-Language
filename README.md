![Logo](./Resources/Logo.png)

## RoadMap

### Основные компоненты
- Lexer -> Готов
- Parser -> В процессе
- Interpreter -> Начата теоретическая часть

- Перевод на компилируемый ЯП -> Не начат

### Запланированные идеологические преимущества по сравнению со Swift (в т.ч. почерпнутые из JS):
- Многофункциональный интерпретатор
   - Локальные экземпляры внутри кода (песочницы), с возможной передачей контекста
   - Уровни метапрограммирования: полное редактирование, частичное редактирование, частичное чтение, нет
   - Использование кастомных функций в песочницах, таких как import(), print() и т.д.
   - Исполнение по предельному уровню ошибок (допущение или не- вольного синтаксиса)
   - Отладочная консоль для просмотра и действий с памятью (в виде окна с иерархией композитов и строкой ввода)
   - Импорт и экспорт текущего состояния памяти из файла
- Метапрограммирование (расширенное взаимодействие с композитами во время исполнения вне отладки)
   - Чтение и изменение внутренних свойств, недоступное обычными путями: список наследственности, количество retain'ов, переключение типа 'class' на 'enum', у полей уровня доступа 'private' на 'public', и т.п.
   - Получение вызывающего композита из области видимости функции
- Композитный тип namespace
- Опциональная типизация переменных

## Спецификация

### Типы

#### Композиты

В Root отдаётся предпочтение объёктной ориентированности, поэтому большая часть типов является композитами.

| Композит          | Мемберы            | Родители          | Вызываемость | Копируемость |
|-------------------|--------------------|-------------------|--------------|--------------|
| Объект            | Только значения    | Класс             | Нет          | Нет          |
| Класс             | Любые              | Класс и протоколы | Да           | Нет          |
| Перечисление      | Без операторов     | Протоколы         | Нет          | Да           |
| Пространство имён | Любые              | Нет               | Нет          | Нет          |
| Протокол          | Только определения | Протоколы         | Нет          | Нет          |
| Структура         | Любые              | Протоколы         | Да           | Да           |
| Функция           | Предопределённые   | Нет               | Да           | Нет          |

Пространства имён (следовательно и тела функций), в отличии от других композитов, могут содержать объявления импорта и операторов.

Родителями протоколов в прямом смысле могут быть только другие протоколы, но в их списках наследственности могут указываться любые композитные типы кроме функций. Таким образом устанавливаются ограничения приемственности в тех случаях, когда протокол предполагается для использования определённой группой типов.

В общем случае в коде в качестве мемберов могут выступать как обычные переменные с любыми значениями, так и все вышеперечисленные композиты в виде объявлений.

Для доступа к сырому представлению композитов предназначен мембер `metaSelf`.

#### Примитивы

К примитивам относятся `string`, `int`, `float` и `bool`. Переменные и константы примитивных типов передаются копированием значений, а операторы действий над ними не могут быть переопределены. Обычно значения примитивных типов инициализируются и используются неявно внутри своих обёрточных композитов.

### Синтаксис

#### Объявления

Объявления подразделяются на 4 группы: импорты, операторы, мемберы и наблюдатели. Объявление обрабатывается раньше другого кода, а его значение считывается в разных местах по идентификатору. Идентификаторы каждого из объявлений, находящихся в одной группе, обязаны быть уникальными.

Каждое объявление создаёт особую структуру внутри композита, в котором оно выполнено. Не считая мемберов, непосредственный доступ к таким структурам имеется только у интерпретатора.

##### Операторы

Операторы состоят из двух объявлений с общим идентификатором, одно из которых - структура, отвечающая за восприятие, а другое - функция, определяющая поведение.

```
postfix operator ++

private infix operator == {
      associativity: left
      precedence: 64
}

struct Integer {
      private var value: int

      init(v: int) {
            value = v
      }

      postfix func ++(v: inout Self) {
          v = v+1
      }

      func ==(lhs: Self, rhs: Self) {
          return lhs.value == rhs.value
      }
}
```

##### Переменные и константы

Переменные и константы объявляются ключевыми словами `var` и `const`.

```
'var' <Переменная или константа>

<Переменная или константа> = <Идентификатор>[':' <Тип>][ '=' <Выражение>][',' <Переменная или константа>]
```

Значением переменной или константы может быть примитив или ссылка на композит.

Любая переменная и константа также может "содержать" `nil` (ничего), если её тип или один из типов указан со знаком `?` на конце. В противном случае она обязана содержать значение на момент интерпретации объявления. Это относится и к функциям - нельзя передать аргумент `nil` в обязательный параметр, и нельзя отдать `nil` как обязательное возвратное значение. Аналогичным образом запрещается вставка `nil`-значений и записей, содержащих `nil`-ключи и/или значения, в массивы и словари с обязательными типами содержания соответственно. При этом, полное отсутствие значений и записей в таких массивах и словарях не запрещается.

```
var empty                                             Пустая переменная с необязательным значением любого типа
var testingVariable = 1                               Переменная с необязательным значением любого типа, инициализируемая со значением Integer(1)
var testingVariable: _? = 1

const firstConstant = Number.Pi,                      Две константы с разными типами значений: любым-необязательным и строковым
      secondConstant: String = 'Example of a string'
```

##### Наблюдатели

Наблюдатели не объявляются самостоятельно, так как закрепляются за другими мемберами, или за всем композитом вцелом. Они используются для изменения обычного поведения при записи и чтении в них.

Всего есть 9 идентификаторов состояний, для перехвата наблюдателями: `willGet`, `get`, `didGet`, `willSet`, `set`, `didSet`, `willDelete`, `delete` и `didDelete`. Также, верхнеуровневые наблюдатели подразделяются на два типа: `chain` и `subscript`.

```
class StepCounter {
    var steps: Integer = 0 {
        willSet {
            print('About to set steps to \(newValue)')
        }

        didSet {
            if steps > oldValue {
                print('Added \(steps-oldValue) steps')
            }
        }
    }
}

var stepCounter = StepCounter()

stepCounter.steps = 200
// About to set steps to 200
// Added 200 steps

stepCounter.steps = 360
// About to set steps to 360
// Added 160 steps

stepCounter.steps = 896
// About to set steps to 896
// Added 536 steps
```

Любой мембер, имеющий наблюдателей состояний `get`, `set` и `delete`, не теряет своего внутреннего хранилища данных, но во избежание рекурсии при его записи и чтении из области видимости наблюдателя необходимо пользоваться переменной или константой `value`. Эта переменная чуть менее важна, но всё ещё несёт своё предназначение и в других состояниях.

Синтаксис не предполагает объявление наблюдателей с чем угодно, кроме переменных и констант, тем не менее, технически любой мембер их поддерживает.

#### Указание типов

```
_                                Любой тип
                                 Предназначен для использования в местах, где указание типа синтаксически необходимо
                                 Фактически отключает ограничение при записи мембера

                                 Примитивы
any                              Любой
string                           Строка
int                              Целое число
float                            Число с плавающей точкой
bool                             Логическое значение

                                 Композиты
Any                              Любой
Self                             Композит зоны видимости
Object                           Объект
Class                            Класс
Enumeration                      Перечисление
Namespace                        Пространство имён
Protocol                         Протокол
Structure                        Структура
Function                         Функция

                                 Функции
()                               Любая (композит типа Function)
<...>(...) async? throws? -> _?
<T>(T, T)                        Функция с дженерик-параметром и обычными параметрами того же дженерик-типа без возвратного значения
(Integer, Number) -> Boolean     Функция с двумя параметрами типа Integer и Number соответственно и возвратным значением типа Boolean
([]..., ...) async throws -> _   Асинхронная, кидающая исключения функция, с любым количеством параметров типа Array в начале, и любыми параметрами после них, с возвратным значением любого типа
(() -> _)?                       Необязательная функция без параметров с возвратным значением любого типа

                                 Массивы
[]                               Любой (объект типа Array)
[_?]
Array
Array<_?>
[_]                              Массив со значениями любого типа
Array<_>

                                 Словари
[:]                              Любой (объект типа Dictionary)
[_?: _?]
Dictionary
Dictionary<_?, _?>
[_: _]                           Словарь с ключами и значениями любого типа
Dictionary<_, _>
[String: _]                      Словарь с ключами типа String и значениями любого типа
Dictionary<String, _>

                                 Прочие
Custom.Self                      Композит, в родительском древе которого находится тип Custom, или который сам им является
Custom                           Объект, в родительском древе которого находится тип Custom
```

Сразу несколько типов может быть указано в одном месте при помощи знака `&`, если `,` используется для разделения на более высоком уровне.

```
var multitypeVariable: Integer & String  Переменная, принимающая значения типов Integer и String
```

#### Удаление

Ключевое слово `delete` производит попытку удаления мембера из композита.

```
'delete' <Идентификатор>[<Путь к мемберу>]

<Путь к мемберу> = ['?']'.'<Идентификатор>[<Путь к мемберу>]
<Путь к мемберу> = '['<Аргументы>']'[<Путь к мемберу>]
```

Если композит не поддерживает этот оператор, определяя наблюдателей `willDelete`, `delete` и `didDelete`, возвращаемым значением будет `Boolean(false)`.

```
delete variable           Удаление из композита области видимости
delete instance.variable  Удаление из другого композита
delete array[0]           Удаление из массива
```
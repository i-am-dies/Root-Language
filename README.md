![Logo](./Resources/Logo.png)

## RoadMap

### Назначение

Язык программирования, обладающий высокой динамичностью, безопасностью во время написания и выполнения, простым удобочитаемым синтаксисом и поддержкой ряда низкоуровневых возможностей.

Некоторые языки, такие как Swift, Groovy, TS или JS (в частности NW.JS), отвечают этим требованиям, но либо не в полном объёме, либо с оговорками. К примеру, Swift неспособен загружать и выполнять исходный код на лету, в Groovy и TS с этим тоже есть трудности, JS в принципе не имеет полноценных типизации и параллелизации. Это малая, но тем не менее существенная часть проблем, выявленных в ходе написания [Poppy DE](https://github.com/sziberov/Poppy-DE) (проекта, который изначально даже и не задумывался, как нечто грандиозное и требующее особого отношения).

### Этапы разработки
- Теория -> В процессе
- Лексер -> Относительно готов
- Парсер -> Относительно готов
- Интерпретатор -> В процессе
- Перевод на компилируемый ЯП -> Пока нет

### Чего нет в Swift, что есть/будет в Root:
- Многофункциональный интерпретатор
   - Локальные экземпляры (процессы) внутри кода (песочницы), с возможной передачей контекста
   - Кастомные определения глобальных мемберов в песочницах, таких как `import()`, `print()` или `process`...
   - Исполнение по предельному уровню ошибок синтаксиса
   - Мультипоточность (любая функция может быть вызвана асинхронно, включая вложенные вызовы, и обождена синхронно)
   - Автоматический выбор перегруженной функции при вызове (примитивного) словаря, который её хранит
   - Необязательнные метки параметров в объявлениях функций
   - Статичные мемберы у функций
   - Предельно точные десятичные числа, основанные на хранении и вычислении оных в виде строк
- Более удобное и безопасное устройство памяти
   - Автоматическое остлеживание доступности композитов и циклов удержания
   - Использование родительской области видимости в моменты вызова супер-функции по умолчанию
   - Доступ к переменным, объявленным внутри функции, из вложенного в неё объявления композита
   - Оповещение наблюдателей об уничтожении композитов
   - Динамический поиск мемберов в ссылочном значении переменной вне зависимости от заданного ей типа
   - Сохранение и загрузка текущего состояния из файла
   - Отладочная консоль (в виде окна с иерархией композитов и строкой ввода)
- Метапрограммирование (расширенное взаимодействие с композитами во время исполнения вне отладки)
   - Чтение и изменение внутренних свойств, описывающих композит
   - Получение вызывающего из функции
   - Получение списка наследующих композитов
   - Получение исходного кода
   - Создание и вызов функции с переопределённым `self` через `bind()` и `apply()`
   - Выполнение кода в определённом `namespace`
   - Уровни доступа: полное редактирование, частичное редактирование, частичное чтение, нет
- Расширенная типизация
   - По-настоящему опциональные типы вместо обёрточного `Optional`
   - Явный композитный тип `namespace` для разграничения и группирования пространств имён
   - Объединённые типы
   - Разделение вложенных типов на статичные и объектные
   - Все композиты - объекты первого класса
   - Анонимные inline протоколы
   - Ссылки на типы из сигнатур функций
   - Значения по умолчанию, в т.ч. в протоколах
   - Сравнение композитных типов по определению или содержимому в случаях, когда по ссылке - неоптимально (песочницы, мультипоточность)
- Новые операторы и ключевые слова
   - `final` (вместо `const`) для объявления констант более широкого спектра
   - `friend` для предоставления доступа к непубличным мемберам ограниченному кругу композитов
   - `in` для проверки наличия мембера в композите
   - `protected` для приватных, но всё ещё наследуемых, мемберов
   - `virtual` для объявления ожидаемо перегружаемых функций
   - `when` (вместо `switch`) для переключения потока кода
   - `with` для смены области видимости
   - `...` (spread) для смешивания коллекций

## Спецификация

### Типы

#### Примитивы

| Примитив                 | Явный |
|--------------------------|-------|
| Логическое значение      | Да    |
| Словарь                  | Да    |
| Ссылка                   | Нет   |
| Строка                   | Да    |
| Указатель                | Нет   |
| Целое число              | Да    |
| Число с плавающей точкой | Да    |

Неявные примитивы существуют для поддержки композитных типов и доступны для взаимодействия лишь косвенно.

Значения примитивных типов передаются копированием, а операторы действий над ними не могут быть переопределены. Обычно они инициализируются и используются внутри своих обёрточных композитов без необходимости прямого взаимодействия.

#### Композиты

| Композит          | Мемберы              | Родители         | Вызываемость | Копируемость          |
|-------------------|----------------------|------------------|--------------|-----------------------|
| Класс             | Любые                | Класс, протоколы | Да           | Нет                   |
| Объект            | Значения             | Класс/структура  | Нет          | Родитель == структура |
| Перечисление      | Случаи, перечисления | Протоколы        | Нет          | Нет                   |
| Пространство имён | Любые                | Нет              | Нет          | Нет                   |
| Протокол          | Определения          | Протоколы        | Нет          | Нет                   |
| Структура         | Любые                | Протоколы        | Да           | Нет                   |
| Функция           | Статичные            | Нет              | Да           | Нет                   |

Пространства имён, в отличии от других композитов, могут содержать объявления импорта и операторов. Разрешается как прямое их объявление внутри тела, так и посредством функций (будет использовано первое ПИ в цепочке областей видимости).

Родителями протоколов в прямом смысле могут быть только другие протоколы, но в их списках наследственности могут указываться любые композитные типы кроме функций. Таким образом устанавливаются ограничения приемственности в тех случаях, когда протокол предполагается для использования определённой группой типов.

В общем случае в коде в качестве мемберов могут выступать как обычные переменные с любыми значениями, так и все вышеперечисленные композиты в виде объявлений.

Доступ к сырому представлению композитов в целях метапрограммирования осуществим посредством мембера `metaSelf`.

### Синтаксис

#### Объявления

Объявления подразделяются на 4 группы: импорты, операторы, мемберы и наблюдатели. Их значения считываются в разных местах по идентификаторам. Идентификаторы каждого из объявлений, находящихся в одной группе, обязаны быть уникальными. Исключение с внешней точки зрения составляют перегруженные функции, где поиск возможно осуществлять по типам и количеству параметров (внутренне эти объявления все равно являются примитивными словарями). У объявлений могут быть модификаторы, влияющие на внешний доступ к ним, или несущие другие эффекты.

##### Операторы

Операторы состоят из двух объявлений с одним общим идентификатором: структуры, отвечающей за восприятие, и функции, определяющей поведение.

```
postfix operator ++

private infix operator == {
    associativity: left
    precedence: 64
}

struct Integer {
    private var value: int

    init(v: int) {
        value = v
    }

    postfix func ++(v: inout Self) {
        v = v+1
    }

    func ==(lhs: Self, rhs: Self) {
        return lhs.value == rhs.value
    }
}
```

##### Классы

...

##### Перечисления

...

##### Пространства имён

...

##### Протоколы

...

##### Структуры

...

##### Функции

...

##### Переменные

Переменные объявляются ключевым словом `var`.

```
'var' <Переменная>[, <Переменная>]

<Переменная> = <Идентификатор>[':' <Тип>][ '=' <Выражение>]
```

Значением переменной может быть примитив или ссылка на композит.

Любая переменная также может "содержать" `nil` (ничего), если её тип или один из типов указан со знаком `?` на конце. В противном случае она обязана содержать значение на момент интерпретации объявления. Это относится и к функциям - нельзя передать аргумент `nil` в обязательный параметр, и нельзя отдать `nil` как обязательное возвратное значение. Аналогичным образом запрещается вставка `nil`-значений и записей, содержащих `nil`-ключи и/или значения, в массивы и словари с обязательными типами содержания соответственно. При этом, полное отсутствие значений и записей в таких массивах и словарях не запрещается.

```
var emptyVariable             Пустая переменная с необязательным значением любого типа
var testingVariable = 1,      Переменная с необязательным значением любого типа, инициализируемая со значением Integer(1)
    nillableVariable: _? = 1
```

По тому же принципу переменные могут содержать значения по умолчанию, которые будут автоматически установлены в момент обращения (ленивая инициализация). Для этого вместо `?` следует использовать `!`. Существует два правила использования умолчаний: тип должен содержать публичный неопциональный конструктор без параметров, а переменная не должна иметь более одного типа по умолчанию. Уточнение: переменные, которым было автоматически установлено значение, не становятся константами, им всё ещё можно задать `nil`, впоследствии переписав умолчание на новое. Последнее может быть полезно, если конструктор типа учитывает какие-либо условия даже без передачи аргументов.

```
var defaultVariable: Integer!  Переменная, инициализируемая по обращению со значением Integer(0)
```

Примитивные типы тоже поддерживают умолчания: `bool` - `false`, `dict` - `[:]`, `float` - `0.0`, `int` - `0`, `string` - `''`.

Помммо переменных с умолчаниями, ленивая инициализация распространяется на статичные переменные, и переменные объектов с модификатором `lazy`.

##### Наблюдатели

Наблюдатели не объявляются самостоятельно, так как закрепляются за другими мемберами, или за всем композитом вцелом. Они используются для изменения обычного поведения при записи и чтении в них.

Всего есть 9 идентификаторов состояний, для перехвата наблюдателями: `willGet`, `get`, `didGet`, `willSet`, `set`, `didSet`, `willDelete`, `delete` и `didDelete`. Также, верхнеуровневые наблюдатели подразделяются на два типа: `chain` и `subscript`.

```
class StepCounter {
    var steps: Integer = 0 {
        willSet {
            print('About to set steps to \(newValue)')
        }

        didSet {
            if steps > oldValue {
                print('Added \(steps-oldValue) steps')
            }
        }
    }
}

var stepCounter = StepCounter()

stepCounter.steps = 200
// About to set steps to 200
// Added 200 steps

stepCounter.steps = 360
// About to set steps to 360
// Added 160 steps

stepCounter.steps = 896
// About to set steps to 896
// Added 536 steps
```

Любой мембер, имеющий наблюдателей состояний `get`, `set` и `delete`, не теряет своего внутреннего хранилища данных, но во избежание рекурсии при его записи и чтении из области видимости наблюдателя необходимо пользоваться переменной `value`. Эта переменная чуть менее важна, но всё ещё несёт своё предназначение и в других состояниях.

Синтаксис не предполагает объявление наблюдателей с чем угодно, кроме переменных, тем не менее, технически любой мембер их поддерживает.

##### Модификаторы

...

#### Указание типов

```
_                                 Любой тип
                                  Предназначен для использования в местах, где указание типа синтаксически необходимо

                                  Примитивы
any                               Любой
bool                              Логическое значение
float                             Число с плавающей точкой
int                               Целое число
string                            Строка

                                  Композиты
Any                               Любой
Class                             Класс
Enumeration                       Перечисление
Function                          Функция
Namespace                         Пространство имён
Object                            Объект
Protocol                          Протокол
Structure                         Структура

                                  Функции
()                                Любая (композит типа Function)
<...>(...) awaits? throws? -> _?
<T>(T, T)                         Функция с дженерик-параметром любого типа и обычными параметрами того же дженерик-типа без возвратного значения
(Integer, Number) -> Boolean      Функция с двумя параметрами типа Integer и Number соответственно и возвратным значением типа Boolean
([]..., ...) awaits throws -> _   Ожидающая, кидающая исключения функция, с любым количеством параметров типа Array в начале, и любыми параметрами после них, с возвратным значением любого типа
(() -> _)?                        Необязательная функция без параметров с возвратным значением любого типа

                                  Массивы
[]                                Любой (объект типа Array)
[_?]
Array
Array<_?>
[_]                               Массив со значениями любого типа
Array<_>

                                  Словари
[:]                               Любой (объект типа Dictionary)
[_?: _?]
Dictionary
Dictionary<_?, _?>
[_: _]                            Словарь с ключами и значениями любого типа
Dictionary<_, _>
[String: _]                       Словарь с ключами типа String и значениями любого типа
Dictionary<String, _>

                                  Прочие
Custom.Self                       Композит, в родительском древе которого находится тип Custom, или который сам им является
Custom                            Объект, в родительском древе которого находится тип Custom
Self                              Композит зоны видимости
```

##### Объединённые типы

Если переменная должна принимать один из нескольких типов, следует использовать объединённый тип. Оный можно определить с помощью знака `|`. Объединённый тип имеет приоритет над пересекающимися.

```
var unionVariable: Integer | String | Boolean  Переменная, принимающая значения типа Integer, String и Boolean
```

##### Пересекающиеся типы

Переменная, которая должна принимать композит, соответствующий нескольким протоколам, определяется с использованием пересекающегося типа. В свою очередь подобный композит также определяется с ним в списке наследственности. Такой тип записывается с разделением через `&` в первом случае и через `,` во втором. Порядок значений влияния не имеет, но в списке может быть максимум один непротокольный композит.

```
class CustomCompositeA {}
class CustomCompositeB: CustomCompositeA, CustomProtocolA {}
class CustomCompositeC: CustomCompositeA, CustomProtocolA, CustomProtocolB {}

var intersectionVariable: CustomCompositeA & CustomProtocolB  Переменная, принимающая значения типа CustomCompositeA, соответствующего протоколу CustomProtocolB
```

#### Удаление

Ключевое слово `delete` производит попытку удаления мембера из композита.

```
'delete' <Идентификатор>[<Путь к мемберу>]

<Путь к мемберу> = ['?']'.'<Идентификатор>[<Путь к мемберу>]
<Путь к мемберу> = '['<Аргументы>']'[<Путь к мемберу>]
```

Если композит не поддерживает этот оператор, определяя наблюдателей `willDelete`, `delete` и `didDelete`, возвращаемым значением будет `Boolean(false)`.

```
delete variable           Удаление из композита области видимости
delete instance.variable  Удаление из другого композита
delete array[0]           Удаление из массива
```

### Память

#### Сборка мусора

Для управления временем жизни композитов в Root применяется развитый Автоматический Подсчёт Ссылок (Automatic Reference Counting).

Отличие от общепринятой реализации состоит в том, что каждый композит имеет свой собственный список удерживающих, который наполняется и опустошается за время выполнения кода. Использование такого списка позволяет динамически отслеживать и уведомлять о недоступности композитов, исключая из выборки циклы удержания, чего не может предоставить счётчик в виде обычного числа.

Композит А попадает в список удерживающих композита Б, если он действительно удерживает его. Действительное удержание означает прямую ссылаемость композита А на композит Б в своих адресах (не считая идентификатора и списка удерживающих), типе, импортах, мемберах или наблюдателях. То же самое условие, только наоборот (отсутствие ссылок), ведёт к выпадению из списка.

Автоматическое (не принудительное) решение об уничтожении композита принимается только в том случае, если тот неудерживаем значимо. Значимое удержание означает формальное удержание глобальным пространством имён, пространством имён текущей области видимости или значением возврата. В свою очередь композит А считается формально удерживаемым композитом Б, если он или хотя бы один из его списка удерживающих (рекурсивно) может быть распознан как композит Б.

Попытки очистки памяти происходят в четырёх случаях:
- После полного уничтожения удерживающего - все ранее удерживаемые им композиты.
- После удаления конкретной ссылки - ссылаемый композит.
- После выполнения инструкции - все созданные за момент её выполнения композиты.
- В момент возврата из тела функции (им.вв. синтаксический конструкт) - созданное для его выполнения пространство имён.

#### Наследование

Каждый композит имеет список адресов, указывающих на свои уровни наследования и область видимости. Эти адреса могут использоваться вручную, или автоматически для поиска мемберов. Как правило, они устанавливаются динамически в моменты вызова (де-)инициализаторов (для переключения между статичным контекстом и контекстом объекта), и назначаются по одному разу для других композитов в моменты создания.

Количество объектов при инициализации композита, наследуемого от другого композита, равняется количеству композитов (унаследованные + унаследовавший), что способствует удобству разделения всех мемберов: нет препятствий перегрузкам и нет случайного обращения к мемберам наследующих композитов.

Процесс инициализации начинается с создания всей цепочки объектов и вызова крайнего производного инициализатора с адресами уровней крайнего производного объекта. Предварительное создание всей цепочки необходимо для поддержки виртуальных мемберов, где поиск должен выполняться с новейших перегрузок. Перед выполнением инструкций инициализатора также выполняются объявления нестатичных мемберов. Инициализатор наследующего композита вправе не вызывать инициализатор наследуемого композита (что, впрочем, в большей части обессмысливает наследование и оставляет объект в подвешенном состоянии).

<details>
    <summary>Пример кода и неформальное описание выходной структуры памяти</summary>

```
class A {
    var a = 1

    init {}

    func b() { 2 }

    virtual func c() { 3 }
}

class B: A {
    var a = 4,
        b = 5

    init { super() }

    func c() { 6 }

    var d = 7
}

var b = B()
```

```
Класс А
    Адреса
        сам == Класс А
        Сам == Класс А
        Область видимости == Пространство имён Глобал
    Тип == Класс
    Инструкции
        а = 1
        б = Функция { 2 }
        в = функция (виртуально) { 3 }
    Мемберы
        инит == Функция #3

Функция инит
    Адреса
        Идентификатор = 3
        сам == Класс А
        Сам == Класс А
        Область видимости == Класс А
    Тип == Функция -> Объект А
    Инструкции
        вернуть сам

Класс Б
    Адреса
        сам == Класс Б
        Сам == Класс Б
        Область видимости == Пространство имён Глобал
    Тип == Класс: Класс А
    Инструкции
        а = 4
        б = 5
        в = Функция { 6 }
        г = 7
    Мемберы
        инит == Функция #5

Функция инит
    Адреса
        Идентификатор = 5
        сам == Класс Б
        Сам == Класс Б
        Область видимости == Класс Б
    Тип == Функция -> Объект Б
    Инструкции
        над()
        вернуть сам

Объект Б
    Адреса
        над == Объект А
        Над == Класс А
        сам == Объект Б
        Сам == Класс Б
        Область видимости == Класс Б
    Тип == Объект класса Б
    Мемберы
        а == 4
        б == 5
        в == Функция 9
        г == 7

Объект А
    Адреса
        сам == Объект А
        Сам == Класс А
        под == Объект Б
        Под == Класс Б
        Область видимости == Класс А
    Тип == Объект класса А
    Мемберы
        а == 1
        б == Функция #11
        в == Функция (виртуально) #12

Пространство имён Вызов<инит #5>  (существует временно)
    Адреса
        над == Объект А
        Над == Класс А
        сам == Объект Б
        Сам == Класс Б
        Область видимости == Класс Б

Функция в
    Адреса
        Идентификатор = 9
        над = Объект А
        Над = Класс А
        сам == Объект Б
        Сам == Класс Б
        Область видимости == Объект Б
    Тип == Функция
    Инструкции
        6

Пространство имён Вызов<инит #3>  (существует временно)
    Адреса
        сам == Объект А
        Сам == Класс А
        под == Объект Б
        Под == Класс Б
        Область видимости == Класс А

Функция б
    Адреса
        Идентификатор = 11
        сам == Объект А
        Сам == Класс А
        под == Объект Б
        Под == Класс Б
        Область видимости == Объект А
    Тип == Функция
    Инструкции
        2

Функция в
    Адреса
        Идентификатор = 12
        сам == Объект А
        Сам == Класс А
        под == Объект Б
        Под == Класс Б
        Область видимости == Объект А
    Тип == Функция
    Инструкции
        3
```
</details>
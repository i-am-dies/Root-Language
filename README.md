![Logo](./Resources/Logo.png)

## RoadMap

### Этапы разработки
- Теория -> В процессе
- Лексер -> Относительно готов
- Парсер -> Относительно готов
- Интерпретатор -> В процессе
- Перевод на компилируемый ЯП -> Пока нет

### Чего нет в Swift, что есть/будет в Root:
- Многофункциональный интерпретатор
   - Локальные экземпляры внутри кода (песочницы), с возможной передачей контекста
   - Кастомные определения глобальных мемберов в песочницах, таких как `import()`, `print()` или `process`...
   - Исполнение по предельному уровню ошибок синтаксиса
   - Мультипоточность (любая функция может быть вызвана асинхронно, включая вложенные вызовы, и обождена синхронно)
   - Необязательнные метки параметров при вызове функций
   - Статичные мемберы у функций
   - Предельно точные десятичные числа, основанные на хранении и вычислении оных в виде строк
- Более удобное и безопасное устройство памяти
   - Автоматическое остлеживание доступности композитов и ретейн-циклов
   - Использование родительской области видимости в моменты вызова супер-функции (в т.ч. инициализирующей)
   - Доступ к переменным, объявленным внутри функции, из вложенного в неё объявления композита
   - Оповещение наблюдателей об уничтожении композитов
   - Сохранение и загрузка текущего состояния из файла
   - Отладочная консоль (в виде окна с иерархией композитов и строкой ввода)
- Метапрограммирование (расширенное взаимодействие с композитами во время исполнения вне отладки)
   - Чтение и изменение внутренних свойств, описывающих композит
   - Получение вызывающего из функции
   - Получение списка наследующих композитов
   - Получение исходного кода
   - Создание и вызов функций в определённом `namespace` через `bind()` и `apply()`
   - Выполнение кода в определённом `namespace` через `with`
   - Уровни доступа: полное редактирование, частичное редактирование, частичное чтение, нет
- Расширенная типизация
   - По-настоящему опциональные типы вместо обёрточного Optional
   - Явный композитный тип `namespace` для разграничения и группирования пространств имён
   - Объединённые типы
   - Разделение вложенных типов на статичные и объектные
   - Выражения для всех композитов, а не только функций в виде замыканий
   - Анонимные inline протоколы
   - Сравнение композитных типов по определению или содержимому в случаях, когда прямое - неоптимально
   - (Необязательное) явное указание дженерик-типов при вызове функций
- Новые операторы и ключевые слова
   - `final` (вместо `const`) для объявления констант более широкого спектра
   - `in` для проверки наличия мембера в композите
   - `when` (вместо `switch`) для переключения потока кода
   - `with` для смены (расширения?) области видимости
   - `...` (spread) для смешивания коллекций

## Спецификация

### Типы

#### Примитивы

| Примитив                 | Явный |
|--------------------------|-------|
| Логическое значение      | Да    |
| Словарь                  | Да    |
| Ссылка                   | Нет   |
| Строка                   | Да    |
| Узел                     | Нет   |
| Указатель                | Нет   |
| Целое число              | Да    |
| Число с плавающей точкой | Да    |

Неявные примитивы существуют для поддержки композитных типов и доступны для взаимодействия лишь косвенно.

Значения примитивных типов передаются копированием, а операторы действий над ними не могут быть переопределены. Обычно они инициализируются и используются внутри своих обёрточных композитов без необходимости прямого взаимодействия.

#### Композиты

| Композит          | Мемберы              | Родители         | Вызываемость | Копируемость          |
|-------------------|----------------------|------------------|--------------|-----------------------|
| Класс             | Любые                | Класс, протоколы | Да           | Нет                   |
| Объект            | Значения             | Класс/структура  | Нет          | Родитель == структура |
| Перечисление      | Случаи, перечисления | Протоколы        | Нет          | Нет                   |
| Пространство имён | Любые                | Нет              | Нет          | Нет                   |
| Протокол          | Определения          | Протоколы        | Нет          | Нет                   |
| Структура         | Любые                | Протоколы        | Да           | Нет                   |
| Функция           | Статичные            | Нет              | Да           | Нет                   |

Пространства имён, в отличии от других композитов, могут содержать объявления импорта и операторов. Разрешается как прямое их объявление внутри тела, так и посредством функций (будет использовано первое ПИ в цепочке областей видимости).

Родителями протоколов в прямом смысле могут быть только другие протоколы, но в их списках наследственности могут указываться любые композитные типы кроме функций. Таким образом устанавливаются ограничения приемственности в тех случаях, когда протокол предполагается для использования определённой группой типов.

В общем случае в коде в качестве мемберов могут выступать как обычные переменные с любыми значениями, так и все вышеперечисленные композиты в виде объявлений.

Для доступа к сырому представлению композитов предназначен мембер `metaSelf`.

### Синтаксис

#### Объявления

Объявления подразделяются на 4 группы: импорты, операторы, мемберы и наблюдатели. Объявление обрабатывается раньше другого кода, а его значение считывается в разных местах по идентификатору. Идентификаторы каждого из объявлений, находящихся в одной группе, обязаны быть уникальными. Исключение составляют мемберы-композиты с параметрами, где поиск возможно осуществлять по типам и количеству параметров. У объявлений могут быть модификаторы, влияющие на внешний доступ к ним, или несущие другие эффекты.

Каждое объявление создаёт особую структуру внутри композита, в котором оно выполнено. Не считая мемберов, непосредственный доступ к этим структурам имеет только интерпретатор.

##### Операторы

Операторы состоят из двух объявлений с одним общим идентификатором: структуры, отвечающей за восприятие, и функции, определяющей поведение.

```
postfix operator ++

private infix operator == {
      associativity: left
      precedence: 64
}

struct Integer {
      private var value: int

      init(v: int) {
            value = v
      }

      postfix func ++(v: inout Self) {
          v = v+1
      }

      func ==(lhs: Self, rhs: Self) {
          return lhs.value == rhs.value
      }
}
```

##### Классы

...

##### Перечисления

...

##### Пространства имён

...

##### Протоколы

...

##### Структуры

...

##### Функции

...

##### Переменные

Переменные объявляются ключевым словом `var`.

```
'var' <Переменная>[, <Переменная>]

<Переменная> = <Идентификатор>[':' <Тип>][ '=' <Выражение>]
```

Значением переменной может быть примитив или ссылка на композит.

Любая переменная также может "содержать" `nil` (ничего), если её тип или один из типов указан со знаком `?` на конце. В противном случае она обязана содержать значение на момент интерпретации объявления. Это относится и к функциям - нельзя передать аргумент `nil` в обязательный параметр, и нельзя отдать `nil` как обязательное возвратное значение. Аналогичным образом запрещается вставка `nil`-значений и записей, содержащих `nil`-ключи и/или значения, в массивы и словари с обязательными типами содержания соответственно. При этом, полное отсутствие значений и записей в таких массивах и словарях не запрещается.

```
var emptyVariable             Пустая переменная с необязательным значением любого типа
var testingVariable = 1,      Переменная с необязательным значением любого типа, инициализируемая со значением Integer(1)
    nillableVariable: _? = 1
```

По тому же принципу переменные могут содержать значения по умолчанию, которые будут автоматически установлены в момент обращения (ленивая инициализация). Для этого вместо `?` следует использовать `!`. Существует два правила использования умолчаний: тип должен содержать публичный неопциональный конструктор без параметров, а переменная не должна иметь более одного типа по умолчанию. Уточнение: переменные, которым было автоматически установлено значение, не становятся константами, им всё ещё можно задать `nil`, впоследствии переписав умолчание на новое. Последнее может быть полезно, если конструктор типа учитывает какие-либо условия даже без передачи аргументов.

```
var defaultVariable: Integer!  Переменная, инициализируемая по обращению со значением Integer(0)
```

Примитивные типы тоже поддерживают умолчания: `bool` - `false`, `dict` - `[:]`, `float` - `0.0`, `int` - `0`, `string` - `''`.

Помммо переменных с умолчаниями, ленивая инициализация распространяется на статичные переменные, и переменные объектов с модификатором `lazy`.

##### Наблюдатели

Наблюдатели не объявляются самостоятельно, так как закрепляются за другими мемберами, или за всем композитом вцелом. Они используются для изменения обычного поведения при записи и чтении в них.

Всего есть 9 идентификаторов состояний, для перехвата наблюдателями: `willGet`, `get`, `didGet`, `willSet`, `set`, `didSet`, `willDelete`, `delete` и `didDelete`. Также, верхнеуровневые наблюдатели подразделяются на два типа: `chain` и `subscript`.

```
class StepCounter {
    var steps: Integer = 0 {
        willSet {
            print('About to set steps to \(newValue)')
        }

        didSet {
            if steps > oldValue {
                print('Added \(steps-oldValue) steps')
            }
        }
    }
}

var stepCounter = StepCounter()

stepCounter.steps = 200
// About to set steps to 200
// Added 200 steps

stepCounter.steps = 360
// About to set steps to 360
// Added 160 steps

stepCounter.steps = 896
// About to set steps to 896
// Added 536 steps
```

Любой мембер, имеющий наблюдателей состояний `get`, `set` и `delete`, не теряет своего внутреннего хранилища данных, но во избежание рекурсии при его записи и чтении из области видимости наблюдателя необходимо пользоваться переменной `value`. Эта переменная чуть менее важна, но всё ещё несёт своё предназначение и в других состояниях.

Синтаксис не предполагает объявление наблюдателей с чем угодно, кроме переменных, тем не менее, технически любой мембер их поддерживает.

##### Модификаторы

...

#### Указание типов

```
_                                 Любой тип
                                  Предназначен для использования в местах, где указание типа синтаксически необходимо

                                  Примитивы
any                               Любой
bool                              Логическое значение
float                             Число с плавающей точкой
int                               Целое число
string                            Строка

                                  Композиты
Any                               Любой
Class                             Класс
Enumeration                       Перечисление
Function                          Функция
Namespace                         Пространство имён
Object                            Объект
Protocol                          Протокол
Structure                         Структура

                                  Функции
()                                Любая (композит типа Function)
<...>(...) awaits? throws? -> _?
<T>(T, T)                         Функция с дженерик-параметром и обычными параметрами того же дженерик-типа без возвратного значения
(Integer, Number) -> Boolean      Функция с двумя параметрами типа Integer и Number соответственно и возвратным значением типа Boolean
([]..., ...) awaits throws -> _   Ожидающая, кидающая исключения функция, с любым количеством параметров типа Array в начале, и любыми параметрами после них, с возвратным значением любого типа
(() -> _)?                        Необязательная функция без параметров с возвратным значением любого типа

                                  Массивы
[]                                Любой (объект типа Array)
[_?]
Array
Array<_?>
[_]                               Массив со значениями любого типа
Array<_>

                                  Словари
[:]                               Любой (объект типа Dictionary)
[_?: _?]
Dictionary
Dictionary<_?, _?>
[_: _]                            Словарь с ключами и значениями любого типа
Dictionary<_, _>
[String: _]                       Словарь с ключами типа String и значениями любого типа
Dictionary<String, _>

                                  Прочие
Custom.Self                       Композит, в родительском древе которого находится тип Custom, или который сам им является
Custom                            Объект, в родительском древе которого находится тип Custom
Self                              Композит зоны видимости
```

##### Объединённые типы

Если переменная должна принимать один из нескольких типов, следует использовать объединённый тип. Оный можно определить с помощью знака `|`. Объединённый тип имеет приоритет над пересекающимися.

```
var unionVariable: Integer | String | Boolean  Переменная, принимающая значения типа Integer, String и Boolean
```

##### Пересекающиеся типы

Переменная, которая должна принимать композит, соответствующий нескольким протоколам, определяется с использованием пересекающегося типа. В свою очередь подобный композит также определяется с ним в списке наследственности. Такой тип записывается с разделением через `&` в первом случае и через `,` во втором. Порядок значений влияния не имеет, но в списке может быть максимум один непротокольный композит.

```
class CustomCompositeA {}
class CustomCompositeB: CustomCompositeA, CustomProtocolA {}
class CustomCompositeC: CustomCompositeA, CustomProtocolA, CustomProtocolB {}

var intersectionVariable: CustomCompositeA & CustomProtocolB  Переменная, принимающая значения типа CustomCompositeA, соответствующего протоколу CustomProtocolB
```

#### Удаление

Ключевое слово `delete` производит попытку удаления мембера из композита.

```
'delete' <Идентификатор>[<Путь к мемберу>]

<Путь к мемберу> = ['?']'.'<Идентификатор>[<Путь к мемберу>]
<Путь к мемберу> = '['<Аргументы>']'[<Путь к мемберу>]
```

Если композит не поддерживает этот оператор, определяя наблюдателей `willDelete`, `delete` и `didDelete`, возвращаемым значением будет `Boolean(false)`.

```
delete variable           Удаление из композита области видимости
delete instance.variable  Удаление из другого композита
delete array[0]           Удаление из массива
```

### Память

#### Сборка мусора

Для управления временем жизни композитов в Root применяется развитый Автоматический Подсчёт Ссылок (Automatic Reference Counting).

Отличие от общепринятой реализации ARC состоит в том, что каждый композит имеет свой собственный список ретейнеров, который наполняется и опустошается за время выполнения кода. Использование такого списка позволяет динамически отслеживать и уведомлять о недоступности композитов, исключая из выборки ретейн-циклы, чего не может предоставить счётчик в виде обычного числа.

#### Наследование

Каждый композит имеет своего родителя и область видимости. Свойство `Родитель` используется для сравнения типа композита, а `Область видимости` для поиска мемберов, в случае их ненахождения в текущем композите. Область видимости может устанавливаться динамически в моменты вызова функций, для переключения между статичным контекстом и контекстом объекта. Количество объектов при инициализации композита, наследуемого от другого композита, не ограничивается одним, что позволяет разделить области видимости таким образом, чтобы функции родителя не могли случайно обратиться к дочерним мемберам, а также не было препятствий перегрузкам.

```
Функция 2
      Область видимости == Класс А

Функция 5
      Область видимости == Класс Б

Класс А
      Родитель == Нет
      Область видимости == Глобальная
      Мембер А = 1
      Мембер Б = Функция 2

Класс Б
      Родитель == Класс А
      Область видимости == Класс А
      Мембер А = 3
      Мембер Б = 4
      Мембер В = Функция 5

Объект А
      Родитель == Класс А
      Область видимости == Класс А
      Мембер А == 1                  Инициализирован классом А
      Мембер Б == Функция 2          Инициализирован классом А, область видимости при вызове == Объект А

Объект Б
      Родитель == Класс Б
      Область видимости == Объект А
      Мембер Супер.А == 1            Находится в объекте А
      Мембер Супер.Б == Функция 2    Находится в объекте А
      Мембер А == 3                  Инициализирован классом Б
      Мембер Б == 4                  Инициализирован классом Б
      Мембер В == Функция 5          Инициализирован классом Б, область видимости при вызове == Объект Б
```
![Logo](./Resources/Logo.png)

## RoadMap

### Этапы разработки
- Теория -> В процессе
- Lexer -> Относительно готов
- Parser -> Относительно готов
- Interpreter -> В процессе
- Перевод на компилируемый ЯП -> Пока нет

### Запланированные идеологические преимущества по сравнению со Swift:
- Многофункциональный интерпретатор
   - Локальные экземпляры внутри кода (песочницы), с возможной передачей контекста
   - Уровни метапрограммирования: полное редактирование, частичное редактирование, частичное чтение, нет
   - Использование кастомных функций в песочницах, таких как `import()` и `print()`...
   - Исполнение по предельному уровню ошибок (допущение или не- вольного синтаксиса)
   - Мультипоточность (любая функция может быть вызвана асинхронно, включая вложенные вызовы, и обождена синхронно)
   - Отладочная консоль для просмотра и действий с памятью (в виде окна с иерархией композитов и строкой ввода)
   - Импорт и экспорт текущего состояния памяти из файла
- Метапрограммирование (расширенное взаимодействие с композитами во время исполнения вне отладки)
   - Чтение и изменение внутренних свойств, недоступное обычными путями: тип, список наследственности, уровень доступа мемберов, ретейнеры...
   - Получение вызывающего из функции
   - Создание и вызов функций в определённом `namespace` через `bind()` и `apply()`
   - Выполнение кода в определённом `namespace` через `with`
- Расширенная типизация
   - По-настоящему опциональные типы вместо обёрточного Optional
   - Явный композитный тип `namespace` для разграничения и группирования пространств имён
   - Объединённые типы
   - Разделение вложенных типов на статичные и объектные
   - Выражения для всех композитов, а не только функций в виде замыканий
   - Анонимные inline протоколы
   - Сравнение композитных типов по определению или содержимому в случаях, когда по идентификатору - неоптимально
   - (Необязательное) явное указание дженерик-типов при вызове функций
- Новые операторы и ключевые слова
   - `final` (вместо `const`) для объявления констант более широкого спектра
   - `in` для проверки наличия мембера в композите
   - `switch`-выражения
   - `with` для смены (расширения?) области видимости
   - `...` (spread) для смешивания коллекций
- Предельно точные десятичные числа, основанные на хранении и вычислении оных в виде строк

## Спецификация

### Типы

#### Композиты

В Root отдаётся предпочтение ООП, поэтому большая часть типов является композитами.

| Композит          | Мемберы              | Родители         | Вызываемость | Копируемость              |
|-------------------|----------------------|------------------|--------------|---------------------------|
| Класс             | Любые                | Класс, протоколы | Да           | Нет                       |
| Объект            | Значения             | Класс/структура  | Нет          | Если родитель - структура |
| Перечисление      | Случаи, перечисления | Протоколы        | Нет          | Нет                       |
| Пространство имён | Любые                | Нет              | Нет          | Нет                       |
| Протокол          | Определения          | Протоколы        | Нет          | Нет                       |
| Структура         | Любые                | Протоколы        | Да           | Нет                       |
| Функция           | Предопределённые     | Нет              | Да           | Нет                       |

Пространства имён (следовательно и тела функций), в отличии от других композитов, могут содержать объявления импорта и операторов.

Родителями протоколов в прямом смысле могут быть только другие протоколы, но в их списках наследственности могут указываться любые композитные типы кроме функций. Таким образом устанавливаются ограничения приемственности в тех случаях, когда протокол предполагается для использования определённой группой типов.

В общем случае в коде в качестве мемберов могут выступать как обычные переменные с любыми значениями, так и все вышеперечисленные композиты в виде объявлений.

Для доступа к сырому представлению композитов предназначен мембер `metaSelf`.

#### Примитивы

К примитивам относятся `bool`, `float`, `int` и `string`. Переменные примитивных типов передаются копированием значений, а операторы действий над ними не могут быть переопределены. Обычно значения примитивных типов инициализируются и используются неявно внутри своих обёрточных композитов.

### Синтаксис

#### Объявления

Объявления подразделяются на 4 группы: импорты, операторы, мемберы и наблюдатели. Объявление обрабатывается раньше другого кода, а его значение считывается в разных местах по идентификатору. Идентификаторы (или, в случае функций, сигнатуры) каждого из объявлений, находящихся в одной группе, обязаны быть уникальными. У объявлений могут быть модификаторы, влияющие на внешний доступ к ним, или несущие другие эффекты.

Каждое объявление создаёт особую структуру внутри композита, в котором оно выполнено. Не считая мемберов, непосредственный доступ к таким структурам имеется только у интерпретатора.

##### Операторы

Операторы состоят из двух объявлений с одним общим идентификатором: структуры, отвечающей за восприятие, и функции, определяющей поведение.

```
postfix operator ++

private infix operator == {
      associativity: left
      precedence: 64
}

struct Integer {
      private var value: int

      init(v: int) {
            value = v
      }

      postfix func ++(v: inout Self) {
          v = v+1
      }

      func ==(lhs: Self, rhs: Self) {
          return lhs.value == rhs.value
      }
}
```

##### Классы

...

##### Перечисления

...

##### Пространства имён

...

##### Протоколы

...

##### Структуры

...

##### Функции

...

##### Переменные

Переменные объявляются ключевым словом `var`.

```
'var' <Переменная>[, <Переменная>]

<Переменная> = <Идентификатор>[':' <Тип>][ '=' <Выражение>]
```

Значением переменной может быть примитив или ссылка на композит.

Любая переменная также может "содержать" `nil` (ничего), если её тип или один из типов указан со знаком `?` на конце. В противном случае она обязана содержать значение на момент интерпретации объявления. Это относится и к функциям - нельзя передать аргумент `nil` в обязательный параметр, и нельзя отдать `nil` как обязательное возвратное значение. Аналогичным образом запрещается вставка `nil`-значений и записей, содержащих `nil`-ключи и/или значения, в массивы и словари с обязательными типами содержания соответственно. При этом, полное отсутствие значений и записей в таких массивах и словарях не запрещается.

```
var emptyVariable             Пустая переменная с необязательным значением любого типа
var testingVariable = 1,      Переменная с необязательным значением любого типа, инициализируемая со значением Integer(1)
    nillableVariable: _? = 1
```

По тому же принципу переменные могут содержать значения по умолчанию, которые будут автоматически установлены в момент обращения (ленивая инициализация). Для этого вместо `?` следует использовать `!`. Существует два правила использования умолчаний: тип должен содержать публичный неопциональный конструктор без параметров, а переменная не должна иметь более одного типа по умолчанию. Уточнение: переменные, которым было автоматически установлено значение, не становятся константами, им всё ещё можно задать `nil`, впоследствии переписав умолчание на новое. Последнее может быть полезно, если конструктор типа учитывает какие-либо условия даже без передачи аргументов.

```
var defaultVariable: Integer!  Переменная, инициализируемая по обращению со значением Integer(0)
```

Примитивные типы тоже поддерживают умолчания: `bool` - `false`, `float` и `int` - `0`, `string` - `''`.

Помммо переменных с умолчаниями, ленивая инициализация распространяется на статичные переменные, и переменные объектов с модификатором `lazy`.

##### Наблюдатели

Наблюдатели не объявляются самостоятельно, так как закрепляются за другими мемберами, или за всем композитом вцелом. Они используются для изменения обычного поведения при записи и чтении в них.

Всего есть 9 идентификаторов состояний, для перехвата наблюдателями: `willGet`, `get`, `didGet`, `willSet`, `set`, `didSet`, `willDelete`, `delete` и `didDelete`. Также, верхнеуровневые наблюдатели подразделяются на два типа: `chain` и `subscript`.

```
class StepCounter {
    var steps: Integer = 0 {
        willSet {
            print('About to set steps to \(newValue)')
        }

        didSet {
            if steps > oldValue {
                print('Added \(steps-oldValue) steps')
            }
        }
    }
}

var stepCounter = StepCounter()

stepCounter.steps = 200
// About to set steps to 200
// Added 200 steps

stepCounter.steps = 360
// About to set steps to 360
// Added 160 steps

stepCounter.steps = 896
// About to set steps to 896
// Added 536 steps
```

Любой мембер, имеющий наблюдателей состояний `get`, `set` и `delete`, не теряет своего внутреннего хранилища данных, но во избежание рекурсии при его записи и чтении из области видимости наблюдателя необходимо пользоваться переменной `value`. Эта переменная чуть менее важна, но всё ещё несёт своё предназначение и в других состояниях.

Синтаксис не предполагает объявление наблюдателей с чем угодно, кроме переменных, тем не менее, технически любой мембер их поддерживает.

##### Модификаторы

...

#### Указание типов

```
_                                 Любой тип
                                  Предназначен для использования в местах, где указание типа синтаксически необходимо

                                  Примитивы
any                               Любой
bool                              Логическое значение
float                             Число с плавающей точкой
int                               Целое число
string                            Строка

                                  Композиты
Any                               Любой
Class                             Класс
Enumeration                       Перечисление
Function                          Функция
Namespace                         Пространство имён
Object                            Объект
Protocol                          Протокол
Structure                         Структура

                                  Функции
()                                Любая (композит типа Function)
<...>(...) awaits? throws? -> _?
<T>(T, T)                         Функция с дженерик-параметром и обычными параметрами того же дженерик-типа без возвратного значения
(Integer, Number) -> Boolean      Функция с двумя параметрами типа Integer и Number соответственно и возвратным значением типа Boolean
([]..., ...) awaits throws -> _   Ожидающая, кидающая исключения функция, с любым количеством параметров типа Array в начале, и любыми параметрами после них, с возвратным значением любого типа
(() -> _)?                        Необязательная функция без параметров с возвратным значением любого типа

                                  Массивы
[]                                Любой (объект типа Array)
[_?]
Array
Array<_?>
[_]                               Массив со значениями любого типа
Array<_>

                                  Словари
[:]                               Любой (объект типа Dictionary)
[_?: _?]
Dictionary
Dictionary<_?, _?>
[_: _]                            Словарь с ключами и значениями любого типа
Dictionary<_, _>
[String: _]                       Словарь с ключами типа String и значениями любого типа
Dictionary<String, _>

                                  Прочие
Custom.Self                       Композит, в родительском древе которого находится тип Custom, или который сам им является
Custom                            Объект, в родительском древе которого находится тип Custom
Self                              Композит зоны видимости
```

##### Объединённые типы

Если переменная должна принимать один из нескольких типов, следует использовать объединённый тип. Оный можно определить с помощью знака `|`. Объединённый тип имеет приоритет над пересекающимися.

```
var unionVariable: Integer | String | Boolean  Переменная, принимающая значения типа Integer, String и Boolean
```

##### Пересекающиеся типы

Переменная, которая должна принимать композит, соответствующий нескольким протоколам, определяется с использованием пересекающегося типа. В свою очередь подобный композит также определяется с ним в списке наследственности. Такой тип записывается с разделением через `&` в первом случае и через `,` во втором. Порядок значений влияния не имеет, но в списке может быть максимум один непротокольный композит.

```
class CustomCompositeA {}
class CustomCompositeB: CustomCompositeA, CustomProtocolA {}
class CustomCompositeC: CustomCompositeA, CustomProtocolA, CustomProtocolB {}

var intersectionVariable: CustomCompositeA & CustomProtocolB  Переменная, принимающая значения типа CustomCompositeA, соответствующего протоколу CustomProtocolB
```

#### Удаление

Ключевое слово `delete` производит попытку удаления мембера из композита.

```
'delete' <Идентификатор>[<Путь к мемберу>]

<Путь к мемберу> = ['?']'.'<Идентификатор>[<Путь к мемберу>]
<Путь к мемберу> = '['<Аргументы>']'[<Путь к мемберу>]
```

Если композит не поддерживает этот оператор, определяя наблюдателей `willDelete`, `delete` и `didDelete`, возвращаемым значением будет `Boolean(false)`.

```
delete variable           Удаление из композита области видимости
delete instance.variable  Удаление из другого композита
delete array[0]           Удаление из массива
```
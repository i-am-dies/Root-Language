![Logo](./Resources/Logo.png)

## RoadMap

### Основные компоненты
- Lexer -> Готов
- Parser -> В процессе
- Interpreter -> Начата теоретическая часть

- Перевод на компилируемый ЯП -> Не начат

### Запланированные идеологические преимущества по сравнению со Swift (в т.ч. почерпнутые из JS):
- Многофункциональный интерпретатор
   - Локальные экземпляры внутри кода (песочницы), с возможной передачей контекста
   - Уровни метапрограммирования: полное редактирование, частичное редактирование, частичное чтение, нет
   - Использование кастомных функций в песочницах, таких как import(), print() и т.д.
   - Исполнение по предельному уровню ошибок (допущение или не- вольного синтаксиса)
   - Отладочная консоль для просмотра и действий с памятью (в виде окна с иерархией композитов и строкой ввода)
   - Импорт и экспорт текущего состояния памяти из файла
- Метапрограммирование (расширенное взаимодействие с композитами во время исполнения вне отладки)
   - Чтение и изменение внутренних свойств, недоступное обычными путями: список наследственности, количество retain'ов, переключение типа 'class' на 'enum', у полей уровня доступа 'private' на 'public', и т.п.
   - Получение вызывающего композита из области видимости функции
- Композитный тип namespace
- Опциональная типизация переменных

## Спецификация

### Типы

#### Композиты

В Root отдаётся предпочтение объёктной ориентированности, поэтому большая часть типов является композитами.

| Композит          | Мемберы            | Родители          | Вызываемость | Копируемость |
|-------------------|--------------------|-------------------|--------------|--------------|
| Объект            | Только значения    | Класс             | Нет          | Нет          |
| Класс             | Любые              | Класс и протоколы | Да           | Нет          |
| Перечисление      | Без операторов     | Протоколы         | Нет          | Да           |
| Пространство имён | Без операторов     | Нет               | Нет          | Нет          |
| Протокол          | Только определения | Протоколы         | Нет          | Нет          |
| Структура         | Любые              | Протоколы         | Да           | Да           |
| Функция           | Предопределённые   | Нет               | Да           | Нет          |

Родителями протоколов в прямом смысле могут быть только другие протоколы, но в их списках наследственности могут указываться любые композитные типы кроме функций. Таким образом устанавливаются ограничения приемственности в тех случаях, когда протокол предполагается для использования определённой группой типов.

В общем случае в коде в качестве мемберов могут выступать как обычные переменные с любыми значениями, так и все вышеперечисленные композиты в виде определений.

Для доступа к сырому представлению композитов предназначен мембер `metaSelf`.

#### Примитивы

К примитивам относятся `string`, `int`, `float` и `bool`. Переменные и константы примитивных типов передаются копированием значений, а операторы действий над ними не могут быть переопределены. Обычно значения примитивных типов инициализируются и используются неявно внутри своих обёрточных композитов.

### Синтаксис

#### Объявления

Любое объявление создаёт мембер внутри композита, в котором оно выполнено. Объявление обрабатывается раньше другого кода, является константой по умолчанию, а также, в отличии от выражения, является самостоятельной частью кода, поэтому обязано содержать идентификатор, а его значение не может быть использовано сходу.

##### Переменные и константы

Переменные и константы объявляются ключевыми словами `var` и `const`.

```
'var' <Переменная или константа>

<Переменная или константа> = <Идентификатор>[':' <Тип>][ '=' <Выражение>][',' <Переменная или константа>]
```

Значением переменной или константы может быть примитив или ссылка на композит.

Любая переменная и константа также может "содержать" `nil` (ничего), если её тип или один из типов указан со знаком `?` на конце. В противном случае она обязана содержать значение на момент интерпретации объявления. Это относится и к функциям - нельзя передать аргумент `nil` в обязательный параметр, и нельзя отдать `nil` как обязательное возвратное значение. Аналогичным образом запрещается вставка `nil`-значений и записей, содержащих `nil`-ключи и/или значения, в массивы и словари с обязательными типами содержания соответственно. При этом, полное отсутствие значений и записей в таких массивах и словарях не запрещается.

```
var empty                                             Пустая переменная с необязательным значением любого типа
var testingVariable = 1                               Переменная с необязательным значением любого типа, инициализируемая со значением Integer(1)
var testingVariable: _? = 1

const firstConstant = Number.Pi,                      Две константы с разными типами значений: любым-необязательным и строковым
      secondConstant: String = 'Example of a string'
```

#### Указание типов

```
_                                Любой тип
                                 Предназначен для использования в местах, где указание типа синтаксически необходимо
                                 Технически позволяет избежать проверок типа при присваивании переменной

                                 Примитивы
any                              Любой
string                           Строка
int                              Целое число
float                            Число с плавающей точкой
bool                             Логическое значение

                                 Композиты
Any                              Любой
Self                             Композит зоны видимости
Object                           Объект
Class                            Класс
Enumeration                      Перечисление
Namespace                        Пространство имён
Protocol                         Протокол
Structure                        Структура
Function                         Функция

                                 Функции
()                               Любая (композит типа Function)
<...>(...) async? throws? -> _?
<T>(T, T)                        Функция с дженерик-параметром и обычными параметрами того же дженерик-типа без возвратного значения
(Integer, Number) -> Boolean     Функция с двумя параметрами типа Integer и Number соответственно и возвратным значением типа Boolean
([]..., ...) async throws -> _   Асинхронная, кидающая исключения функция, с любым количеством параметров типа Array в начале, и любыми параметрами после них, с возвратным значением любого типа
(() -> _)?                       Необязательная функция без параметров с возвратным значением любого типа

                                 Массивы
[]                               Любой (объект типа Array)
[_?]
Array
Array<_?>
[_]                              Массив со значениями любого типа
Array<_>

                                 Словари
[:]                              Любой (объект типа Dictionary)
[_?: _?]
Dictionary
Dictionary<_?, _?>
[_: _]                           Словарь с ключами и значениями любого типа
Dictionary<_, _>
[String: _]                      Словарь с ключами типа String и значениями любого типа
Dictionary<String, _>

                                 Прочие
Custom.Self                      Композит, в родительском древе которого находится тип Custom, или который сам им является
Custom                           Объект, в родительском древе которого находится тип Custom
```

Сразу несколько типов может быть указано в одном месте при помощи знака `&`, если `,` используется для разделения на более высоком уровне.

```
var multitypeVariable: Integer & String  Переменная, принимающая значения типов Integer и String
```

#### Удаление

Ключевое слово `delete` производит попытку удаления мембера из композита.

```
'delete' <Идентификатор>[<Путь к мемберу>]

<Путь к мемберу> = ['?']'.'<Идентификатор>[<Путь к мемберу>]
<Путь к мемберу> = '['<Аргументы>']'[<Путь к мемберу>]
```

Если композит не поддерживает этот оператор, определяя функции `willDelete`, `delete` и `didDelete`, возвращаемым значением будет `Boolean(false)`.

```
delete variable           Удаление из композита области видимости
delete instance.variable  Удаление из другого композита
delete array[0]           Удаление из массива
```
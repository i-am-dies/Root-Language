На данный момент в Root планируется поддержать следующее:
+ Современный синтаксис, схожий со Swift и JS;
+ _Опциональную_ типизацию, включая optional any и void как extreme-типы;
+ Вместо привычного полного разделения на типы и значения, сами типы делятся на абстрактные (декларирующие интерфейс) и конкретные (представляющие значения);
- Мощное метапрограммирование, включая изменение классов и объектов на лету, получение информации о caller'е, наблюдаемость значений (getter/setter, включая общие по типу _getattr_ в Python) и т.д.;
= Функции и классы/объекты как first-class citizen;
= Все ключи безопасности по ООП: private, protected, public;
+ Опциональность метапрограммирования и разделение его на уровни доступа: каждый экземпляр LangServer сам определяет, могут ли скрипты использовать метапрограммирование и в какой мере;
= Статичные переменные в функциях: они доступны как обычные свойства у класса или namespace;
- Подключение скриптов на лету: так же как import - подключение уровня определения, класс VM или подобный может подгружать библиотеки или исполняемые скрипты динамически, благодаря интерпретируемой природе языка;
- Доступ к библиотекам на C++;
+ Расширенную идею Automatic Reference Counting. Классы/объекты всегда держат в своей памяти списки retained/retaining, указывающие на свои связи с другими классами/объектами, позволяющие _автоматически_ избегать цикличных связей при проверке состояния "удержимости" объекта. В свою очередь такая проверка работает засчёт трейсинга как в Garbage Collector'ах - необходимо, чтобы объект был удерживаем (прямо или рекурсивно) глобальным пространством имён, текущим значением передачи управления или текущей областью видимости;
+ Ссылки на переменные и свойства как first-class через тип/значение Inout, который может быть явным как в Swift для большего контроля и неявным как в JS для большего удобства.
= Перегружаемые свойства и переменные помимо перегружаемых методов и примитивные словари с перегрузкой ключей: для одного ключа, свойства или переменной может быть множество значений, автоматически выбираемых по контекстному типу (если он есть) или по порядку определения;
= Цепочку объектов как цепочку экземпляров классов в рантайме, а не как один большой объект: по ней можно перемещаться с помощью псевдопеременных super, self и sub, в т.ч. из внешней области видимости;
- Async/await на основе планировщика задач ОС и реальных потоков, а не на базе собственного планировщика задач в одном потоке. "async func()" просто запустит любую функцию в фоне и возвратит Promise, а "await (async func())" просто подождёт выполнение Promise, заблокировав текущий поток. Await не оборачивает синхронные функции в Promise. Функции всё ещё могут возвращать Promise сами по себе, не будучи помеченными как async ни на стороне вызова, ни на стороне объявления. Promise также имеет знакомый синтаксис, и может быть "обождён" из любого контекста, откуда доступен. К Promise даже могут быть прикреплены несколько callback-обработчиков при желании. Проблема отладки основного потока во время блокировки решается добавлением вспомогательного потока, который слушает отладочные команды и выполняет их в разделяемом контексте основного потока;
+ Иерархию интерпретаторов с опционально наследуемым (разделяемым) контекстом исполнения: каждый интерпретатор может иметь родителя, от которого будут наследоваться или быть независимы куча, стек областей видимости, стек вызовов, стек передач управления и т.д. Это применяется в REPL, сэндбоксинге, отладке и т.д.;
= Интерфейс для динамического управления процессами через IPC (RPC, отладка, интроспекция AST, токенов, импортированных модулей и прочего). Каждая программа (процесс) может выступать в роли сервера или клиента. Сервер работает как маршрутизатор, и координирует сообщения между клиентами. Каждый клиент после подключения к серверу должен отсылать раз в несколько секунд heartbeat-сообщение со списком своих токенов. Если процесс не присылает heartbeat в течении этого времени, он считается зависшим и подключение с ним может быть разорвано со стороны сервера. Токены определяет инициатор программы (пользователь, администратор или система) - в реальном использовании токены представляются сгенерированными автоматически уникальными последовательностями символов. Токены используются как система аутентификации и идентификации - сервер или любой другой процесс может ожидать подключение от другого процесса с ответным токеном, который он сам передал ему при запуске, чтобы однозначно идентифицировать подключение. Это также может быть использовано для того чтобы убить процесс, с которым было разорвано подключение, если есть доступ к его PID на системном уровне. Аутентификация заключается в передачи токена целевого процесса от клиента/сервера к другому клиенту/серверу с каждым IPC запросом, чтобы обозначить своё право на доступ... Эта базовая система доступа и безопасности ложится в основу другого проекта, где безопасность значительно расширяется: токены устанавливаются одним процессам только Ядром Платформы, и выдаются другим только через системный вызов (новые, в дополнение к основному) и посредством агента безопасности (от пользователя требуется осознанное подтверждение и подтверждение личности вроде UAC). Эмуляция системных вызовов Платформы реализуется как RPC от процессов интерпретатора к Ядру. Ядро создаёт процесс с некоторым сложным токеном, ожидает от него подключения и идентифицирует, после чего с помощью IPC подменяет в памяти процесса стандартные функции на свои.
<style>
/* Корневая структура больше не нуждается в grid */
body {
	margin: 0;
	background: #111;
	color: white;
	font-family: sans-serif;
}

/* Стили контейнера клиента */
.client-interface {
	display: grid;
	grid-template:
		'code trees' max-content
		'console console' auto
		/ max-content auto;
	grid-auto-columns: 0;
	grid-auto-rows: 0;

	gap: 8px;
	padding: 12px;
	background: #1e1e1e;
	border: 1px solid #333;
	border-radius: 8px;
	max-width: 100vw;
	max-height: 90vh;
	overflow: auto;
}

/* Основной редактор */
.client-interface .inputText,
.client-interface .inputLint {
	grid-area: code;
	box-sizing: border-box;
	width: 100%;
	height: 30vh;
	font: 12px monospace;
	tab-size: 4;
	white-space: pre;
	overflow: auto;
	padding: 4px;
	border: none;
	resize: both;
}

/* Подсветка */
.client-interface .inputText {
	background: #3f3f3f;
	color: rgba(255, 255, 255, 0.25);
	caret-color: white;
}
.client-interface .inputLint {
	background: none;
	color: #bfbfbf;
	pointer-events: none;
	position: absolute;
	z-index: -1;
}

/* Область деревьев и кнопок */
.client-interface .treesOutput {
	background: #dfdfdf;
	font-size: 10px;
	padding: 8px;
	color: black;
	position: relative;
	overflow-x: auto;
}

.client-interface .treesOutput,
.client-interface .console {
	grid-area: trees;
}

.client-interface .tokensOutput,
.client-interface .ASTOutput,
.client-interface .compositesOutput {
	white-space: pre-wrap;
	font-family: monospace;
	background: #eee;
	color: #111;
	padding: 8px;
	margin-top: 4px;
}

/* Консоль */
.client-interface .console {
	display: flex;
	grid-area: console;
	flex-direction: column;
	gap: 4px;
}

.client-interface .consoleOutput {
	flex: 1;
	overflow-y: auto;
	background: #222;
	padding: 6px;
	font-size: 12px;
	font-family: monospace;
	min-height: 5em;
	max-height: 20vh;
	color: white;
}

.client-interface .consoleInput {
	background: #444;
	color: white;
	border: 1px solid #666;
	padding: 4px;
	font-family: monospace;
	font-size: 12px;
}
</style>
<div id="authTab" style="display: none; position: fixed; inset: 0; background: #222; color: white; z-index: 10; padding: 2em;">
	<h2>Введите данные для подключения</h2>
	<form id="authForm">
		<label>Адрес сокета: <input type="text" id="socketAddress" placeholder="ws://localhost:1234/socket" style="width: 400px;"></label><br><br>
		<label>Токен: <input type="text" id="socketToken" style="width: 400px;"></label><br><br>
		<button type="submit">Подключиться</button>
	</form>
</div>
<template id="clientTemplate">
	<div class="client-interface">
		<textarea class="inputText" spellcheck="false" style="width: 55vw; height: 65vh;"></textarea>
		<div class="inputLint"></div>
		<div class="treesOutput">
			<div class="buttons">
				<button class="changeTree">Change tree</button>
				<button class="interpret">Interpret</button>
			</div>
			<div class="tokensOutput"></div>
			<div class="ASTOutput" style="display: none;"></div>
			<div class="compositesOutput" style="display: none;"></div>
		</div>
		<div class="console">
			<div class="consoleOutput"></div>
			<input type="text" class="consoleInput">
		</div>
	</div>
</template>
<div id="tabsContainer" style="display: flex; gap: 8px; padding: 4px;"></div>
<div id="clientViews"></div>
<script>
	let authTab = document.getElementById('authTab'),
		tabsContainer = document.getElementById('tabsContainer'),
		clientViews = document.getElementById('clientViews'),
		authForm = document.getElementById('authForm'),
		socketAddress = document.getElementById('socketAddress'),
		socketToken = document.getElementById('socketToken'),
		heartbeatInterval,
		processListInterval,
		socket;

	function parse() {
		inputLint.innerHTML = '';

		send({ action: 'lex', code: inputText.value });
		send({ action: 'parse' });
	}

	function openSocket(address, token) {
		if (!address) {
			authTab.style.display = 'block';
			return;
		}

		socket = new WebSocket(address + '?token=' + encodeURIComponent(token));

		socket.onopen = function() {
			authTab.style.display = 'none';

			send({ action: 'listProcesses' });
			clearInterval(heartbeatInterval);
			heartbeatInterval = setInterval(() => send({ action: 'heartbeat' }), 10000);

			clearInterval(processListInterval);
			processListInterval = setInterval(() => send({ action: 'listProcesses' }), 10000);
		};

		socket.onmessage = function(event) {
			let report = JSON.parse(event.data);

			if(report.action === 'processList') {
				updateProcessTabs(report.processes);
			}

			if(report.action === 'tokenized') {
				let view = document.getElementById('client-' + report.clientId);
				if (!view) return;

				let inputLint = view.querySelector('.inputLint');
				let inputText = view.querySelector('.inputText');
				let tokensOutput = view.querySelector('.tokensOutput');

				let tokens = report.tokens,
					lintHTML = '';

				for(let k = 0; k < tokens.length; k++) {
					let position = tokens[k].position,
						type = tokens[k].type,
						value = tokens[k].value,
						generated = tokens[k].generated,
						length = value.length,
						element;

					if(type === 'whitespace') {
						for(let i = 0; i < value.length; i++) {
							if(value[i] !== '\n') {
								element ??= document.createElement('span');
								element.innerText += value[i]

								if(value[i+1] === '\n' || i === value.length-1) {
									lintHTML += element.outerHTML;
									element = undefined;
								}
							}
							if(value[i] === '\n') {
								lintHTML += document.createElement('br').outerHTML;
							}
						}
					} else {
						element = document.createElement('span');
						element.innerText = value;

						if(type.startsWith('comment')) {
							element.style.color = 'rgb(95 179 63)';
						}
						if(type.startsWith('string') && !type.startsWith('stringExpression')) {
							element.style.color = 'rgb(191 127 95)';
						}
						if(type.startsWith('operator')) {
							element.style.color = 'rgb(255 191 0)';

							if(type.endsWith('Prefix')) {
								element.style.color = 'rgb(255 63 0)';
							}
							if(type.endsWith('Infix')) {
								element.style.color = 'rgb(255 95 0)';
							}
							if(type.endsWith('Postfix')) {
								element.style.color = 'rgb(255 127 0)';
							}
						}
						if(
							type.startsWith('parenthesis') ||
							type.startsWith('brace') ||
							type.startsWith('bracket') ||
							type === 'delimiter'
						) {
							element.style.color = 'rgb(255 255 255)';
						}
						if(type.startsWith('keyword')) {
							element.style.color = 'rgb(96 151 255)';

							if([
								'nil',
								'true',
								'false'
							].includes(value)) {
								element.style.color = 'rgb(223 127 223)';
							}
						}
						if(type === 'identifier' && value[0] === value[0].toUpperCase()) {
							element.style.color = 'rgb(223 223 223)';
						}
						if(type.startsWith('number')) {
							element.style.color = 'rgb(223 127 223)';
						}
						if(type === 'unsupported') {
							element.style.color = 'transparent';
						}
						if(generated) {
							element.style.fontStyle = 'italic';
						}

						lintHTML += element.outerHTML;
					}
				}

				inputLint.innerHTML = lintHTML;
				inputLint.scrollTop = inputText.scrollTop;
				inputLint.scrollLeft = inputText.scrollLeft;
				tokensOutput.innerText = JSON.stringify(tokens.filter(v => !v.trivia), null, 4);
			} else
			if(report.action === 'parsed') {
				let view = document.getElementById('client-' + report.clientId);
				if (!view) return;

				let ASTOutput = view.querySelector('.ASTOutput');

				ASTOutput.innerText = JSON.stringify(report.tree, null, 4);
			} else
			if(report.action === 'interpreted') {}

			if(report.action === 'add') {
				let view = document.getElementById('client-' + report.clientId);
				if (!view) return;

				let consoleOutput = view.querySelector('.consoleOutput');

				let message = report.string,
					color = report.level === 0 ? '0 0 0' : report.level === 1 ? '255 95 0' : '255 0 0',
					transparent = report.source !== 'interpreter',
					weight;

				if(report.location != null) {
					let line = report.location.line+1,
						column = report.location.column+1,
						level = report.level.toString()
											.replace('0', 'Info')
											.replace('1', 'Warning')
											.replace('2', 'Error');

					weight = 'regular';
					message = line+':'+column+': '+level+': '+message;
				} else {
					weight = 'bold';
				}

				let prev = document.createElement('span');

				prev.dataset.source = report.source;
				prev.dataset.position = report.position;
				prev.style.color = `rgba(${color} / ${transparent ? '0.75' : '1'})`;
				prev.style.fontWeight = weight;
				prev.innerText = message;

				let next,
					nodes = [...consoleOutput.children].reverse(),
					sources = ['lexer', 'parser', 'interpreter']

				for(let node of nodes) {
					let nextPosition = node.dataset.position*1,
						prevPosition = report.position,
						nextSource = sources.indexOf(node.dataset.source),
						prevSource = sources.indexOf(report.source);

					if(nextSource > prevSource) {
						next = node;
					} else
					if(
						 nextSource <   prevSource ||
						(nextSource === prevSource && nextPosition <= prevPosition)
					) {
						next = node.nextSibling;

						break;
					}
				}

				consoleOutput.insertBefore(prev, next);
				consoleOutput.scrollTop = consoleOutput.scrollHeight;
			} else
			if(report.action === 'removeAfterPosition') {
				let view = document.getElementById('client-' + report.clientId);
				if (!view) return;

				let consoleOutput = view.querySelector('.consoleOutput');

				let nodes = [...consoleOutput.children]

				for(let node of nodes) {
					if(node.dataset.source === report.source && node.dataset.position*1 > report.position)  {
						node.remove();
					}
				}
			} else
			if(report.action === 'removeAll') {
				let view = document.getElementById('client-' + report.clientId);
				if (!view) return;

				let consoleOutput = view.querySelector('.consoleOutput');

				let sources = ['lexer', 'parser', 'interpreter'],
					source = sources.indexOf(report.source);

				if(source === -1) {
					consoleOutput.innerHTML = '';
				} else {
					let toDelete = sources.slice(source),
						nodes = [...consoleOutput.children].filter(n => toDelete.includes(n.dataset.source));

					for(let node of nodes) {
						node.remove();
					}
				}
			}
		};

		socket.onclose = function() {
			clearInterval(heartbeatInterval);
			clearInterval(processListInterval);
			socket = undefined;

			authTab.style.display = 'block';
		};
	}

	authForm.onsubmit = function(e) {
		e.preventDefault();
		openSocket(socketAddress.value.trim(), socketToken.value.trim());
	};

	function updateProcessTabs(processes) {
		let newIds = new Set(processes.map(p => p.ID));
		let existingTabs = new Map();
		let existingViews = new Map();

		// Сохраняем текущие вкладки и представления
		for (let tab of tabsContainer.children) {
			let id = tab.dataset.id;
			if (id) existingTabs.set(id, tab);
		}
		for (let view of clientViews.children) {
			let id = view.dataset.id;
			if (id) existingViews.set(id, view);
		}

		// Удаляем устаревшие
		for (let [id, tab] of existingTabs) {
			if (!newIds.has(+id)) tab.remove();
		}
		for (let [id, view] of existingViews) {
			if (!newIds.has(+id)) view.remove();
		}

		// Обновляем или создаём вкладки и представления
		processes.forEach(proc => {
			let id = String(proc.ID);

			if (!existingTabs.has(id)) {
				let tab = document.createElement('button');
				tab.innerText = 'Client ' + id;
				tab.dataset.id = id;
				tab.onclick = () => showClient(id);
				tabsContainer.appendChild(tab);
			}

			if (!existingViews.has(id)) {
				let template = document.getElementById('clientTemplate');
				let view = document.createElement('div');
				view.id = 'client-' + id;
				view.dataset.id = id;
				view.style.display = 'none';
				view.style.padding = '8px';

				let clone = template.content.cloneNode(true);
				view.appendChild(clone);
				clientViews.appendChild(view);

				initializeClientInterface(view, id);
			}
		});
	}

	function initializeClientInterface(container, clientId) {
		const inputText = container.querySelector('.inputText');
		const inputLint = container.querySelector('.inputLint');
		const tokensOutput = container.querySelector('.tokensOutput');
		const ASTOutput = container.querySelector('.ASTOutput');
		const compositesOutput = container.querySelector('.compositesOutput');
		const changeTree = container.querySelector('.changeTree');
		const interpret = container.querySelector('.interpret');
		const consoleOutput = container.querySelector('.consoleOutput');
		const consoleInput = container.querySelector('.consoleInput');

		inputText.oninput = () => {
			inputLint.innerHTML = '';
			send({ action: 'lex', code: inputText.value, clientId });
			send({ action: 'parse', clientId });
		};

		inputText.onscroll = () => {
			inputLint.scrollTop = inputText.scrollTop;
			inputLint.scrollLeft = inputText.scrollLeft;
		};

		changeTree.onclick = () => {
			if (tokensOutput.style.display !== 'none') {
				ASTOutput.style.display = 'block';
				tokensOutput.style.display = compositesOutput.style.display = 'none';
			} else if (ASTOutput.style.display !== 'none') {
				compositesOutput.style.display = 'block';
				tokensOutput.style.display = ASTOutput.style.display = 'none';
			} else {
				tokensOutput.style.display = 'block';
				ASTOutput.style.display = compositesOutput.style.display = 'none';
			}
		};

		interpret.onclick = () => {
			send({ action: 'interpret', clientId });
		};

		consoleInput.onkeypress = (e) => {
			if (e.key === 'Enter') {
				send({ action: 'evaluate', code: consoleInput.value, clientId });
			}
		};

		// Можно инициализировать сразу:
		// inputText.dispatchEvent(new Event('input'));
	}

	function showClient(id) {
		[...clientViews.children].forEach(c => c.style.display = 'none');
		let view = document.getElementById('client-' + id);
		if (view) view.style.display = 'block';
	}

	function send(action) {
		if (socket && socket.readyState === WebSocket.OPEN) {
			socket.send(JSON.stringify(action));
		}
	}

	openSocket();
	updateProcessTabs([ { ID: 0 }, { ID: 1 } ]);
</script>
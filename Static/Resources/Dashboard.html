<style>
body {
	display: grid;
	grid-template:
		'code trees' max-content
		'console console' auto
		/ max-content auto;
	grid-auto-columns: 0;
	grid-auto-rows: 0;

	height: 100%;

	margin: 0;
}

#inputText,
#inputLint,
#treesOutput,
#console {
	overflow: auto;

	font: 12px monospace;
	tab-size: 4;
	white-space: pre;
}

#inputText,
#inputLint {
	grid-area: code;

	box-sizing: border-box;

	padding: 2px;

	border: none;
	background: rgb(63 63 63 / 1);

	color: rgba(255 255 255 / 0.25);
	caret-color: white;
}

#inputLint {
	background: none;

	color: rgb(191 191 191 / 1);

	pointer-events: none;
}

#treesOutput,
#console {
	grid-area: trees;

	overflow-x: auto;

	background: rgb(223 223 223 / 1);

	font-size: 10px;
}

#console {
	display: flex;
	flex-direction: column;
	grid-area: console;

	background: none;
}

#consoleOutput {
	flex: 1;
}

#buttons {
	display: flex;

	position: fixed;

	margin-left: 24px;
	gap: 8px;
}
</style>
<textarea id="inputText" spellcheck="false" style="width: 55vw; height: 65vh;"></textarea>
<div id="inputLint"></div>
<div id="treesOutput">
	<div id="buttons">
		<button id="changeTree">Change tree</button>
		<button id="interpret">Interpret</button>
	</div>
	<div id="tokensOutput"></div>
	<div id="ASTOutput" style="display: none;"></div>
	<div id="compositesOutput" style="display: none;"></div>
</div>
<div id="console">
	<div id="consoleOutput"></div>
	<input type="text" id="consoleInput">
</div>
<script>
	let inputText = document.getElementById('inputText'),
		inputLint = document.getElementById('inputLint'),
		changeTree = document.getElementById('changeTree'),
		interpret = document.getElementById('interpret'),
		tokensOutput = document.getElementById('tokensOutput'),
		ASTOutput = document.getElementById('ASTOutput'),
		compositesOutput = document.getElementById('compositesOutput'),
		consoleOutput = document.getElementById('consoleOutput'),
		consoleInput = document.getElementById('consoleInput'),
		socket;

	function parse() {
		inputLint.innerHTML = '';

		send({ action: 'lex', code: inputText.value });
		send({ action: 'parse' });
	}

	function openSocket() {
		socket = new WebSocket('ws://'+document.domain+':'+location.port+'/socket');

		socket.onopen = function() {
			if(inputLint.innerHTML === '') {
				parse();
			}
		}

		socket.onmessage = function(event) {
			let report = JSON.parse(event.data);

			if(report.action === 'tokenized') {
				let tokens = report.tokens,
					lintHTML = '';

				for(let k = 0; k < tokens.length; k++) {
					let position = tokens[k].position,
						type = tokens[k].type,
						value = tokens[k].value,
						generated = tokens[k].generated,
						length = value.length,
						element;

					if(type === 'whitespace') {
						for(let i = 0; i < value.length; i++) {
							if(value[i] !== '\n') {
								element ??= document.createElement('span');
								element.innerText += value[i]

								if(value[i+1] === '\n' || i === value.length-1) {
									lintHTML += element.outerHTML;
									element = undefined;
								}
							}
							if(value[i] === '\n') {
								lintHTML += document.createElement('br').outerHTML;
							}
						}
					} else {
						element = document.createElement('span');
						element.innerText = value;

						if(type.startsWith('comment')) {
							element.style.color = 'rgb(95 179 63)';
						}
						if(type.startsWith('string') && !type.startsWith('stringExpression')) {
							element.style.color = 'rgb(191 127 95)';
						}
						if(type.startsWith('operator')) {
							element.style.color = 'rgb(255 191 0)';

							if(type.endsWith('Prefix')) {
								element.style.color = 'rgb(255 63 0)';
							}
							if(type.endsWith('Infix')) {
								element.style.color = 'rgb(255 95 0)';
							}
							if(type.endsWith('Postfix')) {
								element.style.color = 'rgb(255 127 0)';
							}
						}
						if(
							type.startsWith('parenthesis') ||
							type.startsWith('brace') ||
							type.startsWith('bracket') ||
							type === 'delimiter'
						) {
							element.style.color = 'rgb(255 255 255)';
						}
						if(type.startsWith('keyword')) {
							element.style.color = 'rgb(96 151 255)';

							if([
								'nil',
								'true',
								'false'
							].includes(value)) {
								element.style.color = 'rgb(223 127 223)';
							}
						}
						if(type === 'identifier' && value[0] === value[0].toUpperCase()) {
							element.style.color = 'rgb(223 223 223)';
						}
						if(type.startsWith('number')) {
							element.style.color = 'rgb(223 127 223)';
						}
						if(type === 'unsupported') {
							element.style.color = 'transparent';
						}
						if(generated) {
							element.style.fontStyle = 'italic';
						}

						lintHTML += element.outerHTML;
					}
				}

				inputLint.innerHTML = lintHTML;
				inputLint.scrollTop = inputText.scrollTop;
				inputLint.scrollLeft = inputText.scrollLeft;
				tokensOutput.innerText = JSON.stringify(tokens.filter(v => !v.trivia), null, 4);
			} else
			if(report.action === 'parsed') {
				ASTOutput.innerText = JSON.stringify(report.tree, null, 4);
			} else
			if(report.action === 'interpreted') {}

			if(report.action === 'add') {
				let message = report.string,
					color = report.level === 0 ? '0 0 0' : report.level === 1 ? '255 95 0' : '255 0 0',
					transparent = report.source !== 'interpreter',
					weight;

				if(report.location != null) {
					let line = report.location.line+1,
						column = report.location.column+1,
						level = report.level.toString()
											.replace('0', 'Info')
											.replace('1', 'Warning')
											.replace('2', 'Error');

					weight = 'regular';
					message = line+':'+column+': '+level+': '+message;
				} else {
					weight = 'bold';
				}

				let prev = document.createElement('span');

				prev.dataset.source = report.source;
				prev.dataset.position = report.position;
				prev.style.color = `rgba(${color} / ${transparent ? '0.75' : '1'})`;
				prev.style.fontWeight = weight;
				prev.innerText = message;

				let next,
					nodes = [...consoleOutput.children].reverse(),
					sources = ['lexer', 'parser', 'interpreter']

				for(let node of nodes) {
					let nextPosition = node.dataset.position*1,
						prevPosition = report.position,
						nextSource = sources.indexOf(node.dataset.source),
						prevSource = sources.indexOf(report.source);

					if(nextSource > prevSource) {
						next = node;
					} else
					if(
						 nextSource <   prevSource ||
						(nextSource === prevSource && nextPosition <= prevPosition)
					) {
						next = node.nextSibling;

						break;
					}
				}

				consoleOutput.insertBefore(prev, next);
				consoleOutput.scrollTop = consoleOutput.scrollHeight;
			} else
			if(report.action === 'removeAfterPosition') {
				let nodes = [...consoleOutput.children]

				for(let node of nodes) {
					if(node.dataset.source === report.source && node.dataset.position*1 > report.position)  {
						node.remove();
					}
				}
			} else
			if(report.action === 'removeAll') {
				let sources = ['lexer', 'parser', 'interpreter'],
					source = sources.indexOf(report.source);

				if(source === -1) {
					consoleOutput.innerHTML = '';
				} else {
					let toDelete = sources.slice(source),
						nodes = [...consoleOutput.children].filter(n => toDelete.includes(n.dataset.source));

					for(let node of nodes) {
						node.remove();
					}
				}
			}
		}

		socket.onclose = function() {
			socket = undefined;

			setTimeout(openSocket, 5000)
		}
	}

	function send(action) {
		socket?.send?.(JSON.stringify(action));
	}

	inputText.oninput = parse;
	inputText.onscroll = () => {
		inputLint.scrollTop = inputText.scrollTop;
		inputLint.scrollLeft = inputText.scrollLeft;
	}
	changeTree.onclick = () => {
		if(tokensOutput.style.display !== 'none') {
			ASTOutput.style.display = 'block';

			tokensOutput.style.display =
			compositesOutput.style.display = 'none';
		} else
		if(ASTOutput.style.display !== 'none') {
			compositesOutput.style.display = 'block';

			tokensOutput.style.display =
			ASTOutput.style.display = 'none';
		} else {
			tokensOutput.style.display = 'block';

			ASTOutput.style.display =
			compositesOutput.style.display = 'none';
		}
	}
	interpret.onclick = () => {
		send({ action: 'interpret' });
	}
	consoleInput.onkeypress = (e) => {
		if(e.key === 'Enter') {
			send({ action: 'evaluate', code: consoleInput.value });
		}
	}

	openSocket();
</script>
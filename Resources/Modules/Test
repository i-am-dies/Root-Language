func f3() {
	print(caller)

	func () {
		print(caller)
		print(getCallsString())
	}()
}

class B {
	static func f2() {
		print(caller)
		f3()
	}
}

class A {
	static func f1() {
		print(caller)
		B.f2()
	}
}

return A.f1()

var a = 0

class A {
	var a = 1,
		b = -1,
		a_ = print('local a: \(a == 1)'),
		b_ = print('local b: \(b == -1)')

	init(a) {
		print('call self.a: \(self.a == 1)')
		print('call self.b: \(self.b == -1)')
		print('call a: \(a == 2)')
		print('call b: \(b == -1)')

		class B {
			static var a = a,
					   b = b,
					   a_ = print('local (nested) a: \(a == 2)'),
					   b_ = print('local (nested) b: \(b == -1)'),
					   c_ = print('local (nested) f1.s: \(f1.s == 10) == false'),
					   d_ = print('local (nested) f2.s: \(f2.s == 20)')
		}
	}

	func f1() {
		static var s = 10

		return ++s
	}

	static func f2() {
		static var s = 20

		return ++s
	}
}

namespace B {
	namespace C {
		var b = 1

		class D {
			static namespace E {
				func f() {
					static var c = 2,
							   a_ = print('local (nested ns) a: \(a == 0)'),
							   b_ = print('local (nested ns) b: \(b == 1)'),
							   c_ = print('local (nested ns) c: \(c == 2)')
				}
			}
		}
	}
}

var a_ins = A(2)

print('global a: \(a == 0)')
print('global a_ins.a: \(a_ins.a == 1)')
print('global a_ins.b: \(a_ins.b == -1)')

print('global A.f1.s: \(A.f1.s == 10)')
print('global a_ins.f1.s: \(a_ins.f1.s == 10) == false')

print('Add to static 1 \(a_ins.f1() == 11)')
print('Add to static 1 \(a_ins.f1() == 12)')
print('Add to static 1 \(a_ins.f1() == 13)')

print('global A.f2.s: \(A.f2.s == 20)')
print('global a_ins.f2.s: \(a_ins.f2.s == 20)')

print('Add to static 2 \(A.f2() == 21)')
print('Add to static 2 \(A.f2() == 22)')
print('Add to static 2 \(A.'\('f2')'() == 23)')

print('global B.C.D.E.f.a: \(B.C.D.E.f.a == 0) == false')
print('global B.C.D.E.f.b: \(B.C.D.E.f.b == 1) == false')
print('global B.C.D.E.f.c: \(B.C.D.E.f.c == 2)')

return

var a: type = type ((String, F) -> Int)?

return

class A {
	static func e() { 1 }
}

class B: A {
	static func t() {
		print(Super.e())
	}
}

B.t()

return

class A {
	var a: Int = -1,
		b: (Int) -> ()

	init(/*_*/ b: /*@escaping*/ (Int) -> ()) {
		self.b = b
		self.b(0)
	}
}

class B {
	var a: Int = -1,
		b: (Int) -> ()

	init(/*_*/ b: /*@escaping*/ (Int) -> ()) {
		self.b = b
		self.b(1)
	}
}

struct C {
	static var a: Int = 0

	static func e(n: Int) -> () {
		self.a = n
	}
}

var a = A(C.e),
	b = B(C.e)

print(a.a == -1)
print(b.a == -1)
print(C.a == 1)

return

var b

class A {
	class B {
		static var c
	}

	init(c) {
		B.c = c; print(B.c)
	}
}

b = A(1)
//b = nil

return b

class A {
	init {
		print(self)

		var self = 1

		print(self)
	}
}

return A()

class Base {
	init {
		f()
	}

	/*virtual*/ func f() {
		print('Base')
	}
}

class Derived: Base {
	init {
		super()
		f()
	}

	func f() {
		print('Derived')
	}
}

var d = Derived()

return d

var b

class A {
	init(c) {
		b = c; print(1)
	}

	deinit {
		b = Self

		print(b)
	}
}

A(1)
A = nil

return b

var b

class A {
	init(c) {
		b = c; print(1)
	}
}

A(1)

return b

var b

class A {
	deinit {
		b = Self

		print(b)
	}
}

A = nil

return b

struct A {
	struct B {}

	var E
}

func a() {
	class C {
		var b = A.B
	}

	A.B = 1
	//A.E = C.b

	struct A {}
}

return a()

var primitiveArray = [1, 2, 3, 4],
	primitiveDictionary = [1: 2, 3: 4]

class Animal {
	init {}

	func say() {
		'...'
	}
}

class Canine: Animal {
	init {}
}

class Fox: Canine {
	init {}

	func say() {
		'Yiff'
	}
}

class Wolf: Canine {
	func say() {
		'Auf'
	}
}

class Dog: Canine {
	func say() {
		'Bark'
	}
}

class Feline: Animal {}

class Cat: Feline {
	func say() {
		'Meow'
	}
}

var fox = Fox()

func family(a: Animal) {
	'Is \(a.Self.metaSelf.title)'
}

func family(a: Fox) {
	'Is vulpes'
}

func family(a: Dog | Wolf) {
	'Is canine'
}

family(Fox())
family(Dog())
family(Wolf())
family(Cat())

func testFlowTransfer() {
	if true {
		if true {
			var a = 1

			return a
		} else
		if true {
			return 2

			3
		}
	} else {
		4
	}

	//5
}

var flowTransferTest = testFlowTransfer()


func do_(a) {
  a(4)
}

struct Person {
  var age = 0

  func change() {
	do_(func (age) {
	  self.age = ++age
	})
  }
}

Person.change()

struct Array {}

var a: [Global]

func A() {
	struct AB {}  // Retain chain: AB -> A() -> Global

	return AB
}

func B() {
	A()

	return A()
}

func C(CC) {
	return CC
}

var retainTest = C(CC: B())  // Preserve value globally, simple return cleans up memory

return retainTest

/*
func D() {
	struct E {
		func F() {
			struct G {
				func a()

				func H() {
					struct J {}  // J > H(), G, F(), E, D(), Global

					return J
				}
			}

			G.a()

			return G.H()
		}
	}

	return E.F()
}

var retainTest = D()

return retainTest
*/

//var f = A.D,
//	A,
//	f

func test(a: inout _?, and b) {
	return a != b
}

var a: Function | bool = 1

if i > -a { b } { c }  // sequence, prefixed
if i > a { b } { c }   // sequence, non prefixed
if -a { b } { c }      // non sequence, prefixed
if a { b } { c }       // non sequence, non prefixed

for i in 0...3 {

} where i > -1 {  // sequence, prefixed
	print(i)
}
+ outside

for i in 0...3 where i > -1 {  // sequence, prefixed
	print(i)
}

// ---- ---- ---- ----

/* Multiblock
	/* Comment */
		Block */

// Comment Line

import Foundation

final var Boolean = Foundation.Boolean,
		  Number = Foundation.Number,
		  Decimal = Foundation.Decimal,
		  Integer = Foundation.Integer,
		  String = Foundation.String,
		  Array = Foundation.Array,
		  Dictionary = Foundation.Dictionary

final var constant = Number.Pi

var variable

if constant > 0 {
	variable = 1
}

class A {
	private final var constant: Number = 0.5

	protected var variable: Integer = 1

	var variable_01a = 'String'

	var anotherVariable {
		willGet {}
		get {
			return value
		}
		didGet {}

		willSet {}
		set {
			value = newValue
		}
		didSet {}
	}

	chain {
		get {
			return metaSelf.members[key]?.value
		}
		set {
			metaSelf.members[key] = value
		}
		delete {
			delete metaSelf.members[key]
		}
	}

	subscript(a: Integer, b: Integer) -> Integer {
		get {
			return a+b
		}
		set {
			print(a, b)
		}
	}

	init(with number: Integer = 0, and string_: String) {
		print('Intitializing with \(number) and \(string_)')

		variable = number
		variable_01a = string_
	}

	deinit {
		print('Deinitializing!')
	}
}

var instance = A(with: 12, and: '2')

/*
var self.A: self.Class = class { ... }

var self.instance = A(with: 12, and: '2')
*/

print('Testing nested template string: printing some \(identifier+'abc\(1+2+3)def'+0.125) and \(instance.variable)')

var instance_2 = struct {
	init(test: Integer) {
		print('Initialized anonymous struct with testing variable: '+test)
	}
}(12)

instance =
instance_2 = nil

enum B {
	case first
	case second
	case third
	case fourth
}

var enum_value: B = .first

var function

/*
function = { x in x > 0 } - 1

function = (x) in x > 0
function = (x) { x > 0 }
function = (x) { return x > 0 } - 2

function = func (x) in x > 0
function = func (x) { x > 0 }
function = func (x) { return x > 0 } - 3

func getMnemonic(color: Color) =
	when color {
		.RED -> "кот"
		.ORANGE -> "охотник"
		.YELLOW -> "желает"
		.GREEN -> "знать"
		.BLUE -> "где"
		.INDIGO -> "сидят"
		.VIOLET -> "фазаны"
	}

func getWarmth(color: Int) {
	when color {
		RED || YELLOW: 'warm'
		GREEN: 'neutral'
		BLUE: 'cold'
		else: 'unknown'
	}
}
*/

when catImageView.visibility {
	View.VISIBLE -> println('visible')
	View.INVISIBLE -> println('invisible')
	else -> println('gone')
}

var switchedByDictionary = [
	case1: { 0 },
	case2: { nil }
][case_]?()

var A = 1

print(A)		// 1

if true {		// If statements have local scopes
	print(A)	// class (Declarations execute first)

	class A {}
}

print(A)		// 1

A = class {}

print(A)		// class
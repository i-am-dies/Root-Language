class A {
	init {
		print(self)

		var self = 1

		print(self)
	}
}

return A()

class Base {
	init {
		f()
	}

	/*virtual*/ func f() {
		print('Base')
	}
}

class Derived: Base {
	init {
		super()
        f()
	}

	func f() {
		print('Derived')
	}
}

var d = Derived()

return d

var b

class A {
	init(c) {
		b = c; print(1)
	}

	deinit {
		b = Self

		print(b)
	}
}

A(1)
A = nil

return b

var b

class A {
	init(c) {
		b = c; print(1)
	}
}

A(1)

return b

var b

class A {
	deinit {
		b = Self

		print(b)
	}
}

A = nil

return b

struct A {
    struct B {}

    var E
}

func a() {
    class C {
        var b = A.B
    }

    A.B = 1
    //A.E = C.b

    struct A {}
}

return a()

var primitiveArray = [1, 2, 3, 4],
	primitiveDictionary = [1: 2, 3: 4]

class Animal {
    init {}

	func say() {
		'...'
	}
}

class Canine: Animal {
    init {}
}

class Fox: Canine {
    init {}

	func say() {
		'Yiff'
	}
}

class Wolf: Canine {
	func say() {
		'Auf'
	}
}

class Dog: Canine {
	func say() {
		'Bark'
	}
}

class Feline: Animal {}

class Cat: Feline {
	func say() {
		'Meow'
	}
}

var fox = Fox()

func family(a: Animal) {
	'Is \(a.Self.metaSelf.title)'
}

func family(a: Fox) {
	'Is vulpes'
}

func family(a: Dog | Wolf) {
	'Is canine'
}

family(Fox())
family(Dog())
family(Wolf())
family(Cat())

func testFlowTransfer() {
    if true {
        if true {
        	var a = 1

        	return a
        } else
        if true {
        	return 2

        	3
        }
    } else {
        4
    }

    //5
}

var flowTransferTest = testFlowTransfer()


func do_(a) {
  a(4)
}

struct Person {
  var age = 0

  func change() {
    do_(func (age) {
      self.age = ++age
    })
  }
}

Person.change()

struct Array {}

var a: [Global]

func A() {
	struct AB {}  // Retain chain: AB -> A() -> Global

    return AB
}

func B() {
	A()

    return A()
}

func C(CC) {
    return CC
}

var retainTest = C(CC: B())  // Preserve value globally, simple return cleans up memory

return retainTest

/*
func D() {
	struct E {
		func F() {
			struct G {
				func a()

				func H() {
					struct J {}  // J > H(), G, F(), E, D(), Global

					return J
				}
			}

			G.a()

			return G.H()
		}
    }

    return E.F()
}

var retainTest = D()

return retainTest
*/

//var f = A.D,
//	A,
//	f

func test(a: inout _?, and b) {
	return a != b
}

var a: Function | bool = 1

if i > -a { b } { c }  // sequence, prefixed
if i > a { b } { c }   // sequence, non prefixed
if -a { b } { c }      // non sequence, prefixed
if a { b } { c }       // non sequence, non prefixed

for i in 0...3 {

} where i > -1 {  // sequence, prefixed
	print(i)
}
+ outside

for i in 0...3 where i > -1 {  // sequence, prefixed
	print(i)
}

// ---- ---- ---- ----

/* Multiblock
	/* Comment */
		Block */

// Comment Line

import Foundation

final var Boolean = Foundation.Boolean,
	  	  Number = Foundation.Number,
	  	  Decimal = Foundation.Decimal,
	  	  Integer = Foundation.Integer,
	  	  String = Foundation.String,
	  	  Array = Foundation.Array,
	  	  Dictionary = Foundation.Dictionary

final var constant = Number.Pi

var variable

if constant > 0 {
	variable = 1
}

class A {
	private final var constant: Number = 0.5

	protected var variable: Integer = 1

	var variable_01a = 'String'

	var anotherVariable {
		willGet {}
		get {
			return value
		}
		didGet {}

		willSet {}
		set {
			value = newValue
		}
		didSet {}
	}

	chain {
		get {
			return metaSelf.members[key]?.value
		}
		set {
			metaSelf.members[key] = value
		}
		delete {
			delete metaSelf.members[key]
		}
	}

	subscript(a: Integer, b: Integer) -> Integer {
		get {
			return a+b
		}
		set {
			print(a, b)
		}
	}

	init(with number: Integer = 0, and string_: String) {
		print('Intitializing with \(number) and \(string_)')

		variable = number
		variable_01a = string_
	}

	deinit {
		print('Deinitializing!')
	}
}

var instance = A(with: 12, and: '2')

/*
var self.A: self.Class = class { ... }

var self.instance = A(with: 12, and: '2')
*/

print('Testing nested template string: printing some \(identifier+'abc\(1+2+3)def'+0.125) and \(instance.variable)')

var instance_2 = struct {
	init(test: Integer) {
		print('Initialized anonymous struct with testing variable: '+test)
	}
}(12)

instance =
instance_2 = nil

enum B {
	case first
	case second
	case third
	case fourth
}

var enum_value: B = .first

var function

/*
function = { x in x > 0 } - 1

function = (x) in x > 0
function = (x) { x > 0 }
function = (x) { return x > 0 } - 2

function = func (x) in x > 0
function = func (x) { x > 0 }
function = func (x) { return x > 0 } - 3

func getMnemonic(color: Color) =
    when color {
        .RED -> "кот"
        .ORANGE -> "охотник"
        .YELLOW -> "желает"
        .GREEN -> "знать"
        .BLUE -> "где"
        .INDIGO -> "сидят"
        .VIOLET -> "фазаны"
	}

func getWarmth(color: Int) {
	when color {
	    RED || YELLOW: 'warm'
	    GREEN: 'neutral'
	    BLUE: 'cold'
	    else: 'unknown'
	}
}
*/

when catImageView.visibility {
    View.VISIBLE -> println('visible')
    View.INVISIBLE -> println('invisible')
    else -> println('gone')
}

var switchedByDictionary = [
	case1: { 0 },
	case2: { nil }
][case_]?()

var A = 1

print(A)		// 1

if true {		// If statements have local scopes
	print(A)	// class (Declarations execute first)

	class A {}
}

print(A)		// 1

A = class {}

print(A)		// class